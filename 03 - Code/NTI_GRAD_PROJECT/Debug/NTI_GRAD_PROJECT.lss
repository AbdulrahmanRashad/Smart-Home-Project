
NTI_GRAD_PROJECT.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005c56  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000076a  00800060  00005c56  00005cea  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000003e  008007ca  008007ca  00006454  2**0
                  ALLOC
  3 .stab         0000bae4  00000000  00000000  00006454  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00005138  00000000  00000000  00011f38  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00017070  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000197  00000000  00000000  000171b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001a88  00000000  00000000  00017347  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eb7  00000000  00000000  00018dcf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000df7  00000000  00000000  00019c86  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0001aa80  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002bf  00000000  00000000  0001abe0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007f2  00000000  00000000  0001ae9f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6e 00 	jmp	0xdc	; 0xdc <__ctors_end>
       4:	0c 94 69 0d 	jmp	0x1ad2	; 0x1ad2 <__vector_1>
       8:	0c 94 92 0d 	jmp	0x1b24	; 0x1b24 <__vector_2>
       c:	0c 94 bb 0d 	jmp	0x1b76	; 0x1b76 <__vector_3>
      10:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
      14:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
      18:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
      1c:	0c 94 62 09 	jmp	0x12c4	; 0x12c4 <__vector_7>
      20:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
      24:	0c 94 34 09 	jmp	0x1268	; 0x1268 <__vector_9>
      28:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
      2c:	0c 94 92 0b 	jmp	0x1724	; 0x1724 <__vector_11>
      30:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
      34:	0c 94 44 07 	jmp	0xe88	; 0xe88 <__vector_13>
      38:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
      3c:	0c 94 1b 07 	jmp	0xe36	; 0xe36 <__vector_15>
      40:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
      44:	0c 94 96 0c 	jmp	0x192c	; 0x192c <__vector_17>
      48:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
      4c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
      50:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
      54:	8c 28       	or	r8, r12
      56:	9e 28       	or	r9, r14
      58:	b0 28       	or	r11, r0
      5a:	b6 28       	or	r11, r6
      5c:	65 2b       	or	r22, r21
      5e:	6b 2b       	or	r22, r27
      60:	71 2b       	or	r23, r17
      62:	77 2b       	or	r23, r23
      64:	7d 2b       	or	r23, r29
      66:	83 2b       	or	r24, r19
      68:	89 2b       	or	r24, r25
      6a:	10 2c       	mov	r1, r0
      6c:	16 2c       	mov	r1, r6
      6e:	1c 2c       	mov	r1, r12
      70:	22 2c       	mov	r2, r2
      72:	28 2c       	mov	r2, r8
      74:	2e 2c       	mov	r2, r14
      76:	34 2c       	mov	r3, r4
      78:	3a 2c       	mov	r3, r10
      7a:	40 2c       	mov	r4, r0
      7c:	46 2c       	mov	r4, r6
      7e:	33 28       	or	r3, r3
      80:	92 28       	or	r9, r2
      82:	98 28       	or	r9, r8
      84:	a4 28       	or	r10, r4
      86:	aa 28       	or	r10, r10
      88:	bc 28       	or	r11, r12
      8a:	c2 28       	or	r12, r2
      8c:	c8 28       	or	r12, r8
      8e:	23 2a       	or	r2, r19
      90:	3f 2b       	or	r19, r31
      92:	59 2b       	or	r21, r25
      94:	5f 2b       	or	r21, r31
      96:	8f 2b       	or	r24, r31
      98:	95 2b       	or	r25, r21
      9a:	9b 2b       	or	r25, r27
      9c:	a1 2b       	or	r26, r17
      9e:	e6 2b       	or	r30, r22
      a0:	ec 2b       	or	r30, r28
      a2:	f2 2b       	or	r31, r18
      a4:	f8 2b       	or	r31, r24
      a6:	fe 2b       	or	r31, r30
      a8:	04 2c       	mov	r0, r4
      aa:	0a 2c       	mov	r0, r10
      ac:	4c 2c       	mov	r4, r12
      ae:	52 2c       	mov	r5, r2
      b0:	58 2c       	mov	r5, r8
      b2:	5e 2c       	mov	r5, r14
      b4:	64 2c       	mov	r6, r4
      b6:	6a 2c       	mov	r6, r10
      b8:	70 2c       	mov	r7, r0
      ba:	76 2c       	mov	r7, r6
      bc:	7c 2c       	mov	r7, r12
      be:	82 2c       	mov	r8, r2
      c0:	88 2c       	mov	r8, r8
      c2:	8e 2c       	mov	r8, r14
      c4:	94 2c       	mov	r9, r4
      c6:	9a 2c       	mov	r9, r10
      c8:	a0 2c       	mov	r10, r0
      ca:	a6 2c       	mov	r10, r6
      cc:	ac 2c       	mov	r10, r12
      ce:	b2 2c       	mov	r11, r2
      d0:	b8 2c       	mov	r11, r8
      d2:	be 2c       	mov	r11, r14
      d4:	c4 2c       	mov	r12, r4
      d6:	ca 2c       	mov	r12, r10
      d8:	d0 2c       	mov	r13, r0
      da:	d6 2c       	mov	r13, r6

000000dc <__ctors_end>:
      dc:	11 24       	eor	r1, r1
      de:	1f be       	out	0x3f, r1	; 63
      e0:	cf e5       	ldi	r28, 0x5F	; 95
      e2:	d8 e0       	ldi	r29, 0x08	; 8
      e4:	de bf       	out	0x3e, r29	; 62
      e6:	cd bf       	out	0x3d, r28	; 61

000000e8 <__do_copy_data>:
      e8:	17 e0       	ldi	r17, 0x07	; 7
      ea:	a0 e6       	ldi	r26, 0x60	; 96
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	e6 e5       	ldi	r30, 0x56	; 86
      f0:	fc e5       	ldi	r31, 0x5C	; 92
      f2:	02 c0       	rjmp	.+4      	; 0xf8 <.do_copy_data_start>

000000f4 <.do_copy_data_loop>:
      f4:	05 90       	lpm	r0, Z+
      f6:	0d 92       	st	X+, r0

000000f8 <.do_copy_data_start>:
      f8:	aa 3c       	cpi	r26, 0xCA	; 202
      fa:	b1 07       	cpc	r27, r17
      fc:	d9 f7       	brne	.-10     	; 0xf4 <.do_copy_data_loop>

000000fe <__do_clear_bss>:
      fe:	18 e0       	ldi	r17, 0x08	; 8
     100:	aa ec       	ldi	r26, 0xCA	; 202
     102:	b7 e0       	ldi	r27, 0x07	; 7
     104:	01 c0       	rjmp	.+2      	; 0x108 <.do_clear_bss_start>

00000106 <.do_clear_bss_loop>:
     106:	1d 92       	st	X+, r1

00000108 <.do_clear_bss_start>:
     108:	a8 30       	cpi	r26, 0x08	; 8
     10a:	b1 07       	cpc	r27, r17
     10c:	e1 f7       	brne	.-8      	; 0x106 <.do_clear_bss_loop>
     10e:	0e 94 38 2d 	call	0x5a70	; 0x5a70 <main>
     112:	0c 94 29 2e 	jmp	0x5c52	; 0x5c52 <_exit>

00000116 <__bad_interrupt>:
     116:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000011a <__fixunssfsi>:
     11a:	ef 92       	push	r14
     11c:	ff 92       	push	r15
     11e:	0f 93       	push	r16
     120:	1f 93       	push	r17
     122:	7b 01       	movw	r14, r22
     124:	8c 01       	movw	r16, r24
     126:	20 e0       	ldi	r18, 0x00	; 0
     128:	30 e0       	ldi	r19, 0x00	; 0
     12a:	40 e0       	ldi	r20, 0x00	; 0
     12c:	5f e4       	ldi	r21, 0x4F	; 79
     12e:	0e 94 0f 03 	call	0x61e	; 0x61e <__gesf2>
     132:	88 23       	and	r24, r24
     134:	8c f0       	brlt	.+34     	; 0x158 <__fixunssfsi+0x3e>
     136:	c8 01       	movw	r24, r16
     138:	b7 01       	movw	r22, r14
     13a:	20 e0       	ldi	r18, 0x00	; 0
     13c:	30 e0       	ldi	r19, 0x00	; 0
     13e:	40 e0       	ldi	r20, 0x00	; 0
     140:	5f e4       	ldi	r21, 0x4F	; 79
     142:	0e 94 05 02 	call	0x40a	; 0x40a <__subsf3>
     146:	0e 94 3f 03 	call	0x67e	; 0x67e <__fixsfsi>
     14a:	9b 01       	movw	r18, r22
     14c:	ac 01       	movw	r20, r24
     14e:	20 50       	subi	r18, 0x00	; 0
     150:	30 40       	sbci	r19, 0x00	; 0
     152:	40 40       	sbci	r20, 0x00	; 0
     154:	50 48       	sbci	r21, 0x80	; 128
     156:	06 c0       	rjmp	.+12     	; 0x164 <__fixunssfsi+0x4a>
     158:	c8 01       	movw	r24, r16
     15a:	b7 01       	movw	r22, r14
     15c:	0e 94 3f 03 	call	0x67e	; 0x67e <__fixsfsi>
     160:	9b 01       	movw	r18, r22
     162:	ac 01       	movw	r20, r24
     164:	b9 01       	movw	r22, r18
     166:	ca 01       	movw	r24, r20
     168:	1f 91       	pop	r17
     16a:	0f 91       	pop	r16
     16c:	ff 90       	pop	r15
     16e:	ef 90       	pop	r14
     170:	08 95       	ret

00000172 <_fpadd_parts>:
     172:	a0 e0       	ldi	r26, 0x00	; 0
     174:	b0 e0       	ldi	r27, 0x00	; 0
     176:	ef eb       	ldi	r30, 0xBF	; 191
     178:	f0 e0       	ldi	r31, 0x00	; 0
     17a:	0c 94 c3 2d 	jmp	0x5b86	; 0x5b86 <__prologue_saves__>
     17e:	dc 01       	movw	r26, r24
     180:	2b 01       	movw	r4, r22
     182:	fa 01       	movw	r30, r20
     184:	9c 91       	ld	r25, X
     186:	92 30       	cpi	r25, 0x02	; 2
     188:	08 f4       	brcc	.+2      	; 0x18c <_fpadd_parts+0x1a>
     18a:	39 c1       	rjmp	.+626    	; 0x3fe <_fpadd_parts+0x28c>
     18c:	eb 01       	movw	r28, r22
     18e:	88 81       	ld	r24, Y
     190:	82 30       	cpi	r24, 0x02	; 2
     192:	08 f4       	brcc	.+2      	; 0x196 <_fpadd_parts+0x24>
     194:	33 c1       	rjmp	.+614    	; 0x3fc <_fpadd_parts+0x28a>
     196:	94 30       	cpi	r25, 0x04	; 4
     198:	69 f4       	brne	.+26     	; 0x1b4 <_fpadd_parts+0x42>
     19a:	84 30       	cpi	r24, 0x04	; 4
     19c:	09 f0       	breq	.+2      	; 0x1a0 <_fpadd_parts+0x2e>
     19e:	2f c1       	rjmp	.+606    	; 0x3fe <_fpadd_parts+0x28c>
     1a0:	11 96       	adiw	r26, 0x01	; 1
     1a2:	9c 91       	ld	r25, X
     1a4:	11 97       	sbiw	r26, 0x01	; 1
     1a6:	89 81       	ldd	r24, Y+1	; 0x01
     1a8:	98 17       	cp	r25, r24
     1aa:	09 f4       	brne	.+2      	; 0x1ae <_fpadd_parts+0x3c>
     1ac:	28 c1       	rjmp	.+592    	; 0x3fe <_fpadd_parts+0x28c>
     1ae:	aa e9       	ldi	r26, 0x9A	; 154
     1b0:	b6 e0       	ldi	r27, 0x06	; 6
     1b2:	25 c1       	rjmp	.+586    	; 0x3fe <_fpadd_parts+0x28c>
     1b4:	84 30       	cpi	r24, 0x04	; 4
     1b6:	09 f4       	brne	.+2      	; 0x1ba <_fpadd_parts+0x48>
     1b8:	21 c1       	rjmp	.+578    	; 0x3fc <_fpadd_parts+0x28a>
     1ba:	82 30       	cpi	r24, 0x02	; 2
     1bc:	a9 f4       	brne	.+42     	; 0x1e8 <_fpadd_parts+0x76>
     1be:	92 30       	cpi	r25, 0x02	; 2
     1c0:	09 f0       	breq	.+2      	; 0x1c4 <_fpadd_parts+0x52>
     1c2:	1d c1       	rjmp	.+570    	; 0x3fe <_fpadd_parts+0x28c>
     1c4:	9a 01       	movw	r18, r20
     1c6:	ad 01       	movw	r20, r26
     1c8:	88 e0       	ldi	r24, 0x08	; 8
     1ca:	ea 01       	movw	r28, r20
     1cc:	09 90       	ld	r0, Y+
     1ce:	ae 01       	movw	r20, r28
     1d0:	e9 01       	movw	r28, r18
     1d2:	09 92       	st	Y+, r0
     1d4:	9e 01       	movw	r18, r28
     1d6:	81 50       	subi	r24, 0x01	; 1
     1d8:	c1 f7       	brne	.-16     	; 0x1ca <_fpadd_parts+0x58>
     1da:	e2 01       	movw	r28, r4
     1dc:	89 81       	ldd	r24, Y+1	; 0x01
     1de:	11 96       	adiw	r26, 0x01	; 1
     1e0:	9c 91       	ld	r25, X
     1e2:	89 23       	and	r24, r25
     1e4:	81 83       	std	Z+1, r24	; 0x01
     1e6:	08 c1       	rjmp	.+528    	; 0x3f8 <_fpadd_parts+0x286>
     1e8:	92 30       	cpi	r25, 0x02	; 2
     1ea:	09 f4       	brne	.+2      	; 0x1ee <_fpadd_parts+0x7c>
     1ec:	07 c1       	rjmp	.+526    	; 0x3fc <_fpadd_parts+0x28a>
     1ee:	12 96       	adiw	r26, 0x02	; 2
     1f0:	2d 90       	ld	r2, X+
     1f2:	3c 90       	ld	r3, X
     1f4:	13 97       	sbiw	r26, 0x03	; 3
     1f6:	eb 01       	movw	r28, r22
     1f8:	8a 81       	ldd	r24, Y+2	; 0x02
     1fa:	9b 81       	ldd	r25, Y+3	; 0x03
     1fc:	14 96       	adiw	r26, 0x04	; 4
     1fe:	ad 90       	ld	r10, X+
     200:	bd 90       	ld	r11, X+
     202:	cd 90       	ld	r12, X+
     204:	dc 90       	ld	r13, X
     206:	17 97       	sbiw	r26, 0x07	; 7
     208:	ec 80       	ldd	r14, Y+4	; 0x04
     20a:	fd 80       	ldd	r15, Y+5	; 0x05
     20c:	0e 81       	ldd	r16, Y+6	; 0x06
     20e:	1f 81       	ldd	r17, Y+7	; 0x07
     210:	91 01       	movw	r18, r2
     212:	28 1b       	sub	r18, r24
     214:	39 0b       	sbc	r19, r25
     216:	b9 01       	movw	r22, r18
     218:	37 ff       	sbrs	r19, 7
     21a:	04 c0       	rjmp	.+8      	; 0x224 <_fpadd_parts+0xb2>
     21c:	66 27       	eor	r22, r22
     21e:	77 27       	eor	r23, r23
     220:	62 1b       	sub	r22, r18
     222:	73 0b       	sbc	r23, r19
     224:	60 32       	cpi	r22, 0x20	; 32
     226:	71 05       	cpc	r23, r1
     228:	0c f0       	brlt	.+2      	; 0x22c <_fpadd_parts+0xba>
     22a:	61 c0       	rjmp	.+194    	; 0x2ee <_fpadd_parts+0x17c>
     22c:	12 16       	cp	r1, r18
     22e:	13 06       	cpc	r1, r19
     230:	6c f5       	brge	.+90     	; 0x28c <_fpadd_parts+0x11a>
     232:	37 01       	movw	r6, r14
     234:	48 01       	movw	r8, r16
     236:	06 2e       	mov	r0, r22
     238:	04 c0       	rjmp	.+8      	; 0x242 <_fpadd_parts+0xd0>
     23a:	96 94       	lsr	r9
     23c:	87 94       	ror	r8
     23e:	77 94       	ror	r7
     240:	67 94       	ror	r6
     242:	0a 94       	dec	r0
     244:	d2 f7       	brpl	.-12     	; 0x23a <_fpadd_parts+0xc8>
     246:	21 e0       	ldi	r18, 0x01	; 1
     248:	30 e0       	ldi	r19, 0x00	; 0
     24a:	40 e0       	ldi	r20, 0x00	; 0
     24c:	50 e0       	ldi	r21, 0x00	; 0
     24e:	04 c0       	rjmp	.+8      	; 0x258 <_fpadd_parts+0xe6>
     250:	22 0f       	add	r18, r18
     252:	33 1f       	adc	r19, r19
     254:	44 1f       	adc	r20, r20
     256:	55 1f       	adc	r21, r21
     258:	6a 95       	dec	r22
     25a:	d2 f7       	brpl	.-12     	; 0x250 <_fpadd_parts+0xde>
     25c:	21 50       	subi	r18, 0x01	; 1
     25e:	30 40       	sbci	r19, 0x00	; 0
     260:	40 40       	sbci	r20, 0x00	; 0
     262:	50 40       	sbci	r21, 0x00	; 0
     264:	2e 21       	and	r18, r14
     266:	3f 21       	and	r19, r15
     268:	40 23       	and	r20, r16
     26a:	51 23       	and	r21, r17
     26c:	21 15       	cp	r18, r1
     26e:	31 05       	cpc	r19, r1
     270:	41 05       	cpc	r20, r1
     272:	51 05       	cpc	r21, r1
     274:	21 f0       	breq	.+8      	; 0x27e <_fpadd_parts+0x10c>
     276:	21 e0       	ldi	r18, 0x01	; 1
     278:	30 e0       	ldi	r19, 0x00	; 0
     27a:	40 e0       	ldi	r20, 0x00	; 0
     27c:	50 e0       	ldi	r21, 0x00	; 0
     27e:	79 01       	movw	r14, r18
     280:	8a 01       	movw	r16, r20
     282:	e6 28       	or	r14, r6
     284:	f7 28       	or	r15, r7
     286:	08 29       	or	r16, r8
     288:	19 29       	or	r17, r9
     28a:	3c c0       	rjmp	.+120    	; 0x304 <_fpadd_parts+0x192>
     28c:	23 2b       	or	r18, r19
     28e:	d1 f1       	breq	.+116    	; 0x304 <_fpadd_parts+0x192>
     290:	26 0e       	add	r2, r22
     292:	37 1e       	adc	r3, r23
     294:	35 01       	movw	r6, r10
     296:	46 01       	movw	r8, r12
     298:	06 2e       	mov	r0, r22
     29a:	04 c0       	rjmp	.+8      	; 0x2a4 <_fpadd_parts+0x132>
     29c:	96 94       	lsr	r9
     29e:	87 94       	ror	r8
     2a0:	77 94       	ror	r7
     2a2:	67 94       	ror	r6
     2a4:	0a 94       	dec	r0
     2a6:	d2 f7       	brpl	.-12     	; 0x29c <_fpadd_parts+0x12a>
     2a8:	21 e0       	ldi	r18, 0x01	; 1
     2aa:	30 e0       	ldi	r19, 0x00	; 0
     2ac:	40 e0       	ldi	r20, 0x00	; 0
     2ae:	50 e0       	ldi	r21, 0x00	; 0
     2b0:	04 c0       	rjmp	.+8      	; 0x2ba <_fpadd_parts+0x148>
     2b2:	22 0f       	add	r18, r18
     2b4:	33 1f       	adc	r19, r19
     2b6:	44 1f       	adc	r20, r20
     2b8:	55 1f       	adc	r21, r21
     2ba:	6a 95       	dec	r22
     2bc:	d2 f7       	brpl	.-12     	; 0x2b2 <_fpadd_parts+0x140>
     2be:	21 50       	subi	r18, 0x01	; 1
     2c0:	30 40       	sbci	r19, 0x00	; 0
     2c2:	40 40       	sbci	r20, 0x00	; 0
     2c4:	50 40       	sbci	r21, 0x00	; 0
     2c6:	2a 21       	and	r18, r10
     2c8:	3b 21       	and	r19, r11
     2ca:	4c 21       	and	r20, r12
     2cc:	5d 21       	and	r21, r13
     2ce:	21 15       	cp	r18, r1
     2d0:	31 05       	cpc	r19, r1
     2d2:	41 05       	cpc	r20, r1
     2d4:	51 05       	cpc	r21, r1
     2d6:	21 f0       	breq	.+8      	; 0x2e0 <_fpadd_parts+0x16e>
     2d8:	21 e0       	ldi	r18, 0x01	; 1
     2da:	30 e0       	ldi	r19, 0x00	; 0
     2dc:	40 e0       	ldi	r20, 0x00	; 0
     2de:	50 e0       	ldi	r21, 0x00	; 0
     2e0:	59 01       	movw	r10, r18
     2e2:	6a 01       	movw	r12, r20
     2e4:	a6 28       	or	r10, r6
     2e6:	b7 28       	or	r11, r7
     2e8:	c8 28       	or	r12, r8
     2ea:	d9 28       	or	r13, r9
     2ec:	0b c0       	rjmp	.+22     	; 0x304 <_fpadd_parts+0x192>
     2ee:	82 15       	cp	r24, r2
     2f0:	93 05       	cpc	r25, r3
     2f2:	2c f0       	brlt	.+10     	; 0x2fe <_fpadd_parts+0x18c>
     2f4:	1c 01       	movw	r2, r24
     2f6:	aa 24       	eor	r10, r10
     2f8:	bb 24       	eor	r11, r11
     2fa:	65 01       	movw	r12, r10
     2fc:	03 c0       	rjmp	.+6      	; 0x304 <_fpadd_parts+0x192>
     2fe:	ee 24       	eor	r14, r14
     300:	ff 24       	eor	r15, r15
     302:	87 01       	movw	r16, r14
     304:	11 96       	adiw	r26, 0x01	; 1
     306:	9c 91       	ld	r25, X
     308:	d2 01       	movw	r26, r4
     30a:	11 96       	adiw	r26, 0x01	; 1
     30c:	8c 91       	ld	r24, X
     30e:	98 17       	cp	r25, r24
     310:	09 f4       	brne	.+2      	; 0x314 <_fpadd_parts+0x1a2>
     312:	45 c0       	rjmp	.+138    	; 0x39e <_fpadd_parts+0x22c>
     314:	99 23       	and	r25, r25
     316:	39 f0       	breq	.+14     	; 0x326 <_fpadd_parts+0x1b4>
     318:	a8 01       	movw	r20, r16
     31a:	97 01       	movw	r18, r14
     31c:	2a 19       	sub	r18, r10
     31e:	3b 09       	sbc	r19, r11
     320:	4c 09       	sbc	r20, r12
     322:	5d 09       	sbc	r21, r13
     324:	06 c0       	rjmp	.+12     	; 0x332 <_fpadd_parts+0x1c0>
     326:	a6 01       	movw	r20, r12
     328:	95 01       	movw	r18, r10
     32a:	2e 19       	sub	r18, r14
     32c:	3f 09       	sbc	r19, r15
     32e:	40 0b       	sbc	r20, r16
     330:	51 0b       	sbc	r21, r17
     332:	57 fd       	sbrc	r21, 7
     334:	08 c0       	rjmp	.+16     	; 0x346 <_fpadd_parts+0x1d4>
     336:	11 82       	std	Z+1, r1	; 0x01
     338:	33 82       	std	Z+3, r3	; 0x03
     33a:	22 82       	std	Z+2, r2	; 0x02
     33c:	24 83       	std	Z+4, r18	; 0x04
     33e:	35 83       	std	Z+5, r19	; 0x05
     340:	46 83       	std	Z+6, r20	; 0x06
     342:	57 83       	std	Z+7, r21	; 0x07
     344:	1d c0       	rjmp	.+58     	; 0x380 <_fpadd_parts+0x20e>
     346:	81 e0       	ldi	r24, 0x01	; 1
     348:	81 83       	std	Z+1, r24	; 0x01
     34a:	33 82       	std	Z+3, r3	; 0x03
     34c:	22 82       	std	Z+2, r2	; 0x02
     34e:	88 27       	eor	r24, r24
     350:	99 27       	eor	r25, r25
     352:	dc 01       	movw	r26, r24
     354:	82 1b       	sub	r24, r18
     356:	93 0b       	sbc	r25, r19
     358:	a4 0b       	sbc	r26, r20
     35a:	b5 0b       	sbc	r27, r21
     35c:	84 83       	std	Z+4, r24	; 0x04
     35e:	95 83       	std	Z+5, r25	; 0x05
     360:	a6 83       	std	Z+6, r26	; 0x06
     362:	b7 83       	std	Z+7, r27	; 0x07
     364:	0d c0       	rjmp	.+26     	; 0x380 <_fpadd_parts+0x20e>
     366:	22 0f       	add	r18, r18
     368:	33 1f       	adc	r19, r19
     36a:	44 1f       	adc	r20, r20
     36c:	55 1f       	adc	r21, r21
     36e:	24 83       	std	Z+4, r18	; 0x04
     370:	35 83       	std	Z+5, r19	; 0x05
     372:	46 83       	std	Z+6, r20	; 0x06
     374:	57 83       	std	Z+7, r21	; 0x07
     376:	82 81       	ldd	r24, Z+2	; 0x02
     378:	93 81       	ldd	r25, Z+3	; 0x03
     37a:	01 97       	sbiw	r24, 0x01	; 1
     37c:	93 83       	std	Z+3, r25	; 0x03
     37e:	82 83       	std	Z+2, r24	; 0x02
     380:	24 81       	ldd	r18, Z+4	; 0x04
     382:	35 81       	ldd	r19, Z+5	; 0x05
     384:	46 81       	ldd	r20, Z+6	; 0x06
     386:	57 81       	ldd	r21, Z+7	; 0x07
     388:	da 01       	movw	r26, r20
     38a:	c9 01       	movw	r24, r18
     38c:	01 97       	sbiw	r24, 0x01	; 1
     38e:	a1 09       	sbc	r26, r1
     390:	b1 09       	sbc	r27, r1
     392:	8f 5f       	subi	r24, 0xFF	; 255
     394:	9f 4f       	sbci	r25, 0xFF	; 255
     396:	af 4f       	sbci	r26, 0xFF	; 255
     398:	bf 43       	sbci	r27, 0x3F	; 63
     39a:	28 f3       	brcs	.-54     	; 0x366 <_fpadd_parts+0x1f4>
     39c:	0b c0       	rjmp	.+22     	; 0x3b4 <_fpadd_parts+0x242>
     39e:	91 83       	std	Z+1, r25	; 0x01
     3a0:	33 82       	std	Z+3, r3	; 0x03
     3a2:	22 82       	std	Z+2, r2	; 0x02
     3a4:	ea 0c       	add	r14, r10
     3a6:	fb 1c       	adc	r15, r11
     3a8:	0c 1d       	adc	r16, r12
     3aa:	1d 1d       	adc	r17, r13
     3ac:	e4 82       	std	Z+4, r14	; 0x04
     3ae:	f5 82       	std	Z+5, r15	; 0x05
     3b0:	06 83       	std	Z+6, r16	; 0x06
     3b2:	17 83       	std	Z+7, r17	; 0x07
     3b4:	83 e0       	ldi	r24, 0x03	; 3
     3b6:	80 83       	st	Z, r24
     3b8:	24 81       	ldd	r18, Z+4	; 0x04
     3ba:	35 81       	ldd	r19, Z+5	; 0x05
     3bc:	46 81       	ldd	r20, Z+6	; 0x06
     3be:	57 81       	ldd	r21, Z+7	; 0x07
     3c0:	57 ff       	sbrs	r21, 7
     3c2:	1a c0       	rjmp	.+52     	; 0x3f8 <_fpadd_parts+0x286>
     3c4:	c9 01       	movw	r24, r18
     3c6:	aa 27       	eor	r26, r26
     3c8:	97 fd       	sbrc	r25, 7
     3ca:	a0 95       	com	r26
     3cc:	ba 2f       	mov	r27, r26
     3ce:	81 70       	andi	r24, 0x01	; 1
     3d0:	90 70       	andi	r25, 0x00	; 0
     3d2:	a0 70       	andi	r26, 0x00	; 0
     3d4:	b0 70       	andi	r27, 0x00	; 0
     3d6:	56 95       	lsr	r21
     3d8:	47 95       	ror	r20
     3da:	37 95       	ror	r19
     3dc:	27 95       	ror	r18
     3de:	82 2b       	or	r24, r18
     3e0:	93 2b       	or	r25, r19
     3e2:	a4 2b       	or	r26, r20
     3e4:	b5 2b       	or	r27, r21
     3e6:	84 83       	std	Z+4, r24	; 0x04
     3e8:	95 83       	std	Z+5, r25	; 0x05
     3ea:	a6 83       	std	Z+6, r26	; 0x06
     3ec:	b7 83       	std	Z+7, r27	; 0x07
     3ee:	82 81       	ldd	r24, Z+2	; 0x02
     3f0:	93 81       	ldd	r25, Z+3	; 0x03
     3f2:	01 96       	adiw	r24, 0x01	; 1
     3f4:	93 83       	std	Z+3, r25	; 0x03
     3f6:	82 83       	std	Z+2, r24	; 0x02
     3f8:	df 01       	movw	r26, r30
     3fa:	01 c0       	rjmp	.+2      	; 0x3fe <_fpadd_parts+0x28c>
     3fc:	d2 01       	movw	r26, r4
     3fe:	cd 01       	movw	r24, r26
     400:	cd b7       	in	r28, 0x3d	; 61
     402:	de b7       	in	r29, 0x3e	; 62
     404:	e2 e1       	ldi	r30, 0x12	; 18
     406:	0c 94 df 2d 	jmp	0x5bbe	; 0x5bbe <__epilogue_restores__>

0000040a <__subsf3>:
     40a:	a0 e2       	ldi	r26, 0x20	; 32
     40c:	b0 e0       	ldi	r27, 0x00	; 0
     40e:	eb e0       	ldi	r30, 0x0B	; 11
     410:	f2 e0       	ldi	r31, 0x02	; 2
     412:	0c 94 cf 2d 	jmp	0x5b9e	; 0x5b9e <__prologue_saves__+0x18>
     416:	69 83       	std	Y+1, r22	; 0x01
     418:	7a 83       	std	Y+2, r23	; 0x02
     41a:	8b 83       	std	Y+3, r24	; 0x03
     41c:	9c 83       	std	Y+4, r25	; 0x04
     41e:	2d 83       	std	Y+5, r18	; 0x05
     420:	3e 83       	std	Y+6, r19	; 0x06
     422:	4f 83       	std	Y+7, r20	; 0x07
     424:	58 87       	std	Y+8, r21	; 0x08
     426:	e9 e0       	ldi	r30, 0x09	; 9
     428:	ee 2e       	mov	r14, r30
     42a:	f1 2c       	mov	r15, r1
     42c:	ec 0e       	add	r14, r28
     42e:	fd 1e       	adc	r15, r29
     430:	ce 01       	movw	r24, r28
     432:	01 96       	adiw	r24, 0x01	; 1
     434:	b7 01       	movw	r22, r14
     436:	0e 94 30 05 	call	0xa60	; 0xa60 <__unpack_f>
     43a:	8e 01       	movw	r16, r28
     43c:	0f 5e       	subi	r16, 0xEF	; 239
     43e:	1f 4f       	sbci	r17, 0xFF	; 255
     440:	ce 01       	movw	r24, r28
     442:	05 96       	adiw	r24, 0x05	; 5
     444:	b8 01       	movw	r22, r16
     446:	0e 94 30 05 	call	0xa60	; 0xa60 <__unpack_f>
     44a:	8a 89       	ldd	r24, Y+18	; 0x12
     44c:	91 e0       	ldi	r25, 0x01	; 1
     44e:	89 27       	eor	r24, r25
     450:	8a 8b       	std	Y+18, r24	; 0x12
     452:	c7 01       	movw	r24, r14
     454:	b8 01       	movw	r22, r16
     456:	ae 01       	movw	r20, r28
     458:	47 5e       	subi	r20, 0xE7	; 231
     45a:	5f 4f       	sbci	r21, 0xFF	; 255
     45c:	0e 94 b9 00 	call	0x172	; 0x172 <_fpadd_parts>
     460:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <__pack_f>
     464:	a0 96       	adiw	r28, 0x20	; 32
     466:	e6 e0       	ldi	r30, 0x06	; 6
     468:	0c 94 eb 2d 	jmp	0x5bd6	; 0x5bd6 <__epilogue_restores__+0x18>

0000046c <__addsf3>:
     46c:	a0 e2       	ldi	r26, 0x20	; 32
     46e:	b0 e0       	ldi	r27, 0x00	; 0
     470:	ec e3       	ldi	r30, 0x3C	; 60
     472:	f2 e0       	ldi	r31, 0x02	; 2
     474:	0c 94 cf 2d 	jmp	0x5b9e	; 0x5b9e <__prologue_saves__+0x18>
     478:	69 83       	std	Y+1, r22	; 0x01
     47a:	7a 83       	std	Y+2, r23	; 0x02
     47c:	8b 83       	std	Y+3, r24	; 0x03
     47e:	9c 83       	std	Y+4, r25	; 0x04
     480:	2d 83       	std	Y+5, r18	; 0x05
     482:	3e 83       	std	Y+6, r19	; 0x06
     484:	4f 83       	std	Y+7, r20	; 0x07
     486:	58 87       	std	Y+8, r21	; 0x08
     488:	f9 e0       	ldi	r31, 0x09	; 9
     48a:	ef 2e       	mov	r14, r31
     48c:	f1 2c       	mov	r15, r1
     48e:	ec 0e       	add	r14, r28
     490:	fd 1e       	adc	r15, r29
     492:	ce 01       	movw	r24, r28
     494:	01 96       	adiw	r24, 0x01	; 1
     496:	b7 01       	movw	r22, r14
     498:	0e 94 30 05 	call	0xa60	; 0xa60 <__unpack_f>
     49c:	8e 01       	movw	r16, r28
     49e:	0f 5e       	subi	r16, 0xEF	; 239
     4a0:	1f 4f       	sbci	r17, 0xFF	; 255
     4a2:	ce 01       	movw	r24, r28
     4a4:	05 96       	adiw	r24, 0x05	; 5
     4a6:	b8 01       	movw	r22, r16
     4a8:	0e 94 30 05 	call	0xa60	; 0xa60 <__unpack_f>
     4ac:	c7 01       	movw	r24, r14
     4ae:	b8 01       	movw	r22, r16
     4b0:	ae 01       	movw	r20, r28
     4b2:	47 5e       	subi	r20, 0xE7	; 231
     4b4:	5f 4f       	sbci	r21, 0xFF	; 255
     4b6:	0e 94 b9 00 	call	0x172	; 0x172 <_fpadd_parts>
     4ba:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <__pack_f>
     4be:	a0 96       	adiw	r28, 0x20	; 32
     4c0:	e6 e0       	ldi	r30, 0x06	; 6
     4c2:	0c 94 eb 2d 	jmp	0x5bd6	; 0x5bd6 <__epilogue_restores__+0x18>

000004c6 <__divsf3>:
     4c6:	a8 e1       	ldi	r26, 0x18	; 24
     4c8:	b0 e0       	ldi	r27, 0x00	; 0
     4ca:	e9 e6       	ldi	r30, 0x69	; 105
     4cc:	f2 e0       	ldi	r31, 0x02	; 2
     4ce:	0c 94 cb 2d 	jmp	0x5b96	; 0x5b96 <__prologue_saves__+0x10>
     4d2:	69 83       	std	Y+1, r22	; 0x01
     4d4:	7a 83       	std	Y+2, r23	; 0x02
     4d6:	8b 83       	std	Y+3, r24	; 0x03
     4d8:	9c 83       	std	Y+4, r25	; 0x04
     4da:	2d 83       	std	Y+5, r18	; 0x05
     4dc:	3e 83       	std	Y+6, r19	; 0x06
     4de:	4f 83       	std	Y+7, r20	; 0x07
     4e0:	58 87       	std	Y+8, r21	; 0x08
     4e2:	b9 e0       	ldi	r27, 0x09	; 9
     4e4:	eb 2e       	mov	r14, r27
     4e6:	f1 2c       	mov	r15, r1
     4e8:	ec 0e       	add	r14, r28
     4ea:	fd 1e       	adc	r15, r29
     4ec:	ce 01       	movw	r24, r28
     4ee:	01 96       	adiw	r24, 0x01	; 1
     4f0:	b7 01       	movw	r22, r14
     4f2:	0e 94 30 05 	call	0xa60	; 0xa60 <__unpack_f>
     4f6:	8e 01       	movw	r16, r28
     4f8:	0f 5e       	subi	r16, 0xEF	; 239
     4fa:	1f 4f       	sbci	r17, 0xFF	; 255
     4fc:	ce 01       	movw	r24, r28
     4fe:	05 96       	adiw	r24, 0x05	; 5
     500:	b8 01       	movw	r22, r16
     502:	0e 94 30 05 	call	0xa60	; 0xa60 <__unpack_f>
     506:	29 85       	ldd	r18, Y+9	; 0x09
     508:	22 30       	cpi	r18, 0x02	; 2
     50a:	08 f4       	brcc	.+2      	; 0x50e <__divsf3+0x48>
     50c:	7e c0       	rjmp	.+252    	; 0x60a <__divsf3+0x144>
     50e:	39 89       	ldd	r19, Y+17	; 0x11
     510:	32 30       	cpi	r19, 0x02	; 2
     512:	10 f4       	brcc	.+4      	; 0x518 <__divsf3+0x52>
     514:	b8 01       	movw	r22, r16
     516:	7c c0       	rjmp	.+248    	; 0x610 <__divsf3+0x14a>
     518:	8a 85       	ldd	r24, Y+10	; 0x0a
     51a:	9a 89       	ldd	r25, Y+18	; 0x12
     51c:	89 27       	eor	r24, r25
     51e:	8a 87       	std	Y+10, r24	; 0x0a
     520:	24 30       	cpi	r18, 0x04	; 4
     522:	11 f0       	breq	.+4      	; 0x528 <__divsf3+0x62>
     524:	22 30       	cpi	r18, 0x02	; 2
     526:	31 f4       	brne	.+12     	; 0x534 <__divsf3+0x6e>
     528:	23 17       	cp	r18, r19
     52a:	09 f0       	breq	.+2      	; 0x52e <__divsf3+0x68>
     52c:	6e c0       	rjmp	.+220    	; 0x60a <__divsf3+0x144>
     52e:	6a e9       	ldi	r22, 0x9A	; 154
     530:	76 e0       	ldi	r23, 0x06	; 6
     532:	6e c0       	rjmp	.+220    	; 0x610 <__divsf3+0x14a>
     534:	34 30       	cpi	r19, 0x04	; 4
     536:	39 f4       	brne	.+14     	; 0x546 <__divsf3+0x80>
     538:	1d 86       	std	Y+13, r1	; 0x0d
     53a:	1e 86       	std	Y+14, r1	; 0x0e
     53c:	1f 86       	std	Y+15, r1	; 0x0f
     53e:	18 8a       	std	Y+16, r1	; 0x10
     540:	1c 86       	std	Y+12, r1	; 0x0c
     542:	1b 86       	std	Y+11, r1	; 0x0b
     544:	04 c0       	rjmp	.+8      	; 0x54e <__divsf3+0x88>
     546:	32 30       	cpi	r19, 0x02	; 2
     548:	21 f4       	brne	.+8      	; 0x552 <__divsf3+0x8c>
     54a:	84 e0       	ldi	r24, 0x04	; 4
     54c:	89 87       	std	Y+9, r24	; 0x09
     54e:	b7 01       	movw	r22, r14
     550:	5f c0       	rjmp	.+190    	; 0x610 <__divsf3+0x14a>
     552:	2b 85       	ldd	r18, Y+11	; 0x0b
     554:	3c 85       	ldd	r19, Y+12	; 0x0c
     556:	8b 89       	ldd	r24, Y+19	; 0x13
     558:	9c 89       	ldd	r25, Y+20	; 0x14
     55a:	28 1b       	sub	r18, r24
     55c:	39 0b       	sbc	r19, r25
     55e:	3c 87       	std	Y+12, r19	; 0x0c
     560:	2b 87       	std	Y+11, r18	; 0x0b
     562:	ed 84       	ldd	r14, Y+13	; 0x0d
     564:	fe 84       	ldd	r15, Y+14	; 0x0e
     566:	0f 85       	ldd	r16, Y+15	; 0x0f
     568:	18 89       	ldd	r17, Y+16	; 0x10
     56a:	ad 88       	ldd	r10, Y+21	; 0x15
     56c:	be 88       	ldd	r11, Y+22	; 0x16
     56e:	cf 88       	ldd	r12, Y+23	; 0x17
     570:	d8 8c       	ldd	r13, Y+24	; 0x18
     572:	ea 14       	cp	r14, r10
     574:	fb 04       	cpc	r15, r11
     576:	0c 05       	cpc	r16, r12
     578:	1d 05       	cpc	r17, r13
     57a:	40 f4       	brcc	.+16     	; 0x58c <__divsf3+0xc6>
     57c:	ee 0c       	add	r14, r14
     57e:	ff 1c       	adc	r15, r15
     580:	00 1f       	adc	r16, r16
     582:	11 1f       	adc	r17, r17
     584:	21 50       	subi	r18, 0x01	; 1
     586:	30 40       	sbci	r19, 0x00	; 0
     588:	3c 87       	std	Y+12, r19	; 0x0c
     58a:	2b 87       	std	Y+11, r18	; 0x0b
     58c:	20 e0       	ldi	r18, 0x00	; 0
     58e:	30 e0       	ldi	r19, 0x00	; 0
     590:	40 e0       	ldi	r20, 0x00	; 0
     592:	50 e0       	ldi	r21, 0x00	; 0
     594:	80 e0       	ldi	r24, 0x00	; 0
     596:	90 e0       	ldi	r25, 0x00	; 0
     598:	a0 e0       	ldi	r26, 0x00	; 0
     59a:	b0 e4       	ldi	r27, 0x40	; 64
     59c:	60 e0       	ldi	r22, 0x00	; 0
     59e:	70 e0       	ldi	r23, 0x00	; 0
     5a0:	ea 14       	cp	r14, r10
     5a2:	fb 04       	cpc	r15, r11
     5a4:	0c 05       	cpc	r16, r12
     5a6:	1d 05       	cpc	r17, r13
     5a8:	40 f0       	brcs	.+16     	; 0x5ba <__divsf3+0xf4>
     5aa:	28 2b       	or	r18, r24
     5ac:	39 2b       	or	r19, r25
     5ae:	4a 2b       	or	r20, r26
     5b0:	5b 2b       	or	r21, r27
     5b2:	ea 18       	sub	r14, r10
     5b4:	fb 08       	sbc	r15, r11
     5b6:	0c 09       	sbc	r16, r12
     5b8:	1d 09       	sbc	r17, r13
     5ba:	b6 95       	lsr	r27
     5bc:	a7 95       	ror	r26
     5be:	97 95       	ror	r25
     5c0:	87 95       	ror	r24
     5c2:	ee 0c       	add	r14, r14
     5c4:	ff 1c       	adc	r15, r15
     5c6:	00 1f       	adc	r16, r16
     5c8:	11 1f       	adc	r17, r17
     5ca:	6f 5f       	subi	r22, 0xFF	; 255
     5cc:	7f 4f       	sbci	r23, 0xFF	; 255
     5ce:	6f 31       	cpi	r22, 0x1F	; 31
     5d0:	71 05       	cpc	r23, r1
     5d2:	31 f7       	brne	.-52     	; 0x5a0 <__divsf3+0xda>
     5d4:	da 01       	movw	r26, r20
     5d6:	c9 01       	movw	r24, r18
     5d8:	8f 77       	andi	r24, 0x7F	; 127
     5da:	90 70       	andi	r25, 0x00	; 0
     5dc:	a0 70       	andi	r26, 0x00	; 0
     5de:	b0 70       	andi	r27, 0x00	; 0
     5e0:	80 34       	cpi	r24, 0x40	; 64
     5e2:	91 05       	cpc	r25, r1
     5e4:	a1 05       	cpc	r26, r1
     5e6:	b1 05       	cpc	r27, r1
     5e8:	61 f4       	brne	.+24     	; 0x602 <__divsf3+0x13c>
     5ea:	27 fd       	sbrc	r18, 7
     5ec:	0a c0       	rjmp	.+20     	; 0x602 <__divsf3+0x13c>
     5ee:	e1 14       	cp	r14, r1
     5f0:	f1 04       	cpc	r15, r1
     5f2:	01 05       	cpc	r16, r1
     5f4:	11 05       	cpc	r17, r1
     5f6:	29 f0       	breq	.+10     	; 0x602 <__divsf3+0x13c>
     5f8:	20 5c       	subi	r18, 0xC0	; 192
     5fa:	3f 4f       	sbci	r19, 0xFF	; 255
     5fc:	4f 4f       	sbci	r20, 0xFF	; 255
     5fe:	5f 4f       	sbci	r21, 0xFF	; 255
     600:	20 78       	andi	r18, 0x80	; 128
     602:	2d 87       	std	Y+13, r18	; 0x0d
     604:	3e 87       	std	Y+14, r19	; 0x0e
     606:	4f 87       	std	Y+15, r20	; 0x0f
     608:	58 8b       	std	Y+16, r21	; 0x10
     60a:	be 01       	movw	r22, r28
     60c:	67 5f       	subi	r22, 0xF7	; 247
     60e:	7f 4f       	sbci	r23, 0xFF	; 255
     610:	cb 01       	movw	r24, r22
     612:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <__pack_f>
     616:	68 96       	adiw	r28, 0x18	; 24
     618:	ea e0       	ldi	r30, 0x0A	; 10
     61a:	0c 94 e7 2d 	jmp	0x5bce	; 0x5bce <__epilogue_restores__+0x10>

0000061e <__gesf2>:
     61e:	a8 e1       	ldi	r26, 0x18	; 24
     620:	b0 e0       	ldi	r27, 0x00	; 0
     622:	e5 e1       	ldi	r30, 0x15	; 21
     624:	f3 e0       	ldi	r31, 0x03	; 3
     626:	0c 94 cf 2d 	jmp	0x5b9e	; 0x5b9e <__prologue_saves__+0x18>
     62a:	69 83       	std	Y+1, r22	; 0x01
     62c:	7a 83       	std	Y+2, r23	; 0x02
     62e:	8b 83       	std	Y+3, r24	; 0x03
     630:	9c 83       	std	Y+4, r25	; 0x04
     632:	2d 83       	std	Y+5, r18	; 0x05
     634:	3e 83       	std	Y+6, r19	; 0x06
     636:	4f 83       	std	Y+7, r20	; 0x07
     638:	58 87       	std	Y+8, r21	; 0x08
     63a:	89 e0       	ldi	r24, 0x09	; 9
     63c:	e8 2e       	mov	r14, r24
     63e:	f1 2c       	mov	r15, r1
     640:	ec 0e       	add	r14, r28
     642:	fd 1e       	adc	r15, r29
     644:	ce 01       	movw	r24, r28
     646:	01 96       	adiw	r24, 0x01	; 1
     648:	b7 01       	movw	r22, r14
     64a:	0e 94 30 05 	call	0xa60	; 0xa60 <__unpack_f>
     64e:	8e 01       	movw	r16, r28
     650:	0f 5e       	subi	r16, 0xEF	; 239
     652:	1f 4f       	sbci	r17, 0xFF	; 255
     654:	ce 01       	movw	r24, r28
     656:	05 96       	adiw	r24, 0x05	; 5
     658:	b8 01       	movw	r22, r16
     65a:	0e 94 30 05 	call	0xa60	; 0xa60 <__unpack_f>
     65e:	89 85       	ldd	r24, Y+9	; 0x09
     660:	82 30       	cpi	r24, 0x02	; 2
     662:	40 f0       	brcs	.+16     	; 0x674 <__gesf2+0x56>
     664:	89 89       	ldd	r24, Y+17	; 0x11
     666:	82 30       	cpi	r24, 0x02	; 2
     668:	28 f0       	brcs	.+10     	; 0x674 <__gesf2+0x56>
     66a:	c7 01       	movw	r24, r14
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 a8 05 	call	0xb50	; 0xb50 <__fpcmp_parts_f>
     672:	01 c0       	rjmp	.+2      	; 0x676 <__gesf2+0x58>
     674:	8f ef       	ldi	r24, 0xFF	; 255
     676:	68 96       	adiw	r28, 0x18	; 24
     678:	e6 e0       	ldi	r30, 0x06	; 6
     67a:	0c 94 eb 2d 	jmp	0x5bd6	; 0x5bd6 <__epilogue_restores__+0x18>

0000067e <__fixsfsi>:
     67e:	ac e0       	ldi	r26, 0x0C	; 12
     680:	b0 e0       	ldi	r27, 0x00	; 0
     682:	e5 e4       	ldi	r30, 0x45	; 69
     684:	f3 e0       	ldi	r31, 0x03	; 3
     686:	0c 94 d3 2d 	jmp	0x5ba6	; 0x5ba6 <__prologue_saves__+0x20>
     68a:	69 83       	std	Y+1, r22	; 0x01
     68c:	7a 83       	std	Y+2, r23	; 0x02
     68e:	8b 83       	std	Y+3, r24	; 0x03
     690:	9c 83       	std	Y+4, r25	; 0x04
     692:	ce 01       	movw	r24, r28
     694:	01 96       	adiw	r24, 0x01	; 1
     696:	be 01       	movw	r22, r28
     698:	6b 5f       	subi	r22, 0xFB	; 251
     69a:	7f 4f       	sbci	r23, 0xFF	; 255
     69c:	0e 94 30 05 	call	0xa60	; 0xa60 <__unpack_f>
     6a0:	8d 81       	ldd	r24, Y+5	; 0x05
     6a2:	82 30       	cpi	r24, 0x02	; 2
     6a4:	61 f1       	breq	.+88     	; 0x6fe <__fixsfsi+0x80>
     6a6:	82 30       	cpi	r24, 0x02	; 2
     6a8:	50 f1       	brcs	.+84     	; 0x6fe <__fixsfsi+0x80>
     6aa:	84 30       	cpi	r24, 0x04	; 4
     6ac:	21 f4       	brne	.+8      	; 0x6b6 <__fixsfsi+0x38>
     6ae:	8e 81       	ldd	r24, Y+6	; 0x06
     6b0:	88 23       	and	r24, r24
     6b2:	51 f1       	breq	.+84     	; 0x708 <__fixsfsi+0x8a>
     6b4:	2e c0       	rjmp	.+92     	; 0x712 <__fixsfsi+0x94>
     6b6:	2f 81       	ldd	r18, Y+7	; 0x07
     6b8:	38 85       	ldd	r19, Y+8	; 0x08
     6ba:	37 fd       	sbrc	r19, 7
     6bc:	20 c0       	rjmp	.+64     	; 0x6fe <__fixsfsi+0x80>
     6be:	6e 81       	ldd	r22, Y+6	; 0x06
     6c0:	2f 31       	cpi	r18, 0x1F	; 31
     6c2:	31 05       	cpc	r19, r1
     6c4:	1c f0       	brlt	.+6      	; 0x6cc <__fixsfsi+0x4e>
     6c6:	66 23       	and	r22, r22
     6c8:	f9 f0       	breq	.+62     	; 0x708 <__fixsfsi+0x8a>
     6ca:	23 c0       	rjmp	.+70     	; 0x712 <__fixsfsi+0x94>
     6cc:	8e e1       	ldi	r24, 0x1E	; 30
     6ce:	90 e0       	ldi	r25, 0x00	; 0
     6d0:	82 1b       	sub	r24, r18
     6d2:	93 0b       	sbc	r25, r19
     6d4:	29 85       	ldd	r18, Y+9	; 0x09
     6d6:	3a 85       	ldd	r19, Y+10	; 0x0a
     6d8:	4b 85       	ldd	r20, Y+11	; 0x0b
     6da:	5c 85       	ldd	r21, Y+12	; 0x0c
     6dc:	04 c0       	rjmp	.+8      	; 0x6e6 <__fixsfsi+0x68>
     6de:	56 95       	lsr	r21
     6e0:	47 95       	ror	r20
     6e2:	37 95       	ror	r19
     6e4:	27 95       	ror	r18
     6e6:	8a 95       	dec	r24
     6e8:	d2 f7       	brpl	.-12     	; 0x6de <__fixsfsi+0x60>
     6ea:	66 23       	and	r22, r22
     6ec:	b1 f0       	breq	.+44     	; 0x71a <__fixsfsi+0x9c>
     6ee:	50 95       	com	r21
     6f0:	40 95       	com	r20
     6f2:	30 95       	com	r19
     6f4:	21 95       	neg	r18
     6f6:	3f 4f       	sbci	r19, 0xFF	; 255
     6f8:	4f 4f       	sbci	r20, 0xFF	; 255
     6fa:	5f 4f       	sbci	r21, 0xFF	; 255
     6fc:	0e c0       	rjmp	.+28     	; 0x71a <__fixsfsi+0x9c>
     6fe:	20 e0       	ldi	r18, 0x00	; 0
     700:	30 e0       	ldi	r19, 0x00	; 0
     702:	40 e0       	ldi	r20, 0x00	; 0
     704:	50 e0       	ldi	r21, 0x00	; 0
     706:	09 c0       	rjmp	.+18     	; 0x71a <__fixsfsi+0x9c>
     708:	2f ef       	ldi	r18, 0xFF	; 255
     70a:	3f ef       	ldi	r19, 0xFF	; 255
     70c:	4f ef       	ldi	r20, 0xFF	; 255
     70e:	5f e7       	ldi	r21, 0x7F	; 127
     710:	04 c0       	rjmp	.+8      	; 0x71a <__fixsfsi+0x9c>
     712:	20 e0       	ldi	r18, 0x00	; 0
     714:	30 e0       	ldi	r19, 0x00	; 0
     716:	40 e0       	ldi	r20, 0x00	; 0
     718:	50 e8       	ldi	r21, 0x80	; 128
     71a:	b9 01       	movw	r22, r18
     71c:	ca 01       	movw	r24, r20
     71e:	2c 96       	adiw	r28, 0x0c	; 12
     720:	e2 e0       	ldi	r30, 0x02	; 2
     722:	0c 94 ef 2d 	jmp	0x5bde	; 0x5bde <__epilogue_restores__+0x20>

00000726 <__floatunsisf>:
     726:	a8 e0       	ldi	r26, 0x08	; 8
     728:	b0 e0       	ldi	r27, 0x00	; 0
     72a:	e9 e9       	ldi	r30, 0x99	; 153
     72c:	f3 e0       	ldi	r31, 0x03	; 3
     72e:	0c 94 cb 2d 	jmp	0x5b96	; 0x5b96 <__prologue_saves__+0x10>
     732:	7b 01       	movw	r14, r22
     734:	8c 01       	movw	r16, r24
     736:	61 15       	cp	r22, r1
     738:	71 05       	cpc	r23, r1
     73a:	81 05       	cpc	r24, r1
     73c:	91 05       	cpc	r25, r1
     73e:	19 f4       	brne	.+6      	; 0x746 <__floatunsisf+0x20>
     740:	82 e0       	ldi	r24, 0x02	; 2
     742:	89 83       	std	Y+1, r24	; 0x01
     744:	60 c0       	rjmp	.+192    	; 0x806 <__floatunsisf+0xe0>
     746:	83 e0       	ldi	r24, 0x03	; 3
     748:	89 83       	std	Y+1, r24	; 0x01
     74a:	8e e1       	ldi	r24, 0x1E	; 30
     74c:	c8 2e       	mov	r12, r24
     74e:	d1 2c       	mov	r13, r1
     750:	dc 82       	std	Y+4, r13	; 0x04
     752:	cb 82       	std	Y+3, r12	; 0x03
     754:	ed 82       	std	Y+5, r14	; 0x05
     756:	fe 82       	std	Y+6, r15	; 0x06
     758:	0f 83       	std	Y+7, r16	; 0x07
     75a:	18 87       	std	Y+8, r17	; 0x08
     75c:	c8 01       	movw	r24, r16
     75e:	b7 01       	movw	r22, r14
     760:	0e 94 0c 04 	call	0x818	; 0x818 <__clzsi2>
     764:	fc 01       	movw	r30, r24
     766:	31 97       	sbiw	r30, 0x01	; 1
     768:	f7 ff       	sbrs	r31, 7
     76a:	3b c0       	rjmp	.+118    	; 0x7e2 <__floatunsisf+0xbc>
     76c:	22 27       	eor	r18, r18
     76e:	33 27       	eor	r19, r19
     770:	2e 1b       	sub	r18, r30
     772:	3f 0b       	sbc	r19, r31
     774:	57 01       	movw	r10, r14
     776:	68 01       	movw	r12, r16
     778:	02 2e       	mov	r0, r18
     77a:	04 c0       	rjmp	.+8      	; 0x784 <__floatunsisf+0x5e>
     77c:	d6 94       	lsr	r13
     77e:	c7 94       	ror	r12
     780:	b7 94       	ror	r11
     782:	a7 94       	ror	r10
     784:	0a 94       	dec	r0
     786:	d2 f7       	brpl	.-12     	; 0x77c <__floatunsisf+0x56>
     788:	40 e0       	ldi	r20, 0x00	; 0
     78a:	50 e0       	ldi	r21, 0x00	; 0
     78c:	60 e0       	ldi	r22, 0x00	; 0
     78e:	70 e0       	ldi	r23, 0x00	; 0
     790:	81 e0       	ldi	r24, 0x01	; 1
     792:	90 e0       	ldi	r25, 0x00	; 0
     794:	a0 e0       	ldi	r26, 0x00	; 0
     796:	b0 e0       	ldi	r27, 0x00	; 0
     798:	04 c0       	rjmp	.+8      	; 0x7a2 <__floatunsisf+0x7c>
     79a:	88 0f       	add	r24, r24
     79c:	99 1f       	adc	r25, r25
     79e:	aa 1f       	adc	r26, r26
     7a0:	bb 1f       	adc	r27, r27
     7a2:	2a 95       	dec	r18
     7a4:	d2 f7       	brpl	.-12     	; 0x79a <__floatunsisf+0x74>
     7a6:	01 97       	sbiw	r24, 0x01	; 1
     7a8:	a1 09       	sbc	r26, r1
     7aa:	b1 09       	sbc	r27, r1
     7ac:	8e 21       	and	r24, r14
     7ae:	9f 21       	and	r25, r15
     7b0:	a0 23       	and	r26, r16
     7b2:	b1 23       	and	r27, r17
     7b4:	00 97       	sbiw	r24, 0x00	; 0
     7b6:	a1 05       	cpc	r26, r1
     7b8:	b1 05       	cpc	r27, r1
     7ba:	21 f0       	breq	.+8      	; 0x7c4 <__floatunsisf+0x9e>
     7bc:	41 e0       	ldi	r20, 0x01	; 1
     7be:	50 e0       	ldi	r21, 0x00	; 0
     7c0:	60 e0       	ldi	r22, 0x00	; 0
     7c2:	70 e0       	ldi	r23, 0x00	; 0
     7c4:	4a 29       	or	r20, r10
     7c6:	5b 29       	or	r21, r11
     7c8:	6c 29       	or	r22, r12
     7ca:	7d 29       	or	r23, r13
     7cc:	4d 83       	std	Y+5, r20	; 0x05
     7ce:	5e 83       	std	Y+6, r21	; 0x06
     7d0:	6f 83       	std	Y+7, r22	; 0x07
     7d2:	78 87       	std	Y+8, r23	; 0x08
     7d4:	8e e1       	ldi	r24, 0x1E	; 30
     7d6:	90 e0       	ldi	r25, 0x00	; 0
     7d8:	8e 1b       	sub	r24, r30
     7da:	9f 0b       	sbc	r25, r31
     7dc:	9c 83       	std	Y+4, r25	; 0x04
     7de:	8b 83       	std	Y+3, r24	; 0x03
     7e0:	12 c0       	rjmp	.+36     	; 0x806 <__floatunsisf+0xe0>
     7e2:	30 97       	sbiw	r30, 0x00	; 0
     7e4:	81 f0       	breq	.+32     	; 0x806 <__floatunsisf+0xe0>
     7e6:	0e 2e       	mov	r0, r30
     7e8:	04 c0       	rjmp	.+8      	; 0x7f2 <__floatunsisf+0xcc>
     7ea:	ee 0c       	add	r14, r14
     7ec:	ff 1c       	adc	r15, r15
     7ee:	00 1f       	adc	r16, r16
     7f0:	11 1f       	adc	r17, r17
     7f2:	0a 94       	dec	r0
     7f4:	d2 f7       	brpl	.-12     	; 0x7ea <__floatunsisf+0xc4>
     7f6:	ed 82       	std	Y+5, r14	; 0x05
     7f8:	fe 82       	std	Y+6, r15	; 0x06
     7fa:	0f 83       	std	Y+7, r16	; 0x07
     7fc:	18 87       	std	Y+8, r17	; 0x08
     7fe:	ce 1a       	sub	r12, r30
     800:	df 0a       	sbc	r13, r31
     802:	dc 82       	std	Y+4, r13	; 0x04
     804:	cb 82       	std	Y+3, r12	; 0x03
     806:	1a 82       	std	Y+2, r1	; 0x02
     808:	ce 01       	movw	r24, r28
     80a:	01 96       	adiw	r24, 0x01	; 1
     80c:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <__pack_f>
     810:	28 96       	adiw	r28, 0x08	; 8
     812:	ea e0       	ldi	r30, 0x0A	; 10
     814:	0c 94 e7 2d 	jmp	0x5bce	; 0x5bce <__epilogue_restores__+0x10>

00000818 <__clzsi2>:
     818:	ef 92       	push	r14
     81a:	ff 92       	push	r15
     81c:	0f 93       	push	r16
     81e:	1f 93       	push	r17
     820:	7b 01       	movw	r14, r22
     822:	8c 01       	movw	r16, r24
     824:	80 e0       	ldi	r24, 0x00	; 0
     826:	e8 16       	cp	r14, r24
     828:	80 e0       	ldi	r24, 0x00	; 0
     82a:	f8 06       	cpc	r15, r24
     82c:	81 e0       	ldi	r24, 0x01	; 1
     82e:	08 07       	cpc	r16, r24
     830:	80 e0       	ldi	r24, 0x00	; 0
     832:	18 07       	cpc	r17, r24
     834:	88 f4       	brcc	.+34     	; 0x858 <__clzsi2+0x40>
     836:	8f ef       	ldi	r24, 0xFF	; 255
     838:	e8 16       	cp	r14, r24
     83a:	f1 04       	cpc	r15, r1
     83c:	01 05       	cpc	r16, r1
     83e:	11 05       	cpc	r17, r1
     840:	31 f0       	breq	.+12     	; 0x84e <__clzsi2+0x36>
     842:	28 f0       	brcs	.+10     	; 0x84e <__clzsi2+0x36>
     844:	88 e0       	ldi	r24, 0x08	; 8
     846:	90 e0       	ldi	r25, 0x00	; 0
     848:	a0 e0       	ldi	r26, 0x00	; 0
     84a:	b0 e0       	ldi	r27, 0x00	; 0
     84c:	17 c0       	rjmp	.+46     	; 0x87c <__stack+0x1d>
     84e:	80 e0       	ldi	r24, 0x00	; 0
     850:	90 e0       	ldi	r25, 0x00	; 0
     852:	a0 e0       	ldi	r26, 0x00	; 0
     854:	b0 e0       	ldi	r27, 0x00	; 0
     856:	12 c0       	rjmp	.+36     	; 0x87c <__stack+0x1d>
     858:	80 e0       	ldi	r24, 0x00	; 0
     85a:	e8 16       	cp	r14, r24
     85c:	80 e0       	ldi	r24, 0x00	; 0
     85e:	f8 06       	cpc	r15, r24
     860:	80 e0       	ldi	r24, 0x00	; 0
     862:	08 07       	cpc	r16, r24
     864:	81 e0       	ldi	r24, 0x01	; 1
     866:	18 07       	cpc	r17, r24
     868:	28 f0       	brcs	.+10     	; 0x874 <__stack+0x15>
     86a:	88 e1       	ldi	r24, 0x18	; 24
     86c:	90 e0       	ldi	r25, 0x00	; 0
     86e:	a0 e0       	ldi	r26, 0x00	; 0
     870:	b0 e0       	ldi	r27, 0x00	; 0
     872:	04 c0       	rjmp	.+8      	; 0x87c <__stack+0x1d>
     874:	80 e1       	ldi	r24, 0x10	; 16
     876:	90 e0       	ldi	r25, 0x00	; 0
     878:	a0 e0       	ldi	r26, 0x00	; 0
     87a:	b0 e0       	ldi	r27, 0x00	; 0
     87c:	20 e2       	ldi	r18, 0x20	; 32
     87e:	30 e0       	ldi	r19, 0x00	; 0
     880:	40 e0       	ldi	r20, 0x00	; 0
     882:	50 e0       	ldi	r21, 0x00	; 0
     884:	28 1b       	sub	r18, r24
     886:	39 0b       	sbc	r19, r25
     888:	4a 0b       	sbc	r20, r26
     88a:	5b 0b       	sbc	r21, r27
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	16 95       	lsr	r17
     890:	07 95       	ror	r16
     892:	f7 94       	ror	r15
     894:	e7 94       	ror	r14
     896:	8a 95       	dec	r24
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	f7 01       	movw	r30, r14
     89c:	ee 55       	subi	r30, 0x5E	; 94
     89e:	f9 4f       	sbci	r31, 0xF9	; 249
     8a0:	80 81       	ld	r24, Z
     8a2:	28 1b       	sub	r18, r24
     8a4:	31 09       	sbc	r19, r1
     8a6:	41 09       	sbc	r20, r1
     8a8:	51 09       	sbc	r21, r1
     8aa:	c9 01       	movw	r24, r18
     8ac:	1f 91       	pop	r17
     8ae:	0f 91       	pop	r16
     8b0:	ff 90       	pop	r15
     8b2:	ef 90       	pop	r14
     8b4:	08 95       	ret

000008b6 <__pack_f>:
     8b6:	df 92       	push	r13
     8b8:	ef 92       	push	r14
     8ba:	ff 92       	push	r15
     8bc:	0f 93       	push	r16
     8be:	1f 93       	push	r17
     8c0:	fc 01       	movw	r30, r24
     8c2:	e4 80       	ldd	r14, Z+4	; 0x04
     8c4:	f5 80       	ldd	r15, Z+5	; 0x05
     8c6:	06 81       	ldd	r16, Z+6	; 0x06
     8c8:	17 81       	ldd	r17, Z+7	; 0x07
     8ca:	d1 80       	ldd	r13, Z+1	; 0x01
     8cc:	80 81       	ld	r24, Z
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	48 f4       	brcc	.+18     	; 0x8e4 <__pack_f+0x2e>
     8d2:	80 e0       	ldi	r24, 0x00	; 0
     8d4:	90 e0       	ldi	r25, 0x00	; 0
     8d6:	a0 e1       	ldi	r26, 0x10	; 16
     8d8:	b0 e0       	ldi	r27, 0x00	; 0
     8da:	e8 2a       	or	r14, r24
     8dc:	f9 2a       	or	r15, r25
     8de:	0a 2b       	or	r16, r26
     8e0:	1b 2b       	or	r17, r27
     8e2:	a5 c0       	rjmp	.+330    	; 0xa2e <__pack_f+0x178>
     8e4:	84 30       	cpi	r24, 0x04	; 4
     8e6:	09 f4       	brne	.+2      	; 0x8ea <__pack_f+0x34>
     8e8:	9f c0       	rjmp	.+318    	; 0xa28 <__pack_f+0x172>
     8ea:	82 30       	cpi	r24, 0x02	; 2
     8ec:	21 f4       	brne	.+8      	; 0x8f6 <__pack_f+0x40>
     8ee:	ee 24       	eor	r14, r14
     8f0:	ff 24       	eor	r15, r15
     8f2:	87 01       	movw	r16, r14
     8f4:	05 c0       	rjmp	.+10     	; 0x900 <__pack_f+0x4a>
     8f6:	e1 14       	cp	r14, r1
     8f8:	f1 04       	cpc	r15, r1
     8fa:	01 05       	cpc	r16, r1
     8fc:	11 05       	cpc	r17, r1
     8fe:	19 f4       	brne	.+6      	; 0x906 <__pack_f+0x50>
     900:	e0 e0       	ldi	r30, 0x00	; 0
     902:	f0 e0       	ldi	r31, 0x00	; 0
     904:	96 c0       	rjmp	.+300    	; 0xa32 <__pack_f+0x17c>
     906:	62 81       	ldd	r22, Z+2	; 0x02
     908:	73 81       	ldd	r23, Z+3	; 0x03
     90a:	9f ef       	ldi	r25, 0xFF	; 255
     90c:	62 38       	cpi	r22, 0x82	; 130
     90e:	79 07       	cpc	r23, r25
     910:	0c f0       	brlt	.+2      	; 0x914 <__pack_f+0x5e>
     912:	5b c0       	rjmp	.+182    	; 0x9ca <__pack_f+0x114>
     914:	22 e8       	ldi	r18, 0x82	; 130
     916:	3f ef       	ldi	r19, 0xFF	; 255
     918:	26 1b       	sub	r18, r22
     91a:	37 0b       	sbc	r19, r23
     91c:	2a 31       	cpi	r18, 0x1A	; 26
     91e:	31 05       	cpc	r19, r1
     920:	2c f0       	brlt	.+10     	; 0x92c <__pack_f+0x76>
     922:	20 e0       	ldi	r18, 0x00	; 0
     924:	30 e0       	ldi	r19, 0x00	; 0
     926:	40 e0       	ldi	r20, 0x00	; 0
     928:	50 e0       	ldi	r21, 0x00	; 0
     92a:	2a c0       	rjmp	.+84     	; 0x980 <__pack_f+0xca>
     92c:	b8 01       	movw	r22, r16
     92e:	a7 01       	movw	r20, r14
     930:	02 2e       	mov	r0, r18
     932:	04 c0       	rjmp	.+8      	; 0x93c <__pack_f+0x86>
     934:	76 95       	lsr	r23
     936:	67 95       	ror	r22
     938:	57 95       	ror	r21
     93a:	47 95       	ror	r20
     93c:	0a 94       	dec	r0
     93e:	d2 f7       	brpl	.-12     	; 0x934 <__pack_f+0x7e>
     940:	81 e0       	ldi	r24, 0x01	; 1
     942:	90 e0       	ldi	r25, 0x00	; 0
     944:	a0 e0       	ldi	r26, 0x00	; 0
     946:	b0 e0       	ldi	r27, 0x00	; 0
     948:	04 c0       	rjmp	.+8      	; 0x952 <__pack_f+0x9c>
     94a:	88 0f       	add	r24, r24
     94c:	99 1f       	adc	r25, r25
     94e:	aa 1f       	adc	r26, r26
     950:	bb 1f       	adc	r27, r27
     952:	2a 95       	dec	r18
     954:	d2 f7       	brpl	.-12     	; 0x94a <__pack_f+0x94>
     956:	01 97       	sbiw	r24, 0x01	; 1
     958:	a1 09       	sbc	r26, r1
     95a:	b1 09       	sbc	r27, r1
     95c:	8e 21       	and	r24, r14
     95e:	9f 21       	and	r25, r15
     960:	a0 23       	and	r26, r16
     962:	b1 23       	and	r27, r17
     964:	00 97       	sbiw	r24, 0x00	; 0
     966:	a1 05       	cpc	r26, r1
     968:	b1 05       	cpc	r27, r1
     96a:	21 f0       	breq	.+8      	; 0x974 <__pack_f+0xbe>
     96c:	81 e0       	ldi	r24, 0x01	; 1
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	a0 e0       	ldi	r26, 0x00	; 0
     972:	b0 e0       	ldi	r27, 0x00	; 0
     974:	9a 01       	movw	r18, r20
     976:	ab 01       	movw	r20, r22
     978:	28 2b       	or	r18, r24
     97a:	39 2b       	or	r19, r25
     97c:	4a 2b       	or	r20, r26
     97e:	5b 2b       	or	r21, r27
     980:	da 01       	movw	r26, r20
     982:	c9 01       	movw	r24, r18
     984:	8f 77       	andi	r24, 0x7F	; 127
     986:	90 70       	andi	r25, 0x00	; 0
     988:	a0 70       	andi	r26, 0x00	; 0
     98a:	b0 70       	andi	r27, 0x00	; 0
     98c:	80 34       	cpi	r24, 0x40	; 64
     98e:	91 05       	cpc	r25, r1
     990:	a1 05       	cpc	r26, r1
     992:	b1 05       	cpc	r27, r1
     994:	39 f4       	brne	.+14     	; 0x9a4 <__pack_f+0xee>
     996:	27 ff       	sbrs	r18, 7
     998:	09 c0       	rjmp	.+18     	; 0x9ac <__pack_f+0xf6>
     99a:	20 5c       	subi	r18, 0xC0	; 192
     99c:	3f 4f       	sbci	r19, 0xFF	; 255
     99e:	4f 4f       	sbci	r20, 0xFF	; 255
     9a0:	5f 4f       	sbci	r21, 0xFF	; 255
     9a2:	04 c0       	rjmp	.+8      	; 0x9ac <__pack_f+0xf6>
     9a4:	21 5c       	subi	r18, 0xC1	; 193
     9a6:	3f 4f       	sbci	r19, 0xFF	; 255
     9a8:	4f 4f       	sbci	r20, 0xFF	; 255
     9aa:	5f 4f       	sbci	r21, 0xFF	; 255
     9ac:	e0 e0       	ldi	r30, 0x00	; 0
     9ae:	f0 e0       	ldi	r31, 0x00	; 0
     9b0:	20 30       	cpi	r18, 0x00	; 0
     9b2:	a0 e0       	ldi	r26, 0x00	; 0
     9b4:	3a 07       	cpc	r19, r26
     9b6:	a0 e0       	ldi	r26, 0x00	; 0
     9b8:	4a 07       	cpc	r20, r26
     9ba:	a0 e4       	ldi	r26, 0x40	; 64
     9bc:	5a 07       	cpc	r21, r26
     9be:	10 f0       	brcs	.+4      	; 0x9c4 <__pack_f+0x10e>
     9c0:	e1 e0       	ldi	r30, 0x01	; 1
     9c2:	f0 e0       	ldi	r31, 0x00	; 0
     9c4:	79 01       	movw	r14, r18
     9c6:	8a 01       	movw	r16, r20
     9c8:	27 c0       	rjmp	.+78     	; 0xa18 <__pack_f+0x162>
     9ca:	60 38       	cpi	r22, 0x80	; 128
     9cc:	71 05       	cpc	r23, r1
     9ce:	64 f5       	brge	.+88     	; 0xa28 <__pack_f+0x172>
     9d0:	fb 01       	movw	r30, r22
     9d2:	e1 58       	subi	r30, 0x81	; 129
     9d4:	ff 4f       	sbci	r31, 0xFF	; 255
     9d6:	d8 01       	movw	r26, r16
     9d8:	c7 01       	movw	r24, r14
     9da:	8f 77       	andi	r24, 0x7F	; 127
     9dc:	90 70       	andi	r25, 0x00	; 0
     9de:	a0 70       	andi	r26, 0x00	; 0
     9e0:	b0 70       	andi	r27, 0x00	; 0
     9e2:	80 34       	cpi	r24, 0x40	; 64
     9e4:	91 05       	cpc	r25, r1
     9e6:	a1 05       	cpc	r26, r1
     9e8:	b1 05       	cpc	r27, r1
     9ea:	39 f4       	brne	.+14     	; 0x9fa <__pack_f+0x144>
     9ec:	e7 fe       	sbrs	r14, 7
     9ee:	0d c0       	rjmp	.+26     	; 0xa0a <__pack_f+0x154>
     9f0:	80 e4       	ldi	r24, 0x40	; 64
     9f2:	90 e0       	ldi	r25, 0x00	; 0
     9f4:	a0 e0       	ldi	r26, 0x00	; 0
     9f6:	b0 e0       	ldi	r27, 0x00	; 0
     9f8:	04 c0       	rjmp	.+8      	; 0xa02 <__pack_f+0x14c>
     9fa:	8f e3       	ldi	r24, 0x3F	; 63
     9fc:	90 e0       	ldi	r25, 0x00	; 0
     9fe:	a0 e0       	ldi	r26, 0x00	; 0
     a00:	b0 e0       	ldi	r27, 0x00	; 0
     a02:	e8 0e       	add	r14, r24
     a04:	f9 1e       	adc	r15, r25
     a06:	0a 1f       	adc	r16, r26
     a08:	1b 1f       	adc	r17, r27
     a0a:	17 ff       	sbrs	r17, 7
     a0c:	05 c0       	rjmp	.+10     	; 0xa18 <__pack_f+0x162>
     a0e:	16 95       	lsr	r17
     a10:	07 95       	ror	r16
     a12:	f7 94       	ror	r15
     a14:	e7 94       	ror	r14
     a16:	31 96       	adiw	r30, 0x01	; 1
     a18:	87 e0       	ldi	r24, 0x07	; 7
     a1a:	16 95       	lsr	r17
     a1c:	07 95       	ror	r16
     a1e:	f7 94       	ror	r15
     a20:	e7 94       	ror	r14
     a22:	8a 95       	dec	r24
     a24:	d1 f7       	brne	.-12     	; 0xa1a <__pack_f+0x164>
     a26:	05 c0       	rjmp	.+10     	; 0xa32 <__pack_f+0x17c>
     a28:	ee 24       	eor	r14, r14
     a2a:	ff 24       	eor	r15, r15
     a2c:	87 01       	movw	r16, r14
     a2e:	ef ef       	ldi	r30, 0xFF	; 255
     a30:	f0 e0       	ldi	r31, 0x00	; 0
     a32:	6e 2f       	mov	r22, r30
     a34:	67 95       	ror	r22
     a36:	66 27       	eor	r22, r22
     a38:	67 95       	ror	r22
     a3a:	90 2f       	mov	r25, r16
     a3c:	9f 77       	andi	r25, 0x7F	; 127
     a3e:	d7 94       	ror	r13
     a40:	dd 24       	eor	r13, r13
     a42:	d7 94       	ror	r13
     a44:	8e 2f       	mov	r24, r30
     a46:	86 95       	lsr	r24
     a48:	49 2f       	mov	r20, r25
     a4a:	46 2b       	or	r20, r22
     a4c:	58 2f       	mov	r21, r24
     a4e:	5d 29       	or	r21, r13
     a50:	b7 01       	movw	r22, r14
     a52:	ca 01       	movw	r24, r20
     a54:	1f 91       	pop	r17
     a56:	0f 91       	pop	r16
     a58:	ff 90       	pop	r15
     a5a:	ef 90       	pop	r14
     a5c:	df 90       	pop	r13
     a5e:	08 95       	ret

00000a60 <__unpack_f>:
     a60:	fc 01       	movw	r30, r24
     a62:	db 01       	movw	r26, r22
     a64:	40 81       	ld	r20, Z
     a66:	51 81       	ldd	r21, Z+1	; 0x01
     a68:	22 81       	ldd	r18, Z+2	; 0x02
     a6a:	62 2f       	mov	r22, r18
     a6c:	6f 77       	andi	r22, 0x7F	; 127
     a6e:	70 e0       	ldi	r23, 0x00	; 0
     a70:	22 1f       	adc	r18, r18
     a72:	22 27       	eor	r18, r18
     a74:	22 1f       	adc	r18, r18
     a76:	93 81       	ldd	r25, Z+3	; 0x03
     a78:	89 2f       	mov	r24, r25
     a7a:	88 0f       	add	r24, r24
     a7c:	82 2b       	or	r24, r18
     a7e:	28 2f       	mov	r18, r24
     a80:	30 e0       	ldi	r19, 0x00	; 0
     a82:	99 1f       	adc	r25, r25
     a84:	99 27       	eor	r25, r25
     a86:	99 1f       	adc	r25, r25
     a88:	11 96       	adiw	r26, 0x01	; 1
     a8a:	9c 93       	st	X, r25
     a8c:	11 97       	sbiw	r26, 0x01	; 1
     a8e:	21 15       	cp	r18, r1
     a90:	31 05       	cpc	r19, r1
     a92:	a9 f5       	brne	.+106    	; 0xafe <__unpack_f+0x9e>
     a94:	41 15       	cp	r20, r1
     a96:	51 05       	cpc	r21, r1
     a98:	61 05       	cpc	r22, r1
     a9a:	71 05       	cpc	r23, r1
     a9c:	11 f4       	brne	.+4      	; 0xaa2 <__unpack_f+0x42>
     a9e:	82 e0       	ldi	r24, 0x02	; 2
     aa0:	37 c0       	rjmp	.+110    	; 0xb10 <__unpack_f+0xb0>
     aa2:	82 e8       	ldi	r24, 0x82	; 130
     aa4:	9f ef       	ldi	r25, 0xFF	; 255
     aa6:	13 96       	adiw	r26, 0x03	; 3
     aa8:	9c 93       	st	X, r25
     aaa:	8e 93       	st	-X, r24
     aac:	12 97       	sbiw	r26, 0x02	; 2
     aae:	9a 01       	movw	r18, r20
     ab0:	ab 01       	movw	r20, r22
     ab2:	67 e0       	ldi	r22, 0x07	; 7
     ab4:	22 0f       	add	r18, r18
     ab6:	33 1f       	adc	r19, r19
     ab8:	44 1f       	adc	r20, r20
     aba:	55 1f       	adc	r21, r21
     abc:	6a 95       	dec	r22
     abe:	d1 f7       	brne	.-12     	; 0xab4 <__unpack_f+0x54>
     ac0:	83 e0       	ldi	r24, 0x03	; 3
     ac2:	8c 93       	st	X, r24
     ac4:	0d c0       	rjmp	.+26     	; 0xae0 <__unpack_f+0x80>
     ac6:	22 0f       	add	r18, r18
     ac8:	33 1f       	adc	r19, r19
     aca:	44 1f       	adc	r20, r20
     acc:	55 1f       	adc	r21, r21
     ace:	12 96       	adiw	r26, 0x02	; 2
     ad0:	8d 91       	ld	r24, X+
     ad2:	9c 91       	ld	r25, X
     ad4:	13 97       	sbiw	r26, 0x03	; 3
     ad6:	01 97       	sbiw	r24, 0x01	; 1
     ad8:	13 96       	adiw	r26, 0x03	; 3
     ada:	9c 93       	st	X, r25
     adc:	8e 93       	st	-X, r24
     ade:	12 97       	sbiw	r26, 0x02	; 2
     ae0:	20 30       	cpi	r18, 0x00	; 0
     ae2:	80 e0       	ldi	r24, 0x00	; 0
     ae4:	38 07       	cpc	r19, r24
     ae6:	80 e0       	ldi	r24, 0x00	; 0
     ae8:	48 07       	cpc	r20, r24
     aea:	80 e4       	ldi	r24, 0x40	; 64
     aec:	58 07       	cpc	r21, r24
     aee:	58 f3       	brcs	.-42     	; 0xac6 <__unpack_f+0x66>
     af0:	14 96       	adiw	r26, 0x04	; 4
     af2:	2d 93       	st	X+, r18
     af4:	3d 93       	st	X+, r19
     af6:	4d 93       	st	X+, r20
     af8:	5c 93       	st	X, r21
     afa:	17 97       	sbiw	r26, 0x07	; 7
     afc:	08 95       	ret
     afe:	2f 3f       	cpi	r18, 0xFF	; 255
     b00:	31 05       	cpc	r19, r1
     b02:	79 f4       	brne	.+30     	; 0xb22 <__unpack_f+0xc2>
     b04:	41 15       	cp	r20, r1
     b06:	51 05       	cpc	r21, r1
     b08:	61 05       	cpc	r22, r1
     b0a:	71 05       	cpc	r23, r1
     b0c:	19 f4       	brne	.+6      	; 0xb14 <__unpack_f+0xb4>
     b0e:	84 e0       	ldi	r24, 0x04	; 4
     b10:	8c 93       	st	X, r24
     b12:	08 95       	ret
     b14:	64 ff       	sbrs	r22, 4
     b16:	03 c0       	rjmp	.+6      	; 0xb1e <__unpack_f+0xbe>
     b18:	81 e0       	ldi	r24, 0x01	; 1
     b1a:	8c 93       	st	X, r24
     b1c:	12 c0       	rjmp	.+36     	; 0xb42 <__unpack_f+0xe2>
     b1e:	1c 92       	st	X, r1
     b20:	10 c0       	rjmp	.+32     	; 0xb42 <__unpack_f+0xe2>
     b22:	2f 57       	subi	r18, 0x7F	; 127
     b24:	30 40       	sbci	r19, 0x00	; 0
     b26:	13 96       	adiw	r26, 0x03	; 3
     b28:	3c 93       	st	X, r19
     b2a:	2e 93       	st	-X, r18
     b2c:	12 97       	sbiw	r26, 0x02	; 2
     b2e:	83 e0       	ldi	r24, 0x03	; 3
     b30:	8c 93       	st	X, r24
     b32:	87 e0       	ldi	r24, 0x07	; 7
     b34:	44 0f       	add	r20, r20
     b36:	55 1f       	adc	r21, r21
     b38:	66 1f       	adc	r22, r22
     b3a:	77 1f       	adc	r23, r23
     b3c:	8a 95       	dec	r24
     b3e:	d1 f7       	brne	.-12     	; 0xb34 <__unpack_f+0xd4>
     b40:	70 64       	ori	r23, 0x40	; 64
     b42:	14 96       	adiw	r26, 0x04	; 4
     b44:	4d 93       	st	X+, r20
     b46:	5d 93       	st	X+, r21
     b48:	6d 93       	st	X+, r22
     b4a:	7c 93       	st	X, r23
     b4c:	17 97       	sbiw	r26, 0x07	; 7
     b4e:	08 95       	ret

00000b50 <__fpcmp_parts_f>:
     b50:	1f 93       	push	r17
     b52:	dc 01       	movw	r26, r24
     b54:	fb 01       	movw	r30, r22
     b56:	9c 91       	ld	r25, X
     b58:	92 30       	cpi	r25, 0x02	; 2
     b5a:	08 f4       	brcc	.+2      	; 0xb5e <__fpcmp_parts_f+0xe>
     b5c:	47 c0       	rjmp	.+142    	; 0xbec <__fpcmp_parts_f+0x9c>
     b5e:	80 81       	ld	r24, Z
     b60:	82 30       	cpi	r24, 0x02	; 2
     b62:	08 f4       	brcc	.+2      	; 0xb66 <__fpcmp_parts_f+0x16>
     b64:	43 c0       	rjmp	.+134    	; 0xbec <__fpcmp_parts_f+0x9c>
     b66:	94 30       	cpi	r25, 0x04	; 4
     b68:	51 f4       	brne	.+20     	; 0xb7e <__fpcmp_parts_f+0x2e>
     b6a:	11 96       	adiw	r26, 0x01	; 1
     b6c:	1c 91       	ld	r17, X
     b6e:	84 30       	cpi	r24, 0x04	; 4
     b70:	99 f5       	brne	.+102    	; 0xbd8 <__fpcmp_parts_f+0x88>
     b72:	81 81       	ldd	r24, Z+1	; 0x01
     b74:	68 2f       	mov	r22, r24
     b76:	70 e0       	ldi	r23, 0x00	; 0
     b78:	61 1b       	sub	r22, r17
     b7a:	71 09       	sbc	r23, r1
     b7c:	3f c0       	rjmp	.+126    	; 0xbfc <__fpcmp_parts_f+0xac>
     b7e:	84 30       	cpi	r24, 0x04	; 4
     b80:	21 f0       	breq	.+8      	; 0xb8a <__fpcmp_parts_f+0x3a>
     b82:	92 30       	cpi	r25, 0x02	; 2
     b84:	31 f4       	brne	.+12     	; 0xb92 <__fpcmp_parts_f+0x42>
     b86:	82 30       	cpi	r24, 0x02	; 2
     b88:	b9 f1       	breq	.+110    	; 0xbf8 <__fpcmp_parts_f+0xa8>
     b8a:	81 81       	ldd	r24, Z+1	; 0x01
     b8c:	88 23       	and	r24, r24
     b8e:	89 f1       	breq	.+98     	; 0xbf2 <__fpcmp_parts_f+0xa2>
     b90:	2d c0       	rjmp	.+90     	; 0xbec <__fpcmp_parts_f+0x9c>
     b92:	11 96       	adiw	r26, 0x01	; 1
     b94:	1c 91       	ld	r17, X
     b96:	11 97       	sbiw	r26, 0x01	; 1
     b98:	82 30       	cpi	r24, 0x02	; 2
     b9a:	f1 f0       	breq	.+60     	; 0xbd8 <__fpcmp_parts_f+0x88>
     b9c:	81 81       	ldd	r24, Z+1	; 0x01
     b9e:	18 17       	cp	r17, r24
     ba0:	d9 f4       	brne	.+54     	; 0xbd8 <__fpcmp_parts_f+0x88>
     ba2:	12 96       	adiw	r26, 0x02	; 2
     ba4:	2d 91       	ld	r18, X+
     ba6:	3c 91       	ld	r19, X
     ba8:	13 97       	sbiw	r26, 0x03	; 3
     baa:	82 81       	ldd	r24, Z+2	; 0x02
     bac:	93 81       	ldd	r25, Z+3	; 0x03
     bae:	82 17       	cp	r24, r18
     bb0:	93 07       	cpc	r25, r19
     bb2:	94 f0       	brlt	.+36     	; 0xbd8 <__fpcmp_parts_f+0x88>
     bb4:	28 17       	cp	r18, r24
     bb6:	39 07       	cpc	r19, r25
     bb8:	bc f0       	brlt	.+46     	; 0xbe8 <__fpcmp_parts_f+0x98>
     bba:	14 96       	adiw	r26, 0x04	; 4
     bbc:	8d 91       	ld	r24, X+
     bbe:	9d 91       	ld	r25, X+
     bc0:	0d 90       	ld	r0, X+
     bc2:	bc 91       	ld	r27, X
     bc4:	a0 2d       	mov	r26, r0
     bc6:	24 81       	ldd	r18, Z+4	; 0x04
     bc8:	35 81       	ldd	r19, Z+5	; 0x05
     bca:	46 81       	ldd	r20, Z+6	; 0x06
     bcc:	57 81       	ldd	r21, Z+7	; 0x07
     bce:	28 17       	cp	r18, r24
     bd0:	39 07       	cpc	r19, r25
     bd2:	4a 07       	cpc	r20, r26
     bd4:	5b 07       	cpc	r21, r27
     bd6:	18 f4       	brcc	.+6      	; 0xbde <__fpcmp_parts_f+0x8e>
     bd8:	11 23       	and	r17, r17
     bda:	41 f0       	breq	.+16     	; 0xbec <__fpcmp_parts_f+0x9c>
     bdc:	0a c0       	rjmp	.+20     	; 0xbf2 <__fpcmp_parts_f+0xa2>
     bde:	82 17       	cp	r24, r18
     be0:	93 07       	cpc	r25, r19
     be2:	a4 07       	cpc	r26, r20
     be4:	b5 07       	cpc	r27, r21
     be6:	40 f4       	brcc	.+16     	; 0xbf8 <__fpcmp_parts_f+0xa8>
     be8:	11 23       	and	r17, r17
     bea:	19 f0       	breq	.+6      	; 0xbf2 <__fpcmp_parts_f+0xa2>
     bec:	61 e0       	ldi	r22, 0x01	; 1
     bee:	70 e0       	ldi	r23, 0x00	; 0
     bf0:	05 c0       	rjmp	.+10     	; 0xbfc <__fpcmp_parts_f+0xac>
     bf2:	6f ef       	ldi	r22, 0xFF	; 255
     bf4:	7f ef       	ldi	r23, 0xFF	; 255
     bf6:	02 c0       	rjmp	.+4      	; 0xbfc <__fpcmp_parts_f+0xac>
     bf8:	60 e0       	ldi	r22, 0x00	; 0
     bfa:	70 e0       	ldi	r23, 0x00	; 0
     bfc:	cb 01       	movw	r24, r22
     bfe:	1f 91       	pop	r17
     c00:	08 95       	ret

00000c02 <UART_voidInit>:
void UART_voidInit(void){

	uint_8 Local_u8Help = 0;

	/* Set baud rate value */
	UBRRL = BAUD_RATE_VALUE;
     c02:	83 e3       	ldi	r24, 0x33	; 51
     c04:	89 b9       	out	0x09, r24	; 9
	UBRRH =  0;
     c06:	a0 e4       	ldi	r26, 0x40	; 64
     c08:	b0 e0       	ldi	r27, 0x00	; 0
     c0a:	1c 92       	st	X, r1

	/* enable RX */
	SET_BIT(UCSRB, RXEN);
     c0c:	ea e2       	ldi	r30, 0x2A	; 42
     c0e:	f0 e0       	ldi	r31, 0x00	; 0
     c10:	80 81       	ld	r24, Z
     c12:	80 61       	ori	r24, 0x10	; 16
     c14:	80 83       	st	Z, r24

	/* enable TX */
	SET_BIT(UCSRB, TXEN);
     c16:	80 81       	ld	r24, Z
     c18:	88 60       	ori	r24, 0x08	; 8
     c1a:	80 83       	st	Z, r24
#elif	DATA_SIZE == EIGHT_BIT

	/* Data size 8-bit */
	SET_BIT(Local_u8Help, UCSZ0);
	SET_BIT(Local_u8Help, UCSZ1);
	CLR_BIT(UCSRB, UCSZ2);
     c1c:	80 81       	ld	r24, Z
     c1e:	8b 7f       	andi	r24, 0xFB	; 251
     c20:	80 83       	st	Z, r24

#else
#error("You Chosed Wrong UART data size option!")
#endif

	UCSRC = Local_u8Help;
     c22:	86 e8       	ldi	r24, 0x86	; 134
     c24:	8c 93       	st	X, r24

}
     c26:	08 95       	ret

00000c28 <UART_voidSendByte>:

/******************************************************************************
 * Description 	: UART Send Char Blocking Function.		                      *
 ******************************************************************************/

void UART_voidSendByte(uint_8 Copy_u8Data){
     c28:	98 2f       	mov	r25, r24

	/* wait till UDR is Empty */
	while(0 == GET_BIT(UCSRA, UDRE));
     c2a:	eb e2       	ldi	r30, 0x2B	; 43
     c2c:	f0 e0       	ldi	r31, 0x00	; 0
     c2e:	80 81       	ld	r24, Z
     c30:	85 ff       	sbrs	r24, 5
     c32:	fd cf       	rjmp	.-6      	; 0xc2e <UART_voidSendByte+0x6>

	/* Load data in data register */
	UDR = Copy_u8Data;
     c34:	9c b9       	out	0x0c, r25	; 12

}
     c36:	08 95       	ret

00000c38 <UART_u8ReceiveByte>:
 * Description 	: UART Receive Byte Blocking Function.		                  *
 ******************************************************************************/

uint_8 UART_u8ReceiveByte(void){

	while (GET_BIT(UCSRA, RXC) == 0);
     c38:	eb e2       	ldi	r30, 0x2B	; 43
     c3a:	f0 e0       	ldi	r31, 0x00	; 0
     c3c:	80 81       	ld	r24, Z
     c3e:	88 23       	and	r24, r24
     c40:	ec f7       	brge	.-6      	; 0xc3c <UART_u8ReceiveByte+0x4>

	return UDR;
     c42:	8c b1       	in	r24, 0x0c	; 12
}
     c44:	08 95       	ret

00000c46 <UART_voidSendStringBlocking>:
/******************************************************************************
 * Description 	: UART Send String Blocking Function.                         *
 ******************************************************************************/

void UART_voidSendStringBlocking(uint_8 *Copy_u8Data)
{
     c46:	1f 93       	push	r17
     c48:	cf 93       	push	r28
     c4a:	df 93       	push	r29
     c4c:	ec 01       	movw	r28, r24
	uint_8 *Local_u8Data = Copy_u8Data;
	uint_8 i=0;
	while(Local_u8Data[i] != '\0')
     c4e:	88 81       	ld	r24, Y
     c50:	88 23       	and	r24, r24
     c52:	51 f0       	breq	.+20     	; 0xc68 <UART_voidSendStringBlocking+0x22>
     c54:	10 e0       	ldi	r17, 0x00	; 0
	{

		UART_voidSendByte(Local_u8Data[i]);
     c56:	0e 94 14 06 	call	0xc28	; 0xc28 <UART_voidSendByte>
		i++;
     c5a:	1f 5f       	subi	r17, 0xFF	; 255

void UART_voidSendStringBlocking(uint_8 *Copy_u8Data)
{
	uint_8 *Local_u8Data = Copy_u8Data;
	uint_8 i=0;
	while(Local_u8Data[i] != '\0')
     c5c:	fe 01       	movw	r30, r28
     c5e:	e1 0f       	add	r30, r17
     c60:	f1 1d       	adc	r31, r1
     c62:	80 81       	ld	r24, Z
     c64:	88 23       	and	r24, r24
     c66:	b9 f7       	brne	.-18     	; 0xc56 <UART_voidSendStringBlocking+0x10>

		UART_voidSendByte(Local_u8Data[i]);
		i++;
	}

}
     c68:	df 91       	pop	r29
     c6a:	cf 91       	pop	r28
     c6c:	1f 91       	pop	r17
     c6e:	08 95       	ret

00000c70 <UART_voidWriteDecimalNumber>:
/******************************************************************************
 * Description 	: UART Write Decimal Number Blocking Function.                *
 ******************************************************************************/


void UART_voidWriteDecimalNumber(uint_32 Copy_u32Number){
     c70:	af 92       	push	r10
     c72:	bf 92       	push	r11
     c74:	cf 92       	push	r12
     c76:	df 92       	push	r13
     c78:	ef 92       	push	r14
     c7a:	ff 92       	push	r15
     c7c:	0f 93       	push	r16
     c7e:	1f 93       	push	r17
     c80:	5b 01       	movw	r10, r22
     c82:	6c 01       	movw	r12, r24

	uint_32 Local_u8Reversed = 1;

	if(0 == Copy_u32Number){
     c84:	61 15       	cp	r22, r1
     c86:	71 05       	cpc	r23, r1
     c88:	81 05       	cpc	r24, r1
     c8a:	91 05       	cpc	r25, r1
     c8c:	59 f4       	brne	.+22     	; 0xca4 <UART_voidWriteDecimalNumber+0x34>

		UART_voidSendByte('0');
     c8e:	80 e3       	ldi	r24, 0x30	; 48
     c90:	0e 94 14 06 	call	0xc28	; 0xc28 <UART_voidSendByte>
     c94:	51 c0       	rjmp	.+162    	; 0xd38 <UART_voidWriteDecimalNumber+0xc8>
	while(0 != Copy_u32Number){

		Local_u8Reversed = ((Local_u8Reversed * 10) + (Copy_u32Number % 10));
		Copy_u32Number /= 10;
	}
	while(1 != Local_u8Reversed){
     c96:	81 e0       	ldi	r24, 0x01	; 1
     c98:	e8 16       	cp	r14, r24
     c9a:	f1 04       	cpc	r15, r1
     c9c:	01 05       	cpc	r16, r1
     c9e:	11 05       	cpc	r17, r1
     ca0:	59 f5       	brne	.+86     	; 0xcf8 <UART_voidWriteDecimalNumber+0x88>
     ca2:	4a c0       	rjmp	.+148    	; 0xd38 <UART_voidWriteDecimalNumber+0xc8>
     ca4:	ee 24       	eor	r14, r14
     ca6:	ff 24       	eor	r15, r15
     ca8:	87 01       	movw	r16, r14
     caa:	e3 94       	inc	r14

		UART_voidSendByte('0');
	}
	while(0 != Copy_u32Number){

		Local_u8Reversed = ((Local_u8Reversed * 10) + (Copy_u32Number % 10));
     cac:	c8 01       	movw	r24, r16
     cae:	b7 01       	movw	r22, r14
     cb0:	2a e0       	ldi	r18, 0x0A	; 10
     cb2:	30 e0       	ldi	r19, 0x00	; 0
     cb4:	40 e0       	ldi	r20, 0x00	; 0
     cb6:	50 e0       	ldi	r21, 0x00	; 0
     cb8:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <__mulsi3>
     cbc:	7b 01       	movw	r14, r22
     cbe:	8c 01       	movw	r16, r24
     cc0:	c6 01       	movw	r24, r12
     cc2:	b5 01       	movw	r22, r10
     cc4:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
     cc8:	e6 0e       	add	r14, r22
     cca:	f7 1e       	adc	r15, r23
     ccc:	08 1f       	adc	r16, r24
     cce:	19 1f       	adc	r17, r25
		Copy_u32Number /= 10;
     cd0:	c6 01       	movw	r24, r12
     cd2:	b5 01       	movw	r22, r10
     cd4:	2a e0       	ldi	r18, 0x0A	; 10
     cd6:	30 e0       	ldi	r19, 0x00	; 0
     cd8:	40 e0       	ldi	r20, 0x00	; 0
     cda:	50 e0       	ldi	r21, 0x00	; 0
     cdc:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
     ce0:	82 2f       	mov	r24, r18
     ce2:	93 2f       	mov	r25, r19
     ce4:	a4 2f       	mov	r26, r20
     ce6:	b5 2f       	mov	r27, r21
     ce8:	5c 01       	movw	r10, r24
     cea:	6d 01       	movw	r12, r26

	if(0 == Copy_u32Number){

		UART_voidSendByte('0');
	}
	while(0 != Copy_u32Number){
     cec:	a1 14       	cp	r10, r1
     cee:	b1 04       	cpc	r11, r1
     cf0:	c1 04       	cpc	r12, r1
     cf2:	d1 04       	cpc	r13, r1
     cf4:	d9 f6       	brne	.-74     	; 0xcac <UART_voidWriteDecimalNumber+0x3c>
     cf6:	cf cf       	rjmp	.-98     	; 0xc96 <UART_voidWriteDecimalNumber+0x26>
		Local_u8Reversed = ((Local_u8Reversed * 10) + (Copy_u32Number % 10));
		Copy_u32Number /= 10;
	}
	while(1 != Local_u8Reversed){

		UART_voidSendByte((Local_u8Reversed % 10 ) + 48);
     cf8:	c8 01       	movw	r24, r16
     cfa:	b7 01       	movw	r22, r14
     cfc:	2a e0       	ldi	r18, 0x0A	; 10
     cfe:	30 e0       	ldi	r19, 0x00	; 0
     d00:	40 e0       	ldi	r20, 0x00	; 0
     d02:	50 e0       	ldi	r21, 0x00	; 0
     d04:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
     d08:	86 2f       	mov	r24, r22
     d0a:	80 5d       	subi	r24, 0xD0	; 208
     d0c:	0e 94 14 06 	call	0xc28	; 0xc28 <UART_voidSendByte>
		Local_u8Reversed /= 10;
     d10:	c8 01       	movw	r24, r16
     d12:	b7 01       	movw	r22, r14
     d14:	2a e0       	ldi	r18, 0x0A	; 10
     d16:	30 e0       	ldi	r19, 0x00	; 0
     d18:	40 e0       	ldi	r20, 0x00	; 0
     d1a:	50 e0       	ldi	r21, 0x00	; 0
     d1c:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
     d20:	82 2f       	mov	r24, r18
     d22:	93 2f       	mov	r25, r19
     d24:	a4 2f       	mov	r26, r20
     d26:	b5 2f       	mov	r27, r21
     d28:	7c 01       	movw	r14, r24
     d2a:	8d 01       	movw	r16, r26
	while(0 != Copy_u32Number){

		Local_u8Reversed = ((Local_u8Reversed * 10) + (Copy_u32Number % 10));
		Copy_u32Number /= 10;
	}
	while(1 != Local_u8Reversed){
     d2c:	81 e0       	ldi	r24, 0x01	; 1
     d2e:	e8 16       	cp	r14, r24
     d30:	f1 04       	cpc	r15, r1
     d32:	01 05       	cpc	r16, r1
     d34:	11 05       	cpc	r17, r1
     d36:	01 f7       	brne	.-64     	; 0xcf8 <UART_voidWriteDecimalNumber+0x88>

		UART_voidSendByte((Local_u8Reversed % 10 ) + 48);
		Local_u8Reversed /= 10;
	}

}
     d38:	1f 91       	pop	r17
     d3a:	0f 91       	pop	r16
     d3c:	ff 90       	pop	r15
     d3e:	ef 90       	pop	r14
     d40:	df 90       	pop	r13
     d42:	cf 90       	pop	r12
     d44:	bf 90       	pop	r11
     d46:	af 90       	pop	r10
     d48:	08 95       	ret

00000d4a <UART_voidWriteHexadecimalNumber>:
/******************************************************************************
 * Description 	: UART Write Hexadecimal Number Blocking Function.            *
 ******************************************************************************/


void UART_voidWriteHexadecimalNumber(uint_32 Copy_u32DecimalNumber){
     d4a:	ef 92       	push	r14
     d4c:	ff 92       	push	r15
     d4e:	1f 93       	push	r17
     d50:	df 93       	push	r29
     d52:	cf 93       	push	r28
     d54:	cd b7       	in	r28, 0x3d	; 61
     d56:	de b7       	in	r29, 0x3e	; 62
     d58:	c4 56       	subi	r28, 0x64	; 100
     d5a:	d0 40       	sbci	r29, 0x00	; 0
     d5c:	0f b6       	in	r0, 0x3f	; 63
     d5e:	f8 94       	cli
     d60:	de bf       	out	0x3e, r29	; 62
     d62:	0f be       	out	0x3f, r0	; 63
     d64:	cd bf       	out	0x3d, r28	; 61

	uint_8 HexadecimalNumber[100];

	quotient = Copy_u32DecimalNumber;

	if(quotient == 0){  UART_voidSendByte('0');  }
     d66:	61 15       	cp	r22, r1
     d68:	71 05       	cpc	r23, r1
     d6a:	81 05       	cpc	r24, r1
     d6c:	91 05       	cpc	r25, r1
     d6e:	21 f4       	brne	.+8      	; 0xd78 <UART_voidWriteHexadecimalNumber+0x2e>
     d70:	80 e3       	ldi	r24, 0x30	; 48
     d72:	0e 94 14 06 	call	0xc28	; 0xc28 <UART_voidSendByte>
     d76:	2c c0       	rjmp	.+88     	; 0xdd0 <UART_voidWriteHexadecimalNumber+0x86>
     d78:	31 e0       	ldi	r19, 0x01	; 1
			temp = quotient % 16;

			if(temp < 10){  temp = temp + 48;  }
			else{  temp = temp + 55;  }

			HexadecimalNumber[i++] = temp;
     d7a:	ae 01       	movw	r20, r28
     d7c:	4f 5f       	subi	r20, 0xFF	; 255
     d7e:	5f 4f       	sbci	r21, 0xFF	; 255

	else{

		while(quotient != 0){

			temp = quotient % 16;
     d80:	26 2f       	mov	r18, r22
     d82:	2f 70       	andi	r18, 0x0F	; 15

			if(temp < 10){  temp = temp + 48;  }
     d84:	2a 30       	cpi	r18, 0x0A	; 10
     d86:	10 f4       	brcc	.+4      	; 0xd8c <UART_voidWriteHexadecimalNumber+0x42>
     d88:	20 5d       	subi	r18, 0xD0	; 208
     d8a:	01 c0       	rjmp	.+2      	; 0xd8e <UART_voidWriteHexadecimalNumber+0x44>
			else{  temp = temp + 55;  }
     d8c:	29 5c       	subi	r18, 0xC9	; 201

			HexadecimalNumber[i++] = temp;
     d8e:	fa 01       	movw	r30, r20
     d90:	e3 0f       	add	r30, r19
     d92:	f1 1d       	adc	r31, r1
     d94:	20 83       	st	Z, r18
     d96:	3f 5f       	subi	r19, 0xFF	; 255

			quotient = quotient / 16;
     d98:	68 94       	set
     d9a:	13 f8       	bld	r1, 3
     d9c:	96 95       	lsr	r25
     d9e:	87 95       	ror	r24
     da0:	77 95       	ror	r23
     da2:	67 95       	ror	r22
     da4:	16 94       	lsr	r1
     da6:	d1 f7       	brne	.-12     	; 0xd9c <UART_voidWriteHexadecimalNumber+0x52>

	if(quotient == 0){  UART_voidSendByte('0');  }

	else{

		while(quotient != 0){
     da8:	61 15       	cp	r22, r1
     daa:	71 05       	cpc	r23, r1
     dac:	81 05       	cpc	r24, r1
     dae:	91 05       	cpc	r25, r1
     db0:	39 f7       	brne	.-50     	; 0xd80 <UART_voidWriteHexadecimalNumber+0x36>

			quotient = quotient / 16;

		}

		for(j=i-1; j>0; j--){
     db2:	13 2f       	mov	r17, r19
     db4:	11 50       	subi	r17, 0x01	; 1
     db6:	61 f0       	breq	.+24     	; 0xdd0 <UART_voidWriteHexadecimalNumber+0x86>

			UART_voidSendByte(HexadecimalNumber[j]);
     db8:	7e 01       	movw	r14, r28
     dba:	08 94       	sec
     dbc:	e1 1c       	adc	r14, r1
     dbe:	f1 1c       	adc	r15, r1
     dc0:	f7 01       	movw	r30, r14
     dc2:	e1 0f       	add	r30, r17
     dc4:	f1 1d       	adc	r31, r1
     dc6:	80 81       	ld	r24, Z
     dc8:	0e 94 14 06 	call	0xc28	; 0xc28 <UART_voidSendByte>

			quotient = quotient / 16;

		}

		for(j=i-1; j>0; j--){
     dcc:	11 50       	subi	r17, 0x01	; 1
     dce:	c1 f7       	brne	.-16     	; 0xdc0 <UART_voidWriteHexadecimalNumber+0x76>

			UART_voidSendByte(HexadecimalNumber[j]);
		}
	}

}
     dd0:	cc 59       	subi	r28, 0x9C	; 156
     dd2:	df 4f       	sbci	r29, 0xFF	; 255
     dd4:	0f b6       	in	r0, 0x3f	; 63
     dd6:	f8 94       	cli
     dd8:	de bf       	out	0x3e, r29	; 62
     dda:	0f be       	out	0x3f, r0	; 63
     ddc:	cd bf       	out	0x3d, r28	; 61
     dde:	cf 91       	pop	r28
     de0:	df 91       	pop	r29
     de2:	1f 91       	pop	r17
     de4:	ff 90       	pop	r15
     de6:	ef 90       	pop	r14
     de8:	08 95       	ret

00000dea <UART_voidSendByteNoBlock>:
 * Description 	: UART Send Byte Function, Used using interrupt.              *
 ******************************************************************************/

void UART_voidSendByteNoBlock(uint_8 Copy_u8Data){

	UDR = Copy_u8Data;
     dea:	8c b9       	out	0x0c, r24	; 12
}
     dec:	08 95       	ret

00000dee <UART_u8ReceiveByteNoBlock>:
 * Description 	: UART Receive Byte Function, Used using interrupt.           *
 ******************************************************************************/

uint_8 UART_u8ReceiveByteNoBlock(void){

	return UDR;
     dee:	8c b1       	in	r24, 0x0c	; 12
}
     df0:	08 95       	ret

00000df2 <UART_voidEnableInterrupt_RX>:
 * Description 	: UART RX Interrupt Enable Function.			              *
 ******************************************************************************/

void UART_voidEnableInterrupt_RX(void){

	SET_BIT(UCSRB, RXCIE);
     df2:	ea e2       	ldi	r30, 0x2A	; 42
     df4:	f0 e0       	ldi	r31, 0x00	; 0
     df6:	80 81       	ld	r24, Z
     df8:	80 68       	ori	r24, 0x80	; 128
     dfa:	80 83       	st	Z, r24
}
     dfc:	08 95       	ret

00000dfe <UART_voidDisableInterrupt_RX>:
 * Description 	: UART RX Interrupt Disable Function.			              *
 ******************************************************************************/

void UART_voidDisableInterrupt_RX(void){

	CLR_BIT(UCSRB, RXCIE);
     dfe:	ea e2       	ldi	r30, 0x2A	; 42
     e00:	f0 e0       	ldi	r31, 0x00	; 0
     e02:	80 81       	ld	r24, Z
     e04:	8f 77       	andi	r24, 0x7F	; 127
     e06:	80 83       	st	Z, r24
}
     e08:	08 95       	ret

00000e0a <UART_voidEnableInterrupt_TX>:
 * Description 	: UART TX Interrupt Enable Function.			              *
 ******************************************************************************/

void UART_voidEnableInterrupt_TX(void){

	SET_BIT(UCSRB, TXCIE);
     e0a:	ea e2       	ldi	r30, 0x2A	; 42
     e0c:	f0 e0       	ldi	r31, 0x00	; 0
     e0e:	80 81       	ld	r24, Z
     e10:	80 64       	ori	r24, 0x40	; 64
     e12:	80 83       	st	Z, r24
}
     e14:	08 95       	ret

00000e16 <UART_voidDisableInterrupt_TX>:
 * Description 	: UART TX Interrupt Disable Function.			              *
 ******************************************************************************/

void UART_voidDisableInterrupt_TX(void){

	CLR_BIT(UCSRB, TXCIE);
     e16:	ea e2       	ldi	r30, 0x2A	; 42
     e18:	f0 e0       	ldi	r31, 0x00	; 0
     e1a:	80 81       	ld	r24, Z
     e1c:	8f 7b       	andi	r24, 0xBF	; 191
     e1e:	80 83       	st	Z, r24
}
     e20:	08 95       	ret

00000e22 <UART_voidSetCallBack_TX>:
 *		          [ Layer Architecture Problem Solved ].                      *
 ******************************************************************************/

void UART_voidSetCallBack_TX(void(*Local_ptr)(void)){

	UART_TX_CallBack = Local_ptr;
     e22:	90 93 cd 07 	sts	0x07CD, r25
     e26:	80 93 cc 07 	sts	0x07CC, r24

}
     e2a:	08 95       	ret

00000e2c <UART_voidSetCallBack_RX>:
 *		          [ Layer Architecture Problem Solved ].                      *
 ******************************************************************************/

void UART_voidSetCallBack_RX(void(*Local_ptr)(void)){

	UART_RX_CallBack = Local_ptr;
     e2c:	90 93 cb 07 	sts	0x07CB, r25
     e30:	80 93 ca 07 	sts	0x07CA, r24

}
     e34:	08 95       	ret

00000e36 <__vector_15>:

/******************************************************************************
 * !comment  :  ISR Function UART TX interrupt.  						      *
 ******************************************************************************/

ISR( USART_TX ){
     e36:	1f 92       	push	r1
     e38:	0f 92       	push	r0
     e3a:	0f b6       	in	r0, 0x3f	; 63
     e3c:	0f 92       	push	r0
     e3e:	11 24       	eor	r1, r1
     e40:	2f 93       	push	r18
     e42:	3f 93       	push	r19
     e44:	4f 93       	push	r20
     e46:	5f 93       	push	r21
     e48:	6f 93       	push	r22
     e4a:	7f 93       	push	r23
     e4c:	8f 93       	push	r24
     e4e:	9f 93       	push	r25
     e50:	af 93       	push	r26
     e52:	bf 93       	push	r27
     e54:	ef 93       	push	r30
     e56:	ff 93       	push	r31

	if(UART_TX_CallBack != NULL){
     e58:	e0 91 cc 07 	lds	r30, 0x07CC
     e5c:	f0 91 cd 07 	lds	r31, 0x07CD
     e60:	30 97       	sbiw	r30, 0x00	; 0
     e62:	09 f0       	breq	.+2      	; 0xe66 <__vector_15+0x30>

		UART_TX_CallBack();
     e64:	09 95       	icall
	}

	else{/* Return error */}
}
     e66:	ff 91       	pop	r31
     e68:	ef 91       	pop	r30
     e6a:	bf 91       	pop	r27
     e6c:	af 91       	pop	r26
     e6e:	9f 91       	pop	r25
     e70:	8f 91       	pop	r24
     e72:	7f 91       	pop	r23
     e74:	6f 91       	pop	r22
     e76:	5f 91       	pop	r21
     e78:	4f 91       	pop	r20
     e7a:	3f 91       	pop	r19
     e7c:	2f 91       	pop	r18
     e7e:	0f 90       	pop	r0
     e80:	0f be       	out	0x3f, r0	; 63
     e82:	0f 90       	pop	r0
     e84:	1f 90       	pop	r1
     e86:	18 95       	reti

00000e88 <__vector_13>:

/******************************************************************************
 * !comment  :  ISR Function UART RX interrupt.  						      *
 ******************************************************************************/

ISR( USART_RX ){
     e88:	1f 92       	push	r1
     e8a:	0f 92       	push	r0
     e8c:	0f b6       	in	r0, 0x3f	; 63
     e8e:	0f 92       	push	r0
     e90:	11 24       	eor	r1, r1
     e92:	2f 93       	push	r18
     e94:	3f 93       	push	r19
     e96:	4f 93       	push	r20
     e98:	5f 93       	push	r21
     e9a:	6f 93       	push	r22
     e9c:	7f 93       	push	r23
     e9e:	8f 93       	push	r24
     ea0:	9f 93       	push	r25
     ea2:	af 93       	push	r26
     ea4:	bf 93       	push	r27
     ea6:	ef 93       	push	r30
     ea8:	ff 93       	push	r31

	if(UART_RX_CallBack != NULL){
     eaa:	e0 91 ca 07 	lds	r30, 0x07CA
     eae:	f0 91 cb 07 	lds	r31, 0x07CB
     eb2:	30 97       	sbiw	r30, 0x00	; 0
     eb4:	09 f0       	breq	.+2      	; 0xeb8 <__vector_13+0x30>

		UART_RX_CallBack();
     eb6:	09 95       	icall
	}

	else{/* Return error */}
}
     eb8:	ff 91       	pop	r31
     eba:	ef 91       	pop	r30
     ebc:	bf 91       	pop	r27
     ebe:	af 91       	pop	r26
     ec0:	9f 91       	pop	r25
     ec2:	8f 91       	pop	r24
     ec4:	7f 91       	pop	r23
     ec6:	6f 91       	pop	r22
     ec8:	5f 91       	pop	r21
     eca:	4f 91       	pop	r20
     ecc:	3f 91       	pop	r19
     ece:	2f 91       	pop	r18
     ed0:	0f 90       	pop	r0
     ed2:	0f be       	out	0x3f, r0	; 63
     ed4:	0f 90       	pop	r0
     ed6:	1f 90       	pop	r1
     ed8:	18 95       	reti

00000eda <TIMER1_voidInit>:

void TIMER1_voidInit(Timer1_Mode_t Mode, Timer1_Scaler_t Prescaler){



	switch(Mode){
     eda:	87 30       	cpi	r24, 0x07	; 7
     edc:	09 f4       	brne	.+2      	; 0xee0 <TIMER1_voidInit+0x6>
     ede:	a1 c0       	rjmp	.+322    	; 0x1022 <TIMER1_voidInit+0x148>
     ee0:	88 30       	cpi	r24, 0x08	; 8
     ee2:	90 f4       	brcc	.+36     	; 0xf08 <TIMER1_voidInit+0x2e>
     ee4:	83 30       	cpi	r24, 0x03	; 3
     ee6:	09 f4       	brne	.+2      	; 0xeea <TIMER1_voidInit+0x10>
     ee8:	58 c0       	rjmp	.+176    	; 0xf9a <TIMER1_voidInit+0xc0>
     eea:	84 30       	cpi	r24, 0x04	; 4
     eec:	30 f4       	brcc	.+12     	; 0xefa <TIMER1_voidInit+0x20>
     eee:	81 30       	cpi	r24, 0x01	; 1
     ef0:	91 f1       	breq	.+100    	; 0xf56 <TIMER1_voidInit+0x7c>
     ef2:	82 30       	cpi	r24, 0x02	; 2
     ef4:	08 f0       	brcs	.+2      	; 0xef8 <TIMER1_voidInit+0x1e>
     ef6:	40 c0       	rjmp	.+128    	; 0xf78 <TIMER1_voidInit+0x9e>
     ef8:	1d c0       	rjmp	.+58     	; 0xf34 <TIMER1_voidInit+0x5a>
     efa:	85 30       	cpi	r24, 0x05	; 5
     efc:	09 f4       	brne	.+2      	; 0xf00 <TIMER1_voidInit+0x26>
     efe:	6f c0       	rjmp	.+222    	; 0xfde <TIMER1_voidInit+0x104>
     f00:	86 30       	cpi	r24, 0x06	; 6
     f02:	08 f0       	brcs	.+2      	; 0xf06 <TIMER1_voidInit+0x2c>
     f04:	7d c0       	rjmp	.+250    	; 0x1000 <TIMER1_voidInit+0x126>
     f06:	5a c0       	rjmp	.+180    	; 0xfbc <TIMER1_voidInit+0xe2>
     f08:	8b 30       	cpi	r24, 0x0B	; 11
     f0a:	09 f4       	brne	.+2      	; 0xf0e <TIMER1_voidInit+0x34>
     f0c:	ce c0       	rjmp	.+412    	; 0x10aa <TIMER1_voidInit+0x1d0>
     f0e:	8c 30       	cpi	r24, 0x0C	; 12
     f10:	38 f4       	brcc	.+14     	; 0xf20 <TIMER1_voidInit+0x46>
     f12:	89 30       	cpi	r24, 0x09	; 9
     f14:	09 f4       	brne	.+2      	; 0xf18 <TIMER1_voidInit+0x3e>
     f16:	a7 c0       	rjmp	.+334    	; 0x1066 <TIMER1_voidInit+0x18c>
     f18:	8a 30       	cpi	r24, 0x0A	; 10
     f1a:	08 f0       	brcs	.+2      	; 0xf1e <TIMER1_voidInit+0x44>
     f1c:	b5 c0       	rjmp	.+362    	; 0x1088 <TIMER1_voidInit+0x1ae>
     f1e:	92 c0       	rjmp	.+292    	; 0x1044 <TIMER1_voidInit+0x16a>
     f20:	8d 30       	cpi	r24, 0x0D	; 13
     f22:	09 f4       	brne	.+2      	; 0xf26 <TIMER1_voidInit+0x4c>
     f24:	e4 c0       	rjmp	.+456    	; 0x10ee <TIMER1_voidInit+0x214>
     f26:	8d 30       	cpi	r24, 0x0D	; 13
     f28:	08 f4       	brcc	.+2      	; 0xf2c <TIMER1_voidInit+0x52>
     f2a:	d0 c0       	rjmp	.+416    	; 0x10cc <TIMER1_voidInit+0x1f2>
     f2c:	8e 30       	cpi	r24, 0x0E	; 14
     f2e:	09 f0       	breq	.+2      	; 0xf32 <TIMER1_voidInit+0x58>
     f30:	ff c0       	rjmp	.+510    	; 0x1130 <TIMER1_voidInit+0x256>
     f32:	ee c0       	rjmp	.+476    	; 0x1110 <TIMER1_voidInit+0x236>

		case TIMER1_NORMAL_MODE:
			/* Timer1 Mode Normal or Overflow */
			CLR_BIT(TCCR1A, WGM10);
     f34:	ef e4       	ldi	r30, 0x4F	; 79
     f36:	f0 e0       	ldi	r31, 0x00	; 0
     f38:	80 81       	ld	r24, Z
     f3a:	8e 7f       	andi	r24, 0xFE	; 254
     f3c:	80 83       	st	Z, r24
			CLR_BIT(TCCR1A, WGM11);
     f3e:	80 81       	ld	r24, Z
     f40:	8d 7f       	andi	r24, 0xFD	; 253
     f42:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM12);
     f44:	ee e4       	ldi	r30, 0x4E	; 78
     f46:	f0 e0       	ldi	r31, 0x00	; 0
     f48:	80 81       	ld	r24, Z
     f4a:	87 7f       	andi	r24, 0xF7	; 247
     f4c:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM13);
     f4e:	80 81       	ld	r24, Z
     f50:	8f 7e       	andi	r24, 0xEF	; 239
     f52:	80 83       	st	Z, r24
     f54:	ed c0       	rjmp	.+474    	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_PHASE_CORRECT_8BIT_MODE:
			/* Timer1 Mode PWM, Phase Correct, 8-bit */
			SET_BIT(TCCR1A, WGM10);
     f56:	ef e4       	ldi	r30, 0x4F	; 79
     f58:	f0 e0       	ldi	r31, 0x00	; 0
     f5a:	80 81       	ld	r24, Z
     f5c:	81 60       	ori	r24, 0x01	; 1
     f5e:	80 83       	st	Z, r24
			CLR_BIT(TCCR1A, WGM11);
     f60:	80 81       	ld	r24, Z
     f62:	8d 7f       	andi	r24, 0xFD	; 253
     f64:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM12);
     f66:	ee e4       	ldi	r30, 0x4E	; 78
     f68:	f0 e0       	ldi	r31, 0x00	; 0
     f6a:	80 81       	ld	r24, Z
     f6c:	87 7f       	andi	r24, 0xF7	; 247
     f6e:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM13);
     f70:	80 81       	ld	r24, Z
     f72:	8f 7e       	andi	r24, 0xEF	; 239
     f74:	80 83       	st	Z, r24
     f76:	dc c0       	rjmp	.+440    	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_PHASE_CORRECT_9BIT_MODE:
			/* Timer1 Mode PWM, Phase Correct, 9-bit */
			CLR_BIT(TCCR1A, WGM10);
     f78:	ef e4       	ldi	r30, 0x4F	; 79
     f7a:	f0 e0       	ldi	r31, 0x00	; 0
     f7c:	80 81       	ld	r24, Z
     f7e:	8e 7f       	andi	r24, 0xFE	; 254
     f80:	80 83       	st	Z, r24
			SET_BIT(TCCR1A, WGM11);
     f82:	80 81       	ld	r24, Z
     f84:	82 60       	ori	r24, 0x02	; 2
     f86:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM12);
     f88:	ee e4       	ldi	r30, 0x4E	; 78
     f8a:	f0 e0       	ldi	r31, 0x00	; 0
     f8c:	80 81       	ld	r24, Z
     f8e:	87 7f       	andi	r24, 0xF7	; 247
     f90:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM13);
     f92:	80 81       	ld	r24, Z
     f94:	8f 7e       	andi	r24, 0xEF	; 239
     f96:	80 83       	st	Z, r24
     f98:	cb c0       	rjmp	.+406    	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_PHASE_CORRECT_10BIT_MODE:
			/* Timer1 Mode PWM, Phase Correct, 10-bit */
			SET_BIT(TCCR1A, WGM10);
     f9a:	ef e4       	ldi	r30, 0x4F	; 79
     f9c:	f0 e0       	ldi	r31, 0x00	; 0
     f9e:	80 81       	ld	r24, Z
     fa0:	81 60       	ori	r24, 0x01	; 1
     fa2:	80 83       	st	Z, r24
			SET_BIT(TCCR1A, WGM11);
     fa4:	80 81       	ld	r24, Z
     fa6:	82 60       	ori	r24, 0x02	; 2
     fa8:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM12);
     faa:	ee e4       	ldi	r30, 0x4E	; 78
     fac:	f0 e0       	ldi	r31, 0x00	; 0
     fae:	80 81       	ld	r24, Z
     fb0:	87 7f       	andi	r24, 0xF7	; 247
     fb2:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM13);
     fb4:	80 81       	ld	r24, Z
     fb6:	8f 7e       	andi	r24, 0xEF	; 239
     fb8:	80 83       	st	Z, r24
     fba:	ba c0       	rjmp	.+372    	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_CTC_OCR1A_MODE:
			/* Timer1 Mode CTC Top OCR1A */
			CLR_BIT(TCCR1A, WGM10);
     fbc:	ef e4       	ldi	r30, 0x4F	; 79
     fbe:	f0 e0       	ldi	r31, 0x00	; 0
     fc0:	80 81       	ld	r24, Z
     fc2:	8e 7f       	andi	r24, 0xFE	; 254
     fc4:	80 83       	st	Z, r24
			CLR_BIT(TCCR1A, WGM11);
     fc6:	80 81       	ld	r24, Z
     fc8:	8d 7f       	andi	r24, 0xFD	; 253
     fca:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM12);
     fcc:	ee e4       	ldi	r30, 0x4E	; 78
     fce:	f0 e0       	ldi	r31, 0x00	; 0
     fd0:	80 81       	ld	r24, Z
     fd2:	88 60       	ori	r24, 0x08	; 8
     fd4:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM13);
     fd6:	80 81       	ld	r24, Z
     fd8:	8f 7e       	andi	r24, 0xEF	; 239
     fda:	80 83       	st	Z, r24
     fdc:	a9 c0       	rjmp	.+338    	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_FAST_PWM_8BIT_MODE:
			/* Timer1 Mode Fast PWM, 8-bit */
			SET_BIT(TCCR1A, WGM10);
     fde:	ef e4       	ldi	r30, 0x4F	; 79
     fe0:	f0 e0       	ldi	r31, 0x00	; 0
     fe2:	80 81       	ld	r24, Z
     fe4:	81 60       	ori	r24, 0x01	; 1
     fe6:	80 83       	st	Z, r24
			CLR_BIT(TCCR1A, WGM11);
     fe8:	80 81       	ld	r24, Z
     fea:	8d 7f       	andi	r24, 0xFD	; 253
     fec:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM12);
     fee:	ee e4       	ldi	r30, 0x4E	; 78
     ff0:	f0 e0       	ldi	r31, 0x00	; 0
     ff2:	80 81       	ld	r24, Z
     ff4:	88 60       	ori	r24, 0x08	; 8
     ff6:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM13);
     ff8:	80 81       	ld	r24, Z
     ffa:	8f 7e       	andi	r24, 0xEF	; 239
     ffc:	80 83       	st	Z, r24
     ffe:	98 c0       	rjmp	.+304    	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_FAST_PWM_9BIT_MODE:
			/* Timer1 Mode Fast PWM, 9-bit */
			CLR_BIT(TCCR1A, WGM10);
    1000:	ef e4       	ldi	r30, 0x4F	; 79
    1002:	f0 e0       	ldi	r31, 0x00	; 0
    1004:	80 81       	ld	r24, Z
    1006:	8e 7f       	andi	r24, 0xFE	; 254
    1008:	80 83       	st	Z, r24
			SET_BIT(TCCR1A, WGM11);
    100a:	80 81       	ld	r24, Z
    100c:	82 60       	ori	r24, 0x02	; 2
    100e:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM12);
    1010:	ee e4       	ldi	r30, 0x4E	; 78
    1012:	f0 e0       	ldi	r31, 0x00	; 0
    1014:	80 81       	ld	r24, Z
    1016:	88 60       	ori	r24, 0x08	; 8
    1018:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM13);
    101a:	80 81       	ld	r24, Z
    101c:	8f 7e       	andi	r24, 0xEF	; 239
    101e:	80 83       	st	Z, r24
    1020:	87 c0       	rjmp	.+270    	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_FAST_PWM_10BIT_MODE:
			/* Timer1 Mode Fast PWM, 10-bit */
			SET_BIT(TCCR1A, WGM10);
    1022:	ef e4       	ldi	r30, 0x4F	; 79
    1024:	f0 e0       	ldi	r31, 0x00	; 0
    1026:	80 81       	ld	r24, Z
    1028:	81 60       	ori	r24, 0x01	; 1
    102a:	80 83       	st	Z, r24
			SET_BIT(TCCR1A, WGM11);
    102c:	80 81       	ld	r24, Z
    102e:	82 60       	ori	r24, 0x02	; 2
    1030:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM12);
    1032:	ee e4       	ldi	r30, 0x4E	; 78
    1034:	f0 e0       	ldi	r31, 0x00	; 0
    1036:	80 81       	ld	r24, Z
    1038:	88 60       	ori	r24, 0x08	; 8
    103a:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM13);
    103c:	80 81       	ld	r24, Z
    103e:	8f 7e       	andi	r24, 0xEF	; 239
    1040:	80 83       	st	Z, r24
    1042:	76 c0       	rjmp	.+236    	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_PWM_PHASE_FREQ_CORRECT_ICR1_MODE:
			/* Timer1 Mode PWM, Phase and Frequency Correct Top ICR1 */
			CLR_BIT(TCCR1A, WGM10);
    1044:	ef e4       	ldi	r30, 0x4F	; 79
    1046:	f0 e0       	ldi	r31, 0x00	; 0
    1048:	80 81       	ld	r24, Z
    104a:	8e 7f       	andi	r24, 0xFE	; 254
    104c:	80 83       	st	Z, r24
			CLR_BIT(TCCR1A, WGM11);
    104e:	80 81       	ld	r24, Z
    1050:	8d 7f       	andi	r24, 0xFD	; 253
    1052:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM12);
    1054:	ee e4       	ldi	r30, 0x4E	; 78
    1056:	f0 e0       	ldi	r31, 0x00	; 0
    1058:	80 81       	ld	r24, Z
    105a:	87 7f       	andi	r24, 0xF7	; 247
    105c:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM13);
    105e:	80 81       	ld	r24, Z
    1060:	80 61       	ori	r24, 0x10	; 16
    1062:	80 83       	st	Z, r24
    1064:	65 c0       	rjmp	.+202    	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_PWM_PHASE_FREQ_CORRECT_OCR1A_MODE:
			/* Timer1 Mode PWM, Phase and Frequency Correct Top OCR1A */
			SET_BIT(TCCR1A, WGM10);
    1066:	ef e4       	ldi	r30, 0x4F	; 79
    1068:	f0 e0       	ldi	r31, 0x00	; 0
    106a:	80 81       	ld	r24, Z
    106c:	81 60       	ori	r24, 0x01	; 1
    106e:	80 83       	st	Z, r24
			CLR_BIT(TCCR1A, WGM11);
    1070:	80 81       	ld	r24, Z
    1072:	8d 7f       	andi	r24, 0xFD	; 253
    1074:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM12);
    1076:	ee e4       	ldi	r30, 0x4E	; 78
    1078:	f0 e0       	ldi	r31, 0x00	; 0
    107a:	80 81       	ld	r24, Z
    107c:	87 7f       	andi	r24, 0xF7	; 247
    107e:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM13);
    1080:	80 81       	ld	r24, Z
    1082:	80 61       	ori	r24, 0x10	; 16
    1084:	80 83       	st	Z, r24
    1086:	54 c0       	rjmp	.+168    	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_PWM_PHASE_CORRECT_ICR1_MODE:
			/* Timer1 Mode PWM, Phase Correct Top ICR1 */
			CLR_BIT(TCCR1A, WGM10);
    1088:	ef e4       	ldi	r30, 0x4F	; 79
    108a:	f0 e0       	ldi	r31, 0x00	; 0
    108c:	80 81       	ld	r24, Z
    108e:	8e 7f       	andi	r24, 0xFE	; 254
    1090:	80 83       	st	Z, r24
			SET_BIT(TCCR1A, WGM11);
    1092:	80 81       	ld	r24, Z
    1094:	82 60       	ori	r24, 0x02	; 2
    1096:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM12);
    1098:	ee e4       	ldi	r30, 0x4E	; 78
    109a:	f0 e0       	ldi	r31, 0x00	; 0
    109c:	80 81       	ld	r24, Z
    109e:	87 7f       	andi	r24, 0xF7	; 247
    10a0:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM13);
    10a2:	80 81       	ld	r24, Z
    10a4:	80 61       	ori	r24, 0x10	; 16
    10a6:	80 83       	st	Z, r24
    10a8:	43 c0       	rjmp	.+134    	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_PWM_PHASE_CORRECT_OCR1A_MODE:
			/* Timer1 Mode PWM, Phase Correct Top OCR1A */
			SET_BIT(TCCR1A, WGM10);
    10aa:	ef e4       	ldi	r30, 0x4F	; 79
    10ac:	f0 e0       	ldi	r31, 0x00	; 0
    10ae:	80 81       	ld	r24, Z
    10b0:	81 60       	ori	r24, 0x01	; 1
    10b2:	80 83       	st	Z, r24
			SET_BIT(TCCR1A, WGM11);
    10b4:	80 81       	ld	r24, Z
    10b6:	82 60       	ori	r24, 0x02	; 2
    10b8:	80 83       	st	Z, r24
			CLR_BIT(TCCR1B, WGM12);
    10ba:	ee e4       	ldi	r30, 0x4E	; 78
    10bc:	f0 e0       	ldi	r31, 0x00	; 0
    10be:	80 81       	ld	r24, Z
    10c0:	87 7f       	andi	r24, 0xF7	; 247
    10c2:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM13);
    10c4:	80 81       	ld	r24, Z
    10c6:	80 61       	ori	r24, 0x10	; 16
    10c8:	80 83       	st	Z, r24
    10ca:	32 c0       	rjmp	.+100    	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_CTC_ICR1_MODE:
			/* Timer1 Mode CTC Top ICR1 */
			CLR_BIT(TCCR1A, WGM10);
    10cc:	ef e4       	ldi	r30, 0x4F	; 79
    10ce:	f0 e0       	ldi	r31, 0x00	; 0
    10d0:	80 81       	ld	r24, Z
    10d2:	8e 7f       	andi	r24, 0xFE	; 254
    10d4:	80 83       	st	Z, r24
			CLR_BIT(TCCR1A, WGM11);
    10d6:	80 81       	ld	r24, Z
    10d8:	8d 7f       	andi	r24, 0xFD	; 253
    10da:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM12);
    10dc:	ee e4       	ldi	r30, 0x4E	; 78
    10de:	f0 e0       	ldi	r31, 0x00	; 0
    10e0:	80 81       	ld	r24, Z
    10e2:	88 60       	ori	r24, 0x08	; 8
    10e4:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM13);
    10e6:	80 81       	ld	r24, Z
    10e8:	80 61       	ori	r24, 0x10	; 16
    10ea:	80 83       	st	Z, r24
    10ec:	21 c0       	rjmp	.+66     	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_FAST_PWM_ICR1_MODE:
			/* Timer1 Mode Fast PWM Top ICR1 */
			CLR_BIT(TCCR1A, WGM10);
    10ee:	ef e4       	ldi	r30, 0x4F	; 79
    10f0:	f0 e0       	ldi	r31, 0x00	; 0
    10f2:	80 81       	ld	r24, Z
    10f4:	8e 7f       	andi	r24, 0xFE	; 254
    10f6:	80 83       	st	Z, r24
			SET_BIT(TCCR1A, WGM11);
    10f8:	80 81       	ld	r24, Z
    10fa:	82 60       	ori	r24, 0x02	; 2
    10fc:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM12);
    10fe:	ee e4       	ldi	r30, 0x4E	; 78
    1100:	f0 e0       	ldi	r31, 0x00	; 0
    1102:	80 81       	ld	r24, Z
    1104:	88 60       	ori	r24, 0x08	; 8
    1106:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM13);
    1108:	80 81       	ld	r24, Z
    110a:	80 61       	ori	r24, 0x10	; 16
    110c:	80 83       	st	Z, r24
    110e:	10 c0       	rjmp	.+32     	; 0x1130 <TIMER1_voidInit+0x256>
		break;

		case TIMER1_FAST_PWM_OCR1A_MODE:
			/* Timer1 Mode Fast PWM Top OCR1A */
			SET_BIT(TCCR1A, WGM10);
    1110:	ef e4       	ldi	r30, 0x4F	; 79
    1112:	f0 e0       	ldi	r31, 0x00	; 0
    1114:	80 81       	ld	r24, Z
    1116:	81 60       	ori	r24, 0x01	; 1
    1118:	80 83       	st	Z, r24
			SET_BIT(TCCR1A, WGM11);
    111a:	80 81       	ld	r24, Z
    111c:	82 60       	ori	r24, 0x02	; 2
    111e:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM12);
    1120:	ee e4       	ldi	r30, 0x4E	; 78
    1122:	f0 e0       	ldi	r31, 0x00	; 0
    1124:	80 81       	ld	r24, Z
    1126:	88 60       	ori	r24, 0x08	; 8
    1128:	80 83       	st	Z, r24
			SET_BIT(TCCR1B, WGM13);
    112a:	80 81       	ld	r24, Z
    112c:	80 61       	ori	r24, 0x10	; 16
    112e:	80 83       	st	Z, r24
		break;
		default:    break;
	}

	/* Prescaler mask */
	TCCR1B &= PRESCALER_MASK;
    1130:	ee e4       	ldi	r30, 0x4E	; 78
    1132:	f0 e0       	ldi	r31, 0x00	; 0
    1134:	80 81       	ld	r24, Z
    1136:	88 7f       	andi	r24, 0xF8	; 248
    1138:	80 83       	st	Z, r24
	/* Set prescaler value */
	TCCR1B |= Prescaler;
    113a:	80 81       	ld	r24, Z
    113c:	86 2b       	or	r24, r22
    113e:	80 83       	st	Z, r24
	/*IF CHOSSE PWM FAST THEN CLR COMPARE MATCH &......*/
		SET_BIT(TCCR1A,COM1A1 );
    1140:	ef e4       	ldi	r30, 0x4F	; 79
    1142:	f0 e0       	ldi	r31, 0x00	; 0
    1144:	80 81       	ld	r24, Z
    1146:	80 68       	ori	r24, 0x80	; 128
    1148:	80 83       	st	Z, r24
		CLR_BIT(TCCR1A,COM1A0 );
    114a:	80 81       	ld	r24, Z
    114c:	8f 7b       	andi	r24, 0xBF	; 191
    114e:	80 83       	st	Z, r24
		CLR_BIT(TCCR1A, COM1B0);
    1150:	80 81       	ld	r24, Z
    1152:	8f 7e       	andi	r24, 0xEF	; 239
    1154:	80 83       	st	Z, r24
		SET_BIT(TCCR1A, COM1B1);
    1156:	80 81       	ld	r24, Z
    1158:	80 62       	ori	r24, 0x20	; 32
    115a:	80 83       	st	Z, r24

	
}
    115c:	08 95       	ret

0000115e <TIMER1_voidOutputCompareInit>:
*                 Select Output Compare Mode & Channel.                       *
******************************************************************************/

void TIMER1_voidOutputCompareInit(Timer1_OutputCompareMode_t OC1_Mode, Timer1_Channel_t OC1_Channel){

	switch(OC1_Mode){
    115e:	81 30       	cpi	r24, 0x01	; 1
    1160:	01 f1       	breq	.+64     	; 0x11a2 <TIMER1_voidOutputCompareInit+0x44>
    1162:	81 30       	cpi	r24, 0x01	; 1
    1164:	30 f0       	brcs	.+12     	; 0x1172 <TIMER1_voidOutputCompareInit+0x14>
    1166:	82 30       	cpi	r24, 0x02	; 2
    1168:	a1 f1       	breq	.+104    	; 0x11d2 <TIMER1_voidOutputCompareInit+0x74>
    116a:	83 30       	cpi	r24, 0x03	; 3
    116c:	09 f0       	breq	.+2      	; 0x1170 <TIMER1_voidOutputCompareInit+0x12>
    116e:	5e c0       	rjmp	.+188    	; 0x122c <TIMER1_voidOutputCompareInit+0xce>
    1170:	47 c0       	rjmp	.+142    	; 0x1200 <TIMER1_voidOutputCompareInit+0xa2>

		case TIMER1_OC1_DISCONNECTED_MODE:

			switch(OC1_Channel){
    1172:	66 23       	and	r22, r22
    1174:	21 f0       	breq	.+8      	; 0x117e <TIMER1_voidOutputCompareInit+0x20>
    1176:	61 30       	cpi	r22, 0x01	; 1
    1178:	09 f0       	breq	.+2      	; 0x117c <TIMER1_voidOutputCompareInit+0x1e>
    117a:	58 c0       	rjmp	.+176    	; 0x122c <TIMER1_voidOutputCompareInit+0xce>
    117c:	09 c0       	rjmp	.+18     	; 0x1190 <TIMER1_voidOutputCompareInit+0x32>

				case TIMER1_OCR1A:
					/* Select channel A normal */
					CLR_BIT(TCCR1A, COM1A0);
    117e:	ef e4       	ldi	r30, 0x4F	; 79
    1180:	f0 e0       	ldi	r31, 0x00	; 0
    1182:	80 81       	ld	r24, Z
    1184:	8f 7b       	andi	r24, 0xBF	; 191
    1186:	80 83       	st	Z, r24
					CLR_BIT(TCCR1A, COM1A1);
    1188:	80 81       	ld	r24, Z
    118a:	8f 77       	andi	r24, 0x7F	; 127
    118c:	80 83       	st	Z, r24
    118e:	08 95       	ret
				break;

				case TIMER1_OCR1B:
					/* Select channel B normal */
					CLR_BIT(TCCR1A, COM1B0);
    1190:	ef e4       	ldi	r30, 0x4F	; 79
    1192:	f0 e0       	ldi	r31, 0x00	; 0
    1194:	80 81       	ld	r24, Z
    1196:	8f 7e       	andi	r24, 0xEF	; 239
    1198:	80 83       	st	Z, r24
					CLR_BIT(TCCR1A, COM1B1);
    119a:	80 81       	ld	r24, Z
    119c:	8f 7d       	andi	r24, 0xDF	; 223
    119e:	80 83       	st	Z, r24
    11a0:	08 95       	ret
			}
		break;

		case TIMER1_OC1_TOGGLE_MODE:

			switch(OC1_Channel){
    11a2:	66 23       	and	r22, r22
    11a4:	21 f0       	breq	.+8      	; 0x11ae <TIMER1_voidOutputCompareInit+0x50>
    11a6:	61 30       	cpi	r22, 0x01	; 1
    11a8:	09 f0       	breq	.+2      	; 0x11ac <TIMER1_voidOutputCompareInit+0x4e>
    11aa:	40 c0       	rjmp	.+128    	; 0x122c <TIMER1_voidOutputCompareInit+0xce>
    11ac:	09 c0       	rjmp	.+18     	; 0x11c0 <TIMER1_voidOutputCompareInit+0x62>

				case TIMER1_OCR1A:
					/* Select Channel A Toggle */
					SET_BIT(TCCR1A, COM1A0);
    11ae:	ef e4       	ldi	r30, 0x4F	; 79
    11b0:	f0 e0       	ldi	r31, 0x00	; 0
    11b2:	80 81       	ld	r24, Z
    11b4:	80 64       	ori	r24, 0x40	; 64
    11b6:	80 83       	st	Z, r24
					CLR_BIT(TCCR1A, COM1A1);
    11b8:	80 81       	ld	r24, Z
    11ba:	8f 77       	andi	r24, 0x7F	; 127
    11bc:	80 83       	st	Z, r24
    11be:	08 95       	ret
				break;

				case TIMER1_OCR1B:
					/* Select Channel B Toggle */
					SET_BIT(TCCR1A, COM1B0);
    11c0:	ef e4       	ldi	r30, 0x4F	; 79
    11c2:	f0 e0       	ldi	r31, 0x00	; 0
    11c4:	80 81       	ld	r24, Z
    11c6:	80 61       	ori	r24, 0x10	; 16
    11c8:	80 83       	st	Z, r24
					CLR_BIT(TCCR1A, COM1B1);
    11ca:	80 81       	ld	r24, Z
    11cc:	8f 7d       	andi	r24, 0xDF	; 223
    11ce:	80 83       	st	Z, r24
    11d0:	08 95       	ret
			}
		break;

		case TIMER1_OC1_NON_INVERTING_MODE:

			switch(OC1_Channel){
    11d2:	66 23       	and	r22, r22
    11d4:	19 f0       	breq	.+6      	; 0x11dc <TIMER1_voidOutputCompareInit+0x7e>
    11d6:	61 30       	cpi	r22, 0x01	; 1
    11d8:	49 f5       	brne	.+82     	; 0x122c <TIMER1_voidOutputCompareInit+0xce>
    11da:	09 c0       	rjmp	.+18     	; 0x11ee <TIMER1_voidOutputCompareInit+0x90>

				case TIMER1_OCR1A:
					/* Select Channel A Non-inverting */
					CLR_BIT(TCCR1A, COM1A0);
    11dc:	ef e4       	ldi	r30, 0x4F	; 79
    11de:	f0 e0       	ldi	r31, 0x00	; 0
    11e0:	80 81       	ld	r24, Z
    11e2:	8f 7b       	andi	r24, 0xBF	; 191
    11e4:	80 83       	st	Z, r24
					SET_BIT(TCCR1A, COM1A1);
    11e6:	80 81       	ld	r24, Z
    11e8:	80 68       	ori	r24, 0x80	; 128
    11ea:	80 83       	st	Z, r24
    11ec:	08 95       	ret
				break;

				case TIMER1_OCR1B:
					/* Select Channel B Non-inverting */
					CLR_BIT(TCCR1A, COM1B0);
    11ee:	ef e4       	ldi	r30, 0x4F	; 79
    11f0:	f0 e0       	ldi	r31, 0x00	; 0
    11f2:	80 81       	ld	r24, Z
    11f4:	8f 7e       	andi	r24, 0xEF	; 239
    11f6:	80 83       	st	Z, r24
					SET_BIT(TCCR1A, COM1B1);
    11f8:	80 81       	ld	r24, Z
    11fa:	80 62       	ori	r24, 0x20	; 32
    11fc:	80 83       	st	Z, r24
    11fe:	08 95       	ret
			}
		break;

		case TIMER1_OC1_INVERTING_MODE:

			switch(OC1_Channel){
    1200:	66 23       	and	r22, r22
    1202:	19 f0       	breq	.+6      	; 0x120a <TIMER1_voidOutputCompareInit+0xac>
    1204:	61 30       	cpi	r22, 0x01	; 1
    1206:	91 f4       	brne	.+36     	; 0x122c <TIMER1_voidOutputCompareInit+0xce>
    1208:	09 c0       	rjmp	.+18     	; 0x121c <TIMER1_voidOutputCompareInit+0xbe>

				case TIMER1_OCR1A:
					/* Select Channel A Inverting */
					SET_BIT(TCCR1A, COM1A0);
    120a:	ef e4       	ldi	r30, 0x4F	; 79
    120c:	f0 e0       	ldi	r31, 0x00	; 0
    120e:	80 81       	ld	r24, Z
    1210:	80 64       	ori	r24, 0x40	; 64
    1212:	80 83       	st	Z, r24
					SET_BIT(TCCR1A, COM1A1);
    1214:	80 81       	ld	r24, Z
    1216:	80 68       	ori	r24, 0x80	; 128
    1218:	80 83       	st	Z, r24
    121a:	08 95       	ret
				break;

				case TIMER1_OCR1B:
					/* Select Channel B Inverting */
					SET_BIT(TCCR1A, COM1B0);
    121c:	ef e4       	ldi	r30, 0x4F	; 79
    121e:	f0 e0       	ldi	r31, 0x00	; 0
    1220:	80 81       	ld	r24, Z
    1222:	80 61       	ori	r24, 0x10	; 16
    1224:	80 83       	st	Z, r24
					SET_BIT(TCCR1A, COM1B1);
    1226:	80 81       	ld	r24, Z
    1228:	80 62       	ori	r24, 0x20	; 32
    122a:	80 83       	st	Z, r24
    122c:	08 95       	ret

0000122e <TIMER1_u16GetICR1>:
* Description 	: TIMER1 Get Input Capture Register1 Value Function.		  *
******************************************************************************/

uint_16 TIMER1_u16GetICR1(void){

	return ICR1;
    122e:	26 b5       	in	r18, 0x26	; 38
    1230:	37 b5       	in	r19, 0x27	; 39
}
    1232:	82 2f       	mov	r24, r18
    1234:	93 2f       	mov	r25, r19
    1236:	08 95       	ret

00001238 <TIMER1_voidSetOCR1A>:
* Description 	: TIMER1 Set Output Compare Register1 A Value.	              *
******************************************************************************/

void TIMER1_voidSetOCR1A(uint_16 Copy_u16Value){

	OCR1A = Copy_u16Value;
    1238:	9b bd       	out	0x2b, r25	; 43
    123a:	8a bd       	out	0x2a, r24	; 42

}
    123c:	08 95       	ret

0000123e <TIMER1_voidSetOCR1B>:
* Description 	: TIMER1 Set Output Compare Register1 B Value.	              *
******************************************************************************/

void TIMER1_voidSetOCR1B(uint_16 Copy_u16Value){

	OCR1B = Copy_u16Value;
    123e:	99 bd       	out	0x29, r25	; 41
    1240:	88 bd       	out	0x28, r24	; 40

}
    1242:	08 95       	ret

00001244 <TIMER1_voidSetICR1>:
* Description 	: TIMER1 Set Input Capture Register1 Value.	                  *
******************************************************************************/

void TIMER1_voidSetICR1(uint_16 Copy_u16Value){

	 ICR1 = Copy_u16Value;
    1244:	97 bd       	out	0x27, r25	; 39
    1246:	86 bd       	out	0x26, r24	; 38
}
    1248:	08 95       	ret

0000124a <TIMER1_voidSetTCNT1>:
* Description 	: TIMER1 Set TCNT1 Value.	                                  *
******************************************************************************/

void TIMER1_voidSetTCNT1(uint_16 Copy_u16Value){

	TCNT1 = Copy_u16Value;
    124a:	9d bd       	out	0x2d, r25	; 45
    124c:	8c bd       	out	0x2c, r24	; 44

}
    124e:	08 95       	ret

00001250 <PWM1_voidInit>:
* Description 	: TIMER1 PWM initialization Function.		                  *
******************************************************************************/

void PWM1_voidInit(void){

	TIMER1_voidInit(TIMER1_FAST_PWM_ICR1_MODE, TIMER1_SCALER_8);
    1250:	8d e0       	ldi	r24, 0x0D	; 13
    1252:	62 e0       	ldi	r22, 0x02	; 2
    1254:	0e 94 6d 07 	call	0xeda	; 0xeda <TIMER1_voidInit>

	//TIMER1_voidOutputCompareInit(TIMER1_OC1_NON_INVERTING_MODE, TIMER1_OCR1A);
	//TIMER1_voidSetICR1(40000U);
}
    1258:	08 95       	ret

0000125a <Timer1_U8_SET_CALL_BACK>:
void Timer1_U8_SET_CALL_BACK(void(*p1(void))){
	if(p1!=NULL){
    125a:	00 97       	sbiw	r24, 0x00	; 0
    125c:	21 f0       	breq	.+8      	; 0x1266 <Timer1_U8_SET_CALL_BACK+0xc>
		ptrs=p1;
    125e:	90 93 db 07 	sts	0x07DB, r25
    1262:	80 93 da 07 	sts	0x07DA, r24
    1266:	08 95       	ret

00001268 <__vector_9>:
	else{

	}
}
void __vector_9(void) __attribute__ ((signal));
void __vector_9(void){
    1268:	1f 92       	push	r1
    126a:	0f 92       	push	r0
    126c:	0f b6       	in	r0, 0x3f	; 63
    126e:	0f 92       	push	r0
    1270:	11 24       	eor	r1, r1
    1272:	2f 93       	push	r18
    1274:	3f 93       	push	r19
    1276:	4f 93       	push	r20
    1278:	5f 93       	push	r21
    127a:	6f 93       	push	r22
    127c:	7f 93       	push	r23
    127e:	8f 93       	push	r24
    1280:	9f 93       	push	r25
    1282:	af 93       	push	r26
    1284:	bf 93       	push	r27
    1286:	ef 93       	push	r30
    1288:	ff 93       	push	r31
	ptrs();
    128a:	e0 91 da 07 	lds	r30, 0x07DA
    128e:	f0 91 db 07 	lds	r31, 0x07DB
    1292:	09 95       	icall
}
    1294:	ff 91       	pop	r31
    1296:	ef 91       	pop	r30
    1298:	bf 91       	pop	r27
    129a:	af 91       	pop	r26
    129c:	9f 91       	pop	r25
    129e:	8f 91       	pop	r24
    12a0:	7f 91       	pop	r23
    12a2:	6f 91       	pop	r22
    12a4:	5f 91       	pop	r21
    12a6:	4f 91       	pop	r20
    12a8:	3f 91       	pop	r19
    12aa:	2f 91       	pop	r18
    12ac:	0f 90       	pop	r0
    12ae:	0f be       	out	0x3f, r0	; 63
    12b0:	0f 90       	pop	r0
    12b2:	1f 90       	pop	r1
    12b4:	18 95       	reti

000012b6 <Timer1_U8_SET_CALL_BACK2>:
void Timer1_U8_SET_CALL_BACK2(void(*p1(void))){
	if(p1!=NULL){
    12b6:	00 97       	sbiw	r24, 0x00	; 0
    12b8:	21 f0       	breq	.+8      	; 0x12c2 <Timer1_U8_SET_CALL_BACK2+0xc>
		ptrs1=p1;
    12ba:	90 93 d9 07 	sts	0x07D9, r25
    12be:	80 93 d8 07 	sts	0x07D8, r24
    12c2:	08 95       	ret

000012c4 <__vector_7>:
	else{

	}
}
void __vector_7(void) __attribute__ ((signal));
void __vector_7(void){
    12c4:	1f 92       	push	r1
    12c6:	0f 92       	push	r0
    12c8:	0f b6       	in	r0, 0x3f	; 63
    12ca:	0f 92       	push	r0
    12cc:	11 24       	eor	r1, r1
    12ce:	2f 93       	push	r18
    12d0:	3f 93       	push	r19
    12d2:	4f 93       	push	r20
    12d4:	5f 93       	push	r21
    12d6:	6f 93       	push	r22
    12d8:	7f 93       	push	r23
    12da:	8f 93       	push	r24
    12dc:	9f 93       	push	r25
    12de:	af 93       	push	r26
    12e0:	bf 93       	push	r27
    12e2:	ef 93       	push	r30
    12e4:	ff 93       	push	r31
	ptrs1();
    12e6:	e0 91 d8 07 	lds	r30, 0x07D8
    12ea:	f0 91 d9 07 	lds	r31, 0x07D9
    12ee:	09 95       	icall
}
    12f0:	ff 91       	pop	r31
    12f2:	ef 91       	pop	r30
    12f4:	bf 91       	pop	r27
    12f6:	af 91       	pop	r26
    12f8:	9f 91       	pop	r25
    12fa:	8f 91       	pop	r24
    12fc:	7f 91       	pop	r23
    12fe:	6f 91       	pop	r22
    1300:	5f 91       	pop	r21
    1302:	4f 91       	pop	r20
    1304:	3f 91       	pop	r19
    1306:	2f 91       	pop	r18
    1308:	0f 90       	pop	r0
    130a:	0f be       	out	0x3f, r0	; 63
    130c:	0f 90       	pop	r0
    130e:	1f 90       	pop	r1
    1310:	18 95       	reti

00001312 <PWM1_voidFreqKHZ>:

void PWM1_voidFreqKHZ(uint_16 Copy_u16Freq){
    1312:	bc 01       	movw	r22, r24

	if(0 == Copy_u16Freq){
    1314:	00 97       	sbiw	r24, 0x00	; 0
    1316:	71 f0       	breq	.+28     	; 0x1334 <PWM1_voidFreqKHZ+0x22>

		/* return error */
	}
	else{

		uint_16 Local_u16TimeTotal = 1000 / Copy_u16Freq;
    1318:	88 ee       	ldi	r24, 0xE8	; 232
    131a:	93 e0       	ldi	r25, 0x03	; 3
    131c:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <__udivmodhi4>
    1320:	86 2f       	mov	r24, r22
    1322:	97 2f       	mov	r25, r23

		if(Local_u16TimeTotal >= 1){
    1324:	00 97       	sbiw	r24, 0x00	; 0
    1326:	21 f0       	breq	.+8      	; 0x1330 <PWM1_voidFreqKHZ+0x1e>

			ICR1 = Local_u16TimeTotal - 1;
    1328:	01 97       	sbiw	r24, 0x01	; 1
    132a:	97 bd       	out	0x27, r25	; 39
    132c:	86 bd       	out	0x26, r24	; 38
    132e:	08 95       	ret
		}
		else{ ICR1 = 0; }
    1330:	17 bc       	out	0x27, r1	; 39
    1332:	16 bc       	out	0x26, r1	; 38
    1334:	08 95       	ret

00001336 <PWM1_voidFreqHZ>:
* Description 	: TIMER1 Generate PWM @ Frequency (HZ) Function.		      *
******************************************************************************/

void PWM1_voidFreqHZ(uint_16 Copy_u16Freq){

	if(0 == Copy_u16Freq){
    1336:	00 97       	sbiw	r24, 0x00	; 0
    1338:	91 f0       	breq	.+36     	; 0x135e <PWM1_voidFreqHZ+0x28>

		/* return error */
	}
	else{

		uint_16 Local_u16TimeTotal = (uint_32)1000000 / Copy_u16Freq;
    133a:	9c 01       	movw	r18, r24
    133c:	40 e0       	ldi	r20, 0x00	; 0
    133e:	50 e0       	ldi	r21, 0x00	; 0
    1340:	60 e4       	ldi	r22, 0x40	; 64
    1342:	72 e4       	ldi	r23, 0x42	; 66
    1344:	8f e0       	ldi	r24, 0x0F	; 15
    1346:	90 e0       	ldi	r25, 0x00	; 0
    1348:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
    134c:	c9 01       	movw	r24, r18

		if(Local_u16TimeTotal >= 1){
    134e:	23 2b       	or	r18, r19
    1350:	21 f0       	breq	.+8      	; 0x135a <PWM1_voidFreqHZ+0x24>

			ICR1 = Local_u16TimeTotal - 1;
    1352:	01 97       	sbiw	r24, 0x01	; 1
    1354:	97 bd       	out	0x27, r25	; 39
    1356:	86 bd       	out	0x26, r24	; 38
    1358:	08 95       	ret
		}
		else{ ICR1 = 0; }
    135a:	17 bc       	out	0x27, r1	; 39
    135c:	16 bc       	out	0x26, r1	; 38
    135e:	08 95       	ret

00001360 <PWM1_voidDutyCycle>:
* Description 	: TIMER1 PWM Duty Cycle Function.		                      *
******************************************************************************/

void PWM1_voidDutyCycle(uint_16 Copy_u16Duty){

	if(Copy_u16Duty <= 100){
    1360:	85 36       	cpi	r24, 0x65	; 101
    1362:	91 05       	cpc	r25, r1
    1364:	d8 f4       	brcc	.+54     	; 0x139c <PWM1_voidDutyCycle+0x3c>

		uint_16 Local_u16TimeON = ((uint_32)Copy_u16Duty * (ICR1 + 1)) / 100;
    1366:	26 b5       	in	r18, 0x26	; 38
    1368:	37 b5       	in	r19, 0x27	; 39
    136a:	bc 01       	movw	r22, r24
    136c:	80 e0       	ldi	r24, 0x00	; 0
    136e:	90 e0       	ldi	r25, 0x00	; 0
    1370:	2f 5f       	subi	r18, 0xFF	; 255
    1372:	3f 4f       	sbci	r19, 0xFF	; 255
    1374:	40 e0       	ldi	r20, 0x00	; 0
    1376:	50 e0       	ldi	r21, 0x00	; 0
    1378:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <__mulsi3>
    137c:	24 e6       	ldi	r18, 0x64	; 100
    137e:	30 e0       	ldi	r19, 0x00	; 0
    1380:	40 e0       	ldi	r20, 0x00	; 0
    1382:	50 e0       	ldi	r21, 0x00	; 0
    1384:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>

		if(Local_u16TimeON > 1){
    1388:	22 30       	cpi	r18, 0x02	; 2
    138a:	31 05       	cpc	r19, r1
    138c:	28 f0       	brcs	.+10     	; 0x1398 <PWM1_voidDutyCycle+0x38>

			OCR1A = Local_u16TimeON - 1;
    138e:	c9 01       	movw	r24, r18
    1390:	01 97       	sbiw	r24, 0x01	; 1
    1392:	9b bd       	out	0x2b, r25	; 43
    1394:	8a bd       	out	0x2a, r24	; 42
    1396:	08 95       	ret
		}
		else{ OCR1A = 0; }
    1398:	1b bc       	out	0x2b, r1	; 43
    139a:	1a bc       	out	0x2a, r1	; 42
    139c:	08 95       	ret

0000139e <TIMER1_voidInputCaptureEdge>:
* Description 	: TIMER1 Input Capture Edge Function.		                  *
******************************************************************************/

void TIMER1_voidInputCaptureEdge(ICU_Edge_t Edge){

	switch(Edge){
    139e:	88 23       	and	r24, r24
    13a0:	19 f0       	breq	.+6      	; 0x13a8 <TIMER1_voidInputCaptureEdge+0xa>
    13a2:	81 30       	cpi	r24, 0x01	; 1
    13a4:	61 f4       	brne	.+24     	; 0x13be <TIMER1_voidInputCaptureEdge+0x20>
    13a6:	06 c0       	rjmp	.+12     	; 0x13b4 <TIMER1_voidInputCaptureEdge+0x16>

		case ICU_RISING_EDGE:
			/* Input capture rising edge */
			SET_BIT(TCCR1B, ICES1);
    13a8:	ee e4       	ldi	r30, 0x4E	; 78
    13aa:	f0 e0       	ldi	r31, 0x00	; 0
    13ac:	80 81       	ld	r24, Z
    13ae:	80 64       	ori	r24, 0x40	; 64
    13b0:	80 83       	st	Z, r24
    13b2:	08 95       	ret
		break;

		case ICU_FALLING_EDGE:
			/* Input capture falling edge */
			CLR_BIT(TCCR1B, ICES1);
    13b4:	ee e4       	ldi	r30, 0x4E	; 78
    13b6:	f0 e0       	ldi	r31, 0x00	; 0
    13b8:	80 81       	ld	r24, Z
    13ba:	8f 7b       	andi	r24, 0xBF	; 191
    13bc:	80 83       	st	Z, r24
    13be:	08 95       	ret

000013c0 <TIMER1_voidICU_InterruptEnable>:
******************************************************************************/

void TIMER1_voidICU_InterruptEnable(void){

	/* Enable Input Capture Unit mode interrupt */
	SET_BIT(TIMSK, TICIE1);
    13c0:	e9 e5       	ldi	r30, 0x59	; 89
    13c2:	f0 e0       	ldi	r31, 0x00	; 0
    13c4:	80 81       	ld	r24, Z
    13c6:	80 62       	ori	r24, 0x20	; 32
    13c8:	80 83       	st	Z, r24
}
    13ca:	08 95       	ret

000013cc <TIMER1_voidICU_InterruptDisable>:
******************************************************************************/

void TIMER1_voidICU_InterruptDisable(void){

	/* Disable Input Capture Unit mode interrupt */
	CLR_BIT(TIMSK, TICIE1);
    13cc:	e9 e5       	ldi	r30, 0x59	; 89
    13ce:	f0 e0       	ldi	r31, 0x00	; 0
    13d0:	80 81       	ld	r24, Z
    13d2:	8f 7d       	andi	r24, 0xDF	; 223
    13d4:	80 83       	st	Z, r24
}
    13d6:	08 95       	ret

000013d8 <Timer1ICU_InterruptAction>:
* Description 	: TIMER1 ICU Interrupt Action Private Function.				  *
******************************************************************************/

static void Timer1ICU_InterruptAction(void){

	if(Global_u16Flag == 0){
    13d8:	80 91 d6 07 	lds	r24, 0x07D6
    13dc:	90 91 d7 07 	lds	r25, 0x07D7
    13e0:	89 2b       	or	r24, r25
    13e2:	81 f4       	brne	.+32     	; 0x1404 <Timer1ICU_InterruptAction+0x2c>

		Global_u16Time1 = ICR1;
    13e4:	86 b5       	in	r24, 0x26	; 38
    13e6:	97 b5       	in	r25, 0x27	; 39
    13e8:	90 93 dd 07 	sts	0x07DD, r25
    13ec:	80 93 dc 07 	sts	0x07DC, r24
		TIMER1_voidInputCaptureEdge(ICU_FALLING_EDGE);
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	0e 94 cf 09 	call	0x139e	; 0x139e <TIMER1_voidInputCaptureEdge>
		Global_u16Flag = 1;
    13f6:	81 e0       	ldi	r24, 0x01	; 1
    13f8:	90 e0       	ldi	r25, 0x00	; 0
    13fa:	90 93 d7 07 	sts	0x07D7, r25
    13fe:	80 93 d6 07 	sts	0x07D6, r24
    1402:	08 95       	ret

	}
	else if(Global_u16Flag == 1){
    1404:	80 91 d6 07 	lds	r24, 0x07D6
    1408:	90 91 d7 07 	lds	r25, 0x07D7
    140c:	01 97       	sbiw	r24, 0x01	; 1
    140e:	81 f4       	brne	.+32     	; 0x1430 <Timer1ICU_InterruptAction+0x58>

		Global_u16Time2 = ICR1;
    1410:	86 b5       	in	r24, 0x26	; 38
    1412:	97 b5       	in	r25, 0x27	; 39
    1414:	90 93 df 07 	sts	0x07DF, r25
    1418:	80 93 de 07 	sts	0x07DE, r24
		TIMER1_voidInputCaptureEdge(ICU_RISING_EDGE);
    141c:	80 e0       	ldi	r24, 0x00	; 0
    141e:	0e 94 cf 09 	call	0x139e	; 0x139e <TIMER1_voidInputCaptureEdge>
		Global_u16Flag = 2;
    1422:	82 e0       	ldi	r24, 0x02	; 2
    1424:	90 e0       	ldi	r25, 0x00	; 0
    1426:	90 93 d7 07 	sts	0x07D7, r25
    142a:	80 93 d6 07 	sts	0x07D6, r24
    142e:	08 95       	ret

	}
	else if(Global_u16Flag == 2){
    1430:	80 91 d6 07 	lds	r24, 0x07D6
    1434:	90 91 d7 07 	lds	r25, 0x07D7
    1438:	02 97       	sbiw	r24, 0x02	; 2
    143a:	71 f4       	brne	.+28     	; 0x1458 <Timer1ICU_InterruptAction+0x80>

		Global_u16Time3 = ICR1;
    143c:	86 b5       	in	r24, 0x26	; 38
    143e:	97 b5       	in	r25, 0x27	; 39
    1440:	90 93 e1 07 	sts	0x07E1, r25
    1444:	80 93 e0 07 	sts	0x07E0, r24
		TIMER1_voidICU_InterruptDisable();
    1448:	0e 94 e6 09 	call	0x13cc	; 0x13cc <TIMER1_voidICU_InterruptDisable>
		Global_u16Flag = 3;
    144c:	83 e0       	ldi	r24, 0x03	; 3
    144e:	90 e0       	ldi	r25, 0x00	; 0
    1450:	90 93 d7 07 	sts	0x07D7, r25
    1454:	80 93 d6 07 	sts	0x07D6, r24
    1458:	08 95       	ret

0000145a <TIMER1_voidOVF_InterruptEnable>:
******************************************************************************/

void TIMER1_voidOVF_InterruptEnable(void){

	/* Enable overflow mode interrupt */
	SET_BIT(TIMSK, TOIE1);
    145a:	e9 e5       	ldi	r30, 0x59	; 89
    145c:	f0 e0       	ldi	r31, 0x00	; 0
    145e:	80 81       	ld	r24, Z
    1460:	84 60       	ori	r24, 0x04	; 4
    1462:	80 83       	st	Z, r24
}
    1464:	08 95       	ret

00001466 <TIMER1_voidOVF_InterruptDisable>:
******************************************************************************/

void TIMER1_voidOVF_InterruptDisable(void){

	/* Disable overflow mode interrupt */
	CLR_BIT(TIMSK, TOIE1);
    1466:	e9 e5       	ldi	r30, 0x59	; 89
    1468:	f0 e0       	ldi	r31, 0x00	; 0
    146a:	80 81       	ld	r24, Z
    146c:	8b 7f       	andi	r24, 0xFB	; 251
    146e:	80 83       	st	Z, r24
}
    1470:	08 95       	ret

00001472 <TIMER1_voidOCA_InterruptEnable>:
******************************************************************************/

void TIMER1_voidOCA_InterruptEnable(void){

	/* Enable Output Compare A mode interrupt */
	SET_BIT(TIMSK, OCIE1A);
    1472:	e9 e5       	ldi	r30, 0x59	; 89
    1474:	f0 e0       	ldi	r31, 0x00	; 0
    1476:	80 81       	ld	r24, Z
    1478:	80 61       	ori	r24, 0x10	; 16
    147a:	80 83       	st	Z, r24
}
    147c:	08 95       	ret

0000147e <TIMER1_voidOCA_InterruptDisable>:
******************************************************************************/

void TIMER1_voidOCA_InterruptDisable(void){

	/* Disable overflow mode interrupt */
	CLR_BIT(TIMSK, OCIE1A);
    147e:	e9 e5       	ldi	r30, 0x59	; 89
    1480:	f0 e0       	ldi	r31, 0x00	; 0
    1482:	80 81       	ld	r24, Z
    1484:	8f 7e       	andi	r24, 0xEF	; 239
    1486:	80 83       	st	Z, r24
}
    1488:	08 95       	ret

0000148a <TIMER1_voidOCB_InterruptEnable>:
******************************************************************************/

void TIMER1_voidOCB_InterruptEnable(void){

	/* Enable Output Compare B mode interrupt */
	SET_BIT(TIMSK, OCIE1B);
    148a:	e9 e5       	ldi	r30, 0x59	; 89
    148c:	f0 e0       	ldi	r31, 0x00	; 0
    148e:	80 81       	ld	r24, Z
    1490:	88 60       	ori	r24, 0x08	; 8
    1492:	80 83       	st	Z, r24
}
    1494:	08 95       	ret

00001496 <TIMER1_voidOCB_InterruptDisable>:
******************************************************************************/

void TIMER1_voidOCB_InterruptDisable(void){

	/* Disable Output Compare B mode interrupt */
	CLR_BIT(TIMSK, OCIE1B);
    1496:	e9 e5       	ldi	r30, 0x59	; 89
    1498:	f0 e0       	ldi	r31, 0x00	; 0
    149a:	80 81       	ld	r24, Z
    149c:	87 7f       	andi	r24, 0xF7	; 247
    149e:	80 83       	st	Z, r24
}
    14a0:	08 95       	ret

000014a2 <TIMER1_voidOCB_SetCallBack>:
******************************************************************************/

void TIMER1_voidOCB_SetCallBack(void(*Local_Fptr)(void)){

	/* Output Compare B CallBack function TIMER1 */
	TIMER1_OCB_CallBack = Local_Fptr;
    14a2:	90 93 d5 07 	sts	0x07D5, r25
    14a6:	80 93 d4 07 	sts	0x07D4, r24

}
    14aa:	08 95       	ret

000014ac <TIMER1_voidOCA_SetCallBack>:
******************************************************************************/

void TIMER1_voidOCA_SetCallBack(void(*Local_Fptr)(void)){

	/* Output Compare A CallBack function TIMER1 */
	TIMER1_OCA_CallBack = Local_Fptr;
    14ac:	90 93 d3 07 	sts	0x07D3, r25
    14b0:	80 93 d2 07 	sts	0x07D2, r24

}
    14b4:	08 95       	ret

000014b6 <TIMER1_voidSetTime_us>:

/******************************************************************************
* Description 	: TIMER1 Set Interrupt Time (us) Function.		              *
******************************************************************************/

void TIMER1_voidSetTime_us(uint_16 Copy_u16Time, void(*Local_Fptr)(void)){
    14b6:	ef 92       	push	r14
    14b8:	ff 92       	push	r15
    14ba:	0f 93       	push	r16
    14bc:	1f 93       	push	r17
    14be:	8c 01       	movw	r16, r24
    14c0:	7b 01       	movw	r14, r22

	TIMER1_voidInit(TIMER1_CTC_OCR1A_MODE, TIMER1_SCALER_8);
    14c2:	84 e0       	ldi	r24, 0x04	; 4
    14c4:	62 e0       	ldi	r22, 0x02	; 2
    14c6:	0e 94 6d 07 	call	0xeda	; 0xeda <TIMER1_voidInit>
	TIMER1_voidOutputCompareInit(TIMER1_OC1_DISCONNECTED_MODE, TIMER1_OCR1A);
    14ca:	80 e0       	ldi	r24, 0x00	; 0
    14cc:	60 e0       	ldi	r22, 0x00	; 0
    14ce:	0e 94 af 08 	call	0x115e	; 0x115e <TIMER1_voidOutputCompareInit>
	TIMER1_voidOutputCompareInit(TIMER1_OC1_DISCONNECTED_MODE, TIMER1_OCR1B);
    14d2:	80 e0       	ldi	r24, 0x00	; 0
    14d4:	61 e0       	ldi	r22, 0x01	; 1
    14d6:	0e 94 af 08 	call	0x115e	; 0x115e <TIMER1_voidOutputCompareInit>

	OCR1A = (Copy_u16Time - 1);
    14da:	01 50       	subi	r16, 0x01	; 1
    14dc:	10 40       	sbci	r17, 0x00	; 0
    14de:	1b bd       	out	0x2b, r17	; 43
    14e0:	0a bd       	out	0x2a, r16	; 42

	TIMER1_voidOCA_SetCallBack(Local_Fptr);
    14e2:	c7 01       	movw	r24, r14
    14e4:	0e 94 56 0a 	call	0x14ac	; 0x14ac <TIMER1_voidOCA_SetCallBack>

	TIMER1_voidOCA_InterruptEnable();
    14e8:	0e 94 39 0a 	call	0x1472	; 0x1472 <TIMER1_voidOCA_InterruptEnable>

}
    14ec:	1f 91       	pop	r17
    14ee:	0f 91       	pop	r16
    14f0:	ff 90       	pop	r15
    14f2:	ef 90       	pop	r14
    14f4:	08 95       	ret

000014f6 <TIMER1_voidSetTime_ms>:

/******************************************************************************
* Description 	: TIMER1 Set Interrupt Time (ms) Function.		              *
******************************************************************************/

void TIMER1_voidSetTime_ms(uint_16 Copy_u16Time, void(*Local_Fptr)(void)){
    14f6:	ef 92       	push	r14
    14f8:	ff 92       	push	r15
    14fa:	0f 93       	push	r16
    14fc:	1f 93       	push	r17
    14fe:	8c 01       	movw	r16, r24
    1500:	7b 01       	movw	r14, r22

	TIMER1_voidInit(TIMER1_CTC_OCR1A_MODE, TIMER1_SCALER_8);
    1502:	84 e0       	ldi	r24, 0x04	; 4
    1504:	62 e0       	ldi	r22, 0x02	; 2
    1506:	0e 94 6d 07 	call	0xeda	; 0xeda <TIMER1_voidInit>
	TIMER1_voidOutputCompareInit(TIMER1_OC1_DISCONNECTED_MODE, TIMER1_OCR1A);
    150a:	80 e0       	ldi	r24, 0x00	; 0
    150c:	60 e0       	ldi	r22, 0x00	; 0
    150e:	0e 94 af 08 	call	0x115e	; 0x115e <TIMER1_voidOutputCompareInit>
	TIMER1_voidOutputCompareInit(TIMER1_OC1_DISCONNECTED_MODE, TIMER1_OCR1B);
    1512:	80 e0       	ldi	r24, 0x00	; 0
    1514:	61 e0       	ldi	r22, 0x01	; 1
    1516:	0e 94 af 08 	call	0x115e	; 0x115e <TIMER1_voidOutputCompareInit>

	OCR1A = ((Copy_u16Time * 1000) - 1);
    151a:	88 ee       	ldi	r24, 0xE8	; 232
    151c:	93 e0       	ldi	r25, 0x03	; 3
    151e:	9c 01       	movw	r18, r24
    1520:	02 9f       	mul	r16, r18
    1522:	c0 01       	movw	r24, r0
    1524:	03 9f       	mul	r16, r19
    1526:	90 0d       	add	r25, r0
    1528:	12 9f       	mul	r17, r18
    152a:	90 0d       	add	r25, r0
    152c:	11 24       	eor	r1, r1
    152e:	01 97       	sbiw	r24, 0x01	; 1
    1530:	9b bd       	out	0x2b, r25	; 43
    1532:	8a bd       	out	0x2a, r24	; 42

	TIMER1_voidOCA_SetCallBack(Local_Fptr);
    1534:	c7 01       	movw	r24, r14
    1536:	0e 94 56 0a 	call	0x14ac	; 0x14ac <TIMER1_voidOCA_SetCallBack>

	TIMER1_voidOCA_InterruptEnable();
    153a:	0e 94 39 0a 	call	0x1472	; 0x1472 <TIMER1_voidOCA_InterruptEnable>

}
    153e:	1f 91       	pop	r17
    1540:	0f 91       	pop	r16
    1542:	ff 90       	pop	r15
    1544:	ef 90       	pop	r14
    1546:	08 95       	ret

00001548 <TIMER1_voidICU_SetCallBack>:
******************************************************************************/

void TIMER1_voidICU_SetCallBack(void(*Local_Fptr)(void)){

	/* Input Capture Unit CallBack function TIMER1 */
	TIMER1_ICU_CallBack = Local_Fptr;
    1548:	90 93 d1 07 	sts	0x07D1, r25
    154c:	80 93 d0 07 	sts	0x07D0, r24

}
    1550:	08 95       	ret

00001552 <PWM1_voidRead>:

/******************************************************************************
* Description 	: TIMER1 PWM1 Read Function.		                          *
******************************************************************************/

void PWM1_voidRead(uint_32 *ReturnFreq, uint_8 *ReturnDuty){
    1552:	cf 92       	push	r12
    1554:	df 92       	push	r13
    1556:	ef 92       	push	r14
    1558:	ff 92       	push	r15
    155a:	0f 93       	push	r16
    155c:	1f 93       	push	r17
    155e:	cf 93       	push	r28
    1560:	df 93       	push	r29
    1562:	6c 01       	movw	r12, r24
    1564:	eb 01       	movw	r28, r22

	uint_16 Local_u16TimeON, Local_u16TimeOFF;

	TCNT1 = 0;
    1566:	1d bc       	out	0x2d, r1	; 45
    1568:	1c bc       	out	0x2c, r1	; 44

	TIMER1_voidICU_SetCallBack(Timer1ICU_InterruptAction);
    156a:	8c ee       	ldi	r24, 0xEC	; 236
    156c:	99 e0       	ldi	r25, 0x09	; 9
    156e:	0e 94 a4 0a 	call	0x1548	; 0x1548 <TIMER1_voidICU_SetCallBack>
	TIMER1_voidInputCaptureEdge(ICU_RISING_EDGE);
    1572:	80 e0       	ldi	r24, 0x00	; 0
    1574:	0e 94 cf 09 	call	0x139e	; 0x139e <TIMER1_voidInputCaptureEdge>
	TIMER1_voidICU_InterruptEnable();
    1578:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <TIMER1_voidICU_InterruptEnable>

	Global_u16Flag = 0;
    157c:	10 92 d7 07 	sts	0x07D7, r1
    1580:	10 92 d6 07 	sts	0x07D6, r1

	while(Global_u16Flag < 3);
    1584:	80 91 d6 07 	lds	r24, 0x07D6
    1588:	90 91 d7 07 	lds	r25, 0x07D7
    158c:	03 97       	sbiw	r24, 0x03	; 3
    158e:	d0 f3       	brcs	.-12     	; 0x1584 <PWM1_voidRead+0x32>

	Local_u16TimeON = Global_u16Time2 - Global_u16Time1;
    1590:	60 91 de 07 	lds	r22, 0x07DE
    1594:	70 91 df 07 	lds	r23, 0x07DF
    1598:	20 91 dc 07 	lds	r18, 0x07DC
    159c:	30 91 dd 07 	lds	r19, 0x07DD

	Local_u16TimeOFF = Global_u16Time3 - Global_u16Time2;
    15a0:	e0 90 e0 07 	lds	r14, 0x07E0
    15a4:	f0 90 e1 07 	lds	r15, 0x07E1
    15a8:	40 91 de 07 	lds	r20, 0x07DE
    15ac:	50 91 df 07 	lds	r21, 0x07DF

	*ReturnDuty = ((uint_32) Local_u16TimeON * 100)/((uint_32)Local_u16TimeON + Local_u16TimeOFF);
    15b0:	62 1b       	sub	r22, r18
    15b2:	73 0b       	sbc	r23, r19
    15b4:	80 e0       	ldi	r24, 0x00	; 0
    15b6:	90 e0       	ldi	r25, 0x00	; 0
    15b8:	e4 1a       	sub	r14, r20
    15ba:	f5 0a       	sbc	r15, r21
    15bc:	00 e0       	ldi	r16, 0x00	; 0
    15be:	10 e0       	ldi	r17, 0x00	; 0
    15c0:	e6 0e       	add	r14, r22
    15c2:	f7 1e       	adc	r15, r23
    15c4:	08 1f       	adc	r16, r24
    15c6:	19 1f       	adc	r17, r25
    15c8:	24 e6       	ldi	r18, 0x64	; 100
    15ca:	30 e0       	ldi	r19, 0x00	; 0
    15cc:	40 e0       	ldi	r20, 0x00	; 0
    15ce:	50 e0       	ldi	r21, 0x00	; 0
    15d0:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <__mulsi3>
    15d4:	a8 01       	movw	r20, r16
    15d6:	97 01       	movw	r18, r14
    15d8:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
    15dc:	28 83       	st	Y, r18

	*ReturnFreq = ((uint_32)1000000) / ((uint_32)Local_u16TimeON + Local_u16TimeOFF);
    15de:	60 e4       	ldi	r22, 0x40	; 64
    15e0:	72 e4       	ldi	r23, 0x42	; 66
    15e2:	8f e0       	ldi	r24, 0x0F	; 15
    15e4:	90 e0       	ldi	r25, 0x00	; 0
    15e6:	a8 01       	movw	r20, r16
    15e8:	97 01       	movw	r18, r14
    15ea:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
    15ee:	f6 01       	movw	r30, r12
    15f0:	20 83       	st	Z, r18
    15f2:	31 83       	std	Z+1, r19	; 0x01
    15f4:	42 83       	std	Z+2, r20	; 0x02
    15f6:	53 83       	std	Z+3, r21	; 0x03

}
    15f8:	df 91       	pop	r29
    15fa:	cf 91       	pop	r28
    15fc:	1f 91       	pop	r17
    15fe:	0f 91       	pop	r16
    1600:	ff 90       	pop	r15
    1602:	ef 90       	pop	r14
    1604:	df 90       	pop	r13
    1606:	cf 90       	pop	r12
    1608:	08 95       	ret

0000160a <TIMER1_voidOVF_SetCallBack>:
******************************************************************************/

void TIMER1_voidOVF_SetCallBack(void(*Local_Fptr)(void)){

	/* Overflow CallBack function TIMER1 */
	TIMER1_OVF_CallBack = Local_Fptr;
    160a:	90 93 cf 07 	sts	0x07CF, r25
    160e:	80 93 ce 07 	sts	0x07CE, r24

}
    1612:	08 95       	ret

00001614 <TIMER0_voidInit>:
*			      & Prescaler vale.                                           *
******************************************************************************/

void TIMER0_voidInit(Timer0Mode_t Mode, Timer0Scaler_t Prescaler){

	switch(Mode){
    1614:	81 30       	cpi	r24, 0x01	; 1
    1616:	81 f0       	breq	.+32     	; 0x1638 <TIMER0_voidInit+0x24>
    1618:	81 30       	cpi	r24, 0x01	; 1
    161a:	28 f0       	brcs	.+10     	; 0x1626 <TIMER0_voidInit+0x12>
    161c:	82 30       	cpi	r24, 0x02	; 2
    161e:	a9 f0       	breq	.+42     	; 0x164a <TIMER0_voidInit+0x36>
    1620:	83 30       	cpi	r24, 0x03	; 3
    1622:	21 f5       	brne	.+72     	; 0x166c <TIMER0_voidInit+0x58>
    1624:	1b c0       	rjmp	.+54     	; 0x165c <TIMER0_voidInit+0x48>
	
		case TIMER0_NORMAL_MODE :
			/* Select Normal mode or overflow mode */
			CLR_BIT(TCCR0, WGM01);	CLR_BIT(TCCR0, WGM00);
    1626:	e3 e5       	ldi	r30, 0x53	; 83
    1628:	f0 e0       	ldi	r31, 0x00	; 0
    162a:	80 81       	ld	r24, Z
    162c:	87 7f       	andi	r24, 0xF7	; 247
    162e:	80 83       	st	Z, r24
    1630:	80 81       	ld	r24, Z
    1632:	8f 7b       	andi	r24, 0xBF	; 191
    1634:	80 83       	st	Z, r24
    1636:	1a c0       	rjmp	.+52     	; 0x166c <TIMER0_voidInit+0x58>
		break;	
		
		case TIMER0_PHASE_CORRECT_MODE :
			/* Select mode */
			SET_BIT(TCCR0, WGM00);	CLR_BIT(TCCR0, WGM01);
    1638:	e3 e5       	ldi	r30, 0x53	; 83
    163a:	f0 e0       	ldi	r31, 0x00	; 0
    163c:	80 81       	ld	r24, Z
    163e:	80 64       	ori	r24, 0x40	; 64
    1640:	80 83       	st	Z, r24
    1642:	80 81       	ld	r24, Z
    1644:	87 7f       	andi	r24, 0xF7	; 247
    1646:	80 83       	st	Z, r24
    1648:	11 c0       	rjmp	.+34     	; 0x166c <TIMER0_voidInit+0x58>
		break;	
		
		case TIMER0_CTC_MODE :
			/* Select CTC mode  */
			CLR_BIT(TCCR0, WGM00);	SET_BIT(TCCR0, WGM01);
    164a:	e3 e5       	ldi	r30, 0x53	; 83
    164c:	f0 e0       	ldi	r31, 0x00	; 0
    164e:	80 81       	ld	r24, Z
    1650:	8f 7b       	andi	r24, 0xBF	; 191
    1652:	80 83       	st	Z, r24
    1654:	80 81       	ld	r24, Z
    1656:	88 60       	ori	r24, 0x08	; 8
    1658:	80 83       	st	Z, r24
    165a:	08 c0       	rjmp	.+16     	; 0x166c <TIMER0_voidInit+0x58>
		break;
		
		case TIMER0_FAST_PWM_MODE :
			/* Select PWM, Fast mode */
			SET_BIT(TCCR0, WGM00);	SET_BIT(TCCR0, WGM01);
    165c:	e3 e5       	ldi	r30, 0x53	; 83
    165e:	f0 e0       	ldi	r31, 0x00	; 0
    1660:	80 81       	ld	r24, Z
    1662:	80 64       	ori	r24, 0x40	; 64
    1664:	80 83       	st	Z, r24
    1666:	80 81       	ld	r24, Z
    1668:	88 60       	ori	r24, 0x08	; 8
    166a:	80 83       	st	Z, r24
		
		default:   break;
	}
	
	/* Prescaler mask */
	TCCR0 &= PRESCALER_MASK;
    166c:	e3 e5       	ldi	r30, 0x53	; 83
    166e:	f0 e0       	ldi	r31, 0x00	; 0
    1670:	80 81       	ld	r24, Z
    1672:	88 7f       	andi	r24, 0xF8	; 248
    1674:	80 83       	st	Z, r24
	
	/* Set prescaler value */
	TCCR0 |= Prescaler;
    1676:	80 81       	ld	r24, Z
    1678:	86 2b       	or	r24, r22
    167a:	80 83       	st	Z, r24

}
    167c:	08 95       	ret

0000167e <TIMER0_voidOutputCompareInit>:
*                 Select Output Compare Mode.                                 *
******************************************************************************/

void TIMER0_voidOutputCompareInit(Timer0_OutputCompareMode_t OC0Mode){

	switch(OC0Mode){
    167e:	81 30       	cpi	r24, 0x01	; 1
    1680:	81 f0       	breq	.+32     	; 0x16a2 <TIMER0_voidOutputCompareInit+0x24>
    1682:	81 30       	cpi	r24, 0x01	; 1
    1684:	28 f0       	brcs	.+10     	; 0x1690 <TIMER0_voidOutputCompareInit+0x12>
    1686:	82 30       	cpi	r24, 0x02	; 2
    1688:	a9 f0       	breq	.+42     	; 0x16b4 <TIMER0_voidOutputCompareInit+0x36>
    168a:	83 30       	cpi	r24, 0x03	; 3
    168c:	21 f5       	brne	.+72     	; 0x16d6 <TIMER0_voidOutputCompareInit+0x58>
    168e:	1b c0       	rjmp	.+54     	; 0x16c6 <TIMER0_voidOutputCompareInit+0x48>

		case TIMER0_OC0_DISCONNECTED_MODE :
			// OC0 disconnected
			CLR_BIT(TCCR0, COM00);	CLR_BIT(TCCR0, COM01);
    1690:	e3 e5       	ldi	r30, 0x53	; 83
    1692:	f0 e0       	ldi	r31, 0x00	; 0
    1694:	80 81       	ld	r24, Z
    1696:	8f 7e       	andi	r24, 0xEF	; 239
    1698:	80 83       	st	Z, r24
    169a:	80 81       	ld	r24, Z
    169c:	8f 7d       	andi	r24, 0xDF	; 223
    169e:	80 83       	st	Z, r24
    16a0:	08 95       	ret
		break;

		case TIMER0_OC0_TOGGLE_MODE :
			// Toggle OC0 on compare match
			SET_BIT(TCCR0, COM00);	CLR_BIT(TCCR0, COM01);
    16a2:	e3 e5       	ldi	r30, 0x53	; 83
    16a4:	f0 e0       	ldi	r31, 0x00	; 0
    16a6:	80 81       	ld	r24, Z
    16a8:	80 61       	ori	r24, 0x10	; 16
    16aa:	80 83       	st	Z, r24
    16ac:	80 81       	ld	r24, Z
    16ae:	8f 7d       	andi	r24, 0xDF	; 223
    16b0:	80 83       	st	Z, r24
    16b2:	08 95       	ret
		break;

		case TIMER0_OC0_NON_INVERTING_MODE :
			// Non inverting OC0
			CLR_BIT(TCCR0, COM00);	SET_BIT(TCCR0, COM01);
    16b4:	e3 e5       	ldi	r30, 0x53	; 83
    16b6:	f0 e0       	ldi	r31, 0x00	; 0
    16b8:	80 81       	ld	r24, Z
    16ba:	8f 7e       	andi	r24, 0xEF	; 239
    16bc:	80 83       	st	Z, r24
    16be:	80 81       	ld	r24, Z
    16c0:	80 62       	ori	r24, 0x20	; 32
    16c2:	80 83       	st	Z, r24
    16c4:	08 95       	ret
		break;

		case TIMER0_OC0_INVERTING_MODE :
			// inverting OC0
			SET_BIT(TCCR0, COM00);	SET_BIT(TCCR0, COM01);
    16c6:	e3 e5       	ldi	r30, 0x53	; 83
    16c8:	f0 e0       	ldi	r31, 0x00	; 0
    16ca:	80 81       	ld	r24, Z
    16cc:	80 61       	ori	r24, 0x10	; 16
    16ce:	80 83       	st	Z, r24
    16d0:	80 81       	ld	r24, Z
    16d2:	80 62       	ori	r24, 0x20	; 32
    16d4:	80 83       	st	Z, r24
    16d6:	08 95       	ret

000016d8 <TIMER0_voidSetTimerCounterValue>:
* Description 	: TIMER0 Set Timer Counter Value Function.				      *
******************************************************************************/

void TIMER0_voidSetTimerCounterValue(uint_8 Copy_u8TimerValue){

	TCNT0 = Copy_u8TimerValue;
    16d8:	82 bf       	out	0x32, r24	; 50
}
    16da:	08 95       	ret

000016dc <TIMER0_voidSetOutputCompareValue>:
void TIMER0_voidSetOutputCompareValue(uint_8 Copy_u8CompareValue){

	OCR0 = Copy_u8CompareValue;
    16dc:	8c bf       	out	0x3c, r24	; 60
}
    16de:	08 95       	ret

000016e0 <Timer0_void_Intilize_Pwm>:
void Timer0_void_Intilize_Pwm(void){
	////FAST PWM
	SET_BIT(TCCR0,WGM00);
    16e0:	e3 e5       	ldi	r30, 0x53	; 83
    16e2:	f0 e0       	ldi	r31, 0x00	; 0
    16e4:	80 81       	ld	r24, Z
    16e6:	80 64       	ori	r24, 0x40	; 64
    16e8:	80 83       	st	Z, r24
	SET_BIT(TCCR0,WGM01);
    16ea:	80 81       	ld	r24, Z
    16ec:	88 60       	ori	r24, 0x08	; 8
    16ee:	80 83       	st	Z, r24
	//FAST PWM clear COMPARE
	//SET_BIT(TCCR0,COM01);
	//CLR_BIT(TCCR0,COM00);
	//FAST PWM CLR COMPARE
		SET_BIT(TCCR0,COM01);
    16f0:	80 81       	ld	r24, Z
    16f2:	80 62       	ori	r24, 0x20	; 32
    16f4:	80 83       	st	Z, r24
		/////
		SET_BIT(TCCR0,COM00);
    16f6:	80 81       	ld	r24, Z
    16f8:	80 61       	ori	r24, 0x10	; 16
    16fa:	80 83       	st	Z, r24
	//clr bit PRESCALER 64
	TCCR0=TCCR0 & TIMER_PRES_MUSK_PWM;
    16fc:	80 81       	ld	r24, Z
    16fe:	80 7e       	andi	r24, 0xE0	; 224
    1700:	80 83       	st	Z, r24
	//set bit PRESCALER 64
	TCCR0=TCCR0 | TIMER_DIV_BY_8;
    1702:	80 81       	ld	r24, Z
    1704:	82 60       	ori	r24, 0x02	; 2
    1706:	80 83       	st	Z, r24
	//DIO_voidSetPinDirection(DIO_u8PORTB,PIN3,Output);
	//SET COMPARE VALUE
	TIMER0_voidSetOutputCompareValue(63U); //25% DUTY CYCLE 64 PRESCALER //16 MHZ CRYSTAL
    1708:	8f e3       	ldi	r24, 0x3F	; 63
    170a:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <TIMER0_voidSetOutputCompareValue>

	TCNT0=0; //NORAML MODE
    170e:	12 be       	out	0x32, r1	; 50
	//enable NO NEEDING
	//SET_BIT(TIFR,TIFR_OCF0); //enable compare match INTERRUPT FLAG
	//SET_BIT(TIMSK,TIMSK_OCIE0);//enable compare match INTERRUPT ENABLE IN THE END
}
    1710:	08 95       	ret

00001712 <TIMER0_u8GetTimerCounterValue>:
* Description 	: TIMER0 Get Timer Counter Value Function.				      *
******************************************************************************/

uint_8 TIMER0_u8GetTimerCounterValue(void){

	return TCNT0;
    1712:	82 b7       	in	r24, 0x32	; 50
}
    1714:	08 95       	ret

00001716 <Timer0_U8_SET_CALL_BACK>:
void Timer0_U8_SET_CALL_BACK(void(*p1(void))){
	if(p1!=NULL){
    1716:	00 97       	sbiw	r24, 0x00	; 0
    1718:	21 f0       	breq	.+8      	; 0x1722 <Timer0_U8_SET_CALL_BACK+0xc>
		TIMER0_OverflowCallBack=p1;
    171a:	90 93 e5 07 	sts	0x07E5, r25
    171e:	80 93 e4 07 	sts	0x07E4, r24
    1722:	08 95       	ret

00001724 <__vector_11>:

	}
}
void __vector_11(void)__attribute__ ((signal));

void __vector_11(void){  //TIMER0 overflow
    1724:	1f 92       	push	r1
    1726:	0f 92       	push	r0
    1728:	0f b6       	in	r0, 0x3f	; 63
    172a:	0f 92       	push	r0
    172c:	11 24       	eor	r1, r1
    172e:	2f 93       	push	r18
    1730:	3f 93       	push	r19
    1732:	4f 93       	push	r20
    1734:	5f 93       	push	r21
    1736:	6f 93       	push	r22
    1738:	7f 93       	push	r23
    173a:	8f 93       	push	r24
    173c:	9f 93       	push	r25
    173e:	af 93       	push	r26
    1740:	bf 93       	push	r27
    1742:	ef 93       	push	r30
    1744:	ff 93       	push	r31
	TIMER0_OverflowCallBack();
    1746:	e0 91 e4 07 	lds	r30, 0x07E4
    174a:	f0 91 e5 07 	lds	r31, 0x07E5
    174e:	09 95       	icall

}
    1750:	ff 91       	pop	r31
    1752:	ef 91       	pop	r30
    1754:	bf 91       	pop	r27
    1756:	af 91       	pop	r26
    1758:	9f 91       	pop	r25
    175a:	8f 91       	pop	r24
    175c:	7f 91       	pop	r23
    175e:	6f 91       	pop	r22
    1760:	5f 91       	pop	r21
    1762:	4f 91       	pop	r20
    1764:	3f 91       	pop	r19
    1766:	2f 91       	pop	r18
    1768:	0f 90       	pop	r0
    176a:	0f be       	out	0x3f, r0	; 63
    176c:	0f 90       	pop	r0
    176e:	1f 90       	pop	r1
    1770:	18 95       	reti

00001772 <TIMER0_voidUpdateDutyCycle>:
/******************************************************************************
* Description 	: TIMER0 Update Duty Cycle Value Function                     *
* 			      and put it in the OCR0 register.                            *
******************************************************************************/

void TIMER0_voidUpdateDutyCycle(uint_8 Copy_u8DutyCycle){
    1772:	98 2f       	mov	r25, r24

	if(Copy_u8DutyCycle <= 100){
    1774:	85 36       	cpi	r24, 0x65	; 101
    1776:	78 f4       	brcc	.+30     	; 0x1796 <TIMER0_voidUpdateDutyCycle+0x24>

		uint_8 Local_u8TimeON = ((uint_16)Copy_u8DutyCycle * (TIMER0_MAX_COUNT)) / 100;
    1778:	8f ef       	ldi	r24, 0xFF	; 255
    177a:	98 9f       	mul	r25, r24
    177c:	c0 01       	movw	r24, r0
    177e:	11 24       	eor	r1, r1
    1780:	64 e6       	ldi	r22, 0x64	; 100
    1782:	70 e0       	ldi	r23, 0x00	; 0
    1784:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <__udivmodhi4>

		if(Local_u8TimeON > 1){
    1788:	62 30       	cpi	r22, 0x02	; 2
    178a:	20 f0       	brcs	.+8      	; 0x1794 <TIMER0_voidUpdateDutyCycle+0x22>

			OCR0 = Local_u8TimeON-1;
    178c:	86 2f       	mov	r24, r22
    178e:	81 50       	subi	r24, 0x01	; 1
    1790:	8c bf       	out	0x3c, r24	; 60
    1792:	08 95       	ret
		}
		else{  OCR0 = 0;  }
    1794:	1c be       	out	0x3c, r1	; 60
    1796:	08 95       	ret

00001798 <TIMER0_voidOverflowInterruptEnable>:
******************************************************************************/

void TIMER0_voidOverflowInterruptEnable(void){
	
	/* Enable overflow mode interrupt */
	SET_BIT(TIMSK, TOIE0);
    1798:	e9 e5       	ldi	r30, 0x59	; 89
    179a:	f0 e0       	ldi	r31, 0x00	; 0
    179c:	80 81       	ld	r24, Z
    179e:	81 60       	ori	r24, 0x01	; 1
    17a0:	80 83       	st	Z, r24
}
    17a2:	08 95       	ret

000017a4 <TIMER0_voidOverflowInterruptDisable>:
******************************************************************************/

void TIMER0_voidOverflowInterruptDisable(void){
	
	/* Disable overflow mode interrupt */
	CLR_BIT(TIMSK, TOIE0);
    17a4:	e9 e5       	ldi	r30, 0x59	; 89
    17a6:	f0 e0       	ldi	r31, 0x00	; 0
    17a8:	80 81       	ld	r24, Z
    17aa:	8e 7f       	andi	r24, 0xFE	; 254
    17ac:	80 83       	st	Z, r24
}
    17ae:	08 95       	ret

000017b0 <TIMER0_voidCompareMatchnterruptEnable>:
******************************************************************************/

void TIMER0_voidCompareMatchnterruptEnable(void){
	
	/* Output Compare Match interrupt Enable */
	SET_BIT(TIMSK, OCIE0);
    17b0:	e9 e5       	ldi	r30, 0x59	; 89
    17b2:	f0 e0       	ldi	r31, 0x00	; 0
    17b4:	80 81       	ld	r24, Z
    17b6:	82 60       	ori	r24, 0x02	; 2
    17b8:	80 83       	st	Z, r24
}
    17ba:	08 95       	ret

000017bc <TIMER0_voidCompareMatchInterruptDisable>:
******************************************************************************/

void TIMER0_voidCompareMatchInterruptDisable(void){
	
	/* Output Compare Match interrupt Disable */
	CLR_BIT(TIMSK, OCIE0);
    17bc:	e9 e5       	ldi	r30, 0x59	; 89
    17be:	f0 e0       	ldi	r31, 0x00	; 0
    17c0:	80 81       	ld	r24, Z
    17c2:	8d 7f       	andi	r24, 0xFD	; 253
    17c4:	80 83       	st	Z, r24
}
    17c6:	08 95       	ret

000017c8 <TIMER0_voidOverflowSetCallBack>:
*		          [ Layer Architecture Problem Solved ].                      *
******************************************************************************/

void TIMER0_voidOverflowSetCallBack(void(*Local_Fptr)(void)){

	TIMER0_OverflowCallBack = Local_Fptr;
    17c8:	90 93 e5 07 	sts	0x07E5, r25
    17cc:	80 93 e4 07 	sts	0x07E4, r24

}
    17d0:	08 95       	ret

000017d2 <TIMER0_voidCompareMatchSetCallBack>:
*		          [ Layer Architecture Problem Solved ].                      *
******************************************************************************/

void TIMER0_voidCompareMatchSetCallBack(void(*Local_Fptr)(void)){

	TIMER0_CompareMatchCallBack = Local_Fptr;
    17d2:	90 93 e3 07 	sts	0x07E3, r25
    17d6:	80 93 e2 07 	sts	0x07E2, r24

}
    17da:	08 95       	ret

000017dc <EEPROM_u8ReadByte>:
/******************************************************************************
***************************** Function Implementation *************************
******************************************************************************/


uint_8 EEPROM_u8ReadByte(uint_16 Copy_u16Address){
    17dc:	9c 01       	movw	r18, r24

	/* Wait for completion of previous write */
	while(EECR & (1<<EEWE));
    17de:	ec e3       	ldi	r30, 0x3C	; 60
    17e0:	f0 e0       	ldi	r31, 0x00	; 0
    17e2:	80 81       	ld	r24, Z
    17e4:	81 fd       	sbrc	r24, 1
    17e6:	fd cf       	rjmp	.-6      	; 0x17e2 <EEPROM_u8ReadByte+0x6>

	/* Set up address register */
	EEAR = Copy_u16Address;
    17e8:	3f bb       	out	0x1f, r19	; 31
    17ea:	2e bb       	out	0x1e, r18	; 30

	/* Start eeprom read by writing EERE */
	EECR |= (1<<EERE);
    17ec:	ec e3       	ldi	r30, 0x3C	; 60
    17ee:	f0 e0       	ldi	r31, 0x00	; 0
    17f0:	80 81       	ld	r24, Z
    17f2:	81 60       	ori	r24, 0x01	; 1
    17f4:	80 83       	st	Z, r24

	/* Return data from data register */
	return EEDR;
    17f6:	8d b3       	in	r24, 0x1d	; 29

}
    17f8:	08 95       	ret

000017fa <EEPROM_voidReadeBlock>:


void EEPROM_voidReadeBlock(uint_16 Copy_u16Address, uint_8 *Ptr_u8Return, uint_16 Copy_u16Size){
    17fa:	ef 92       	push	r14
    17fc:	ff 92       	push	r15
    17fe:	0f 93       	push	r16
    1800:	1f 93       	push	r17
    1802:	cf 93       	push	r28
    1804:	df 93       	push	r29
    1806:	ec 01       	movw	r28, r24

	uint_16 Local_u16ByteCounter = 0;

	/* Wait for completion of previous write */
	while(EECR & (1<<EEWE));
    1808:	ec e3       	ldi	r30, 0x3C	; 60
    180a:	f0 e0       	ldi	r31, 0x00	; 0
    180c:	80 81       	ld	r24, Z
    180e:	81 fd       	sbrc	r24, 1
    1810:	fd cf       	rjmp	.-6      	; 0x180c <EEPROM_voidReadeBlock+0x12>

	while(Local_u16ByteCounter < Copy_u16Size){
    1812:	41 15       	cp	r20, r1
    1814:	51 05       	cpc	r21, r1
    1816:	f9 f0       	breq	.+62     	; 0x1856 <EEPROM_voidReadeBlock+0x5c>
    1818:	20 e0       	ldi	r18, 0x00	; 0
    181a:	30 e0       	ldi	r19, 0x00	; 0

		/* Set up address register */
		EEAR = Copy_u16Address + Local_u16ByteCounter;
    181c:	0f 2e       	mov	r0, r31
    181e:	fe e3       	ldi	r31, 0x3E	; 62
    1820:	ef 2e       	mov	r14, r31
    1822:	ff 24       	eor	r15, r15
    1824:	f0 2d       	mov	r31, r0

		/* Start eeprom read by writing EERE */
		EECR |= (1<<EERE);
    1826:	ac e3       	ldi	r26, 0x3C	; 60
    1828:	b0 e0       	ldi	r27, 0x00	; 0

		/* move data form data register to the array */
		*(Ptr_u8Return + Local_u16ByteCounter) = EEDR;
    182a:	0d e3       	ldi	r16, 0x3D	; 61
    182c:	10 e0       	ldi	r17, 0x00	; 0
	uint_16 Local_u16ByteCounter = 0;

	/* Wait for completion of previous write */
	while(EECR & (1<<EEWE));

	while(Local_u16ByteCounter < Copy_u16Size){
    182e:	c9 01       	movw	r24, r18
    1830:	8c 0f       	add	r24, r28
    1832:	9d 1f       	adc	r25, r29

		/* Set up address register */
		EEAR = Copy_u16Address + Local_u16ByteCounter;
    1834:	f7 01       	movw	r30, r14
    1836:	91 83       	std	Z+1, r25	; 0x01
    1838:	80 83       	st	Z, r24

		/* Start eeprom read by writing EERE */
		EECR |= (1<<EERE);
    183a:	8c 91       	ld	r24, X
    183c:	81 60       	ori	r24, 0x01	; 1
    183e:	8c 93       	st	X, r24

		/* move data form data register to the array */
		*(Ptr_u8Return + Local_u16ByteCounter) = EEDR;
    1840:	f8 01       	movw	r30, r16
    1842:	80 81       	ld	r24, Z
    1844:	fb 01       	movw	r30, r22
    1846:	e2 0f       	add	r30, r18
    1848:	f3 1f       	adc	r31, r19
    184a:	80 83       	st	Z, r24

		/* increase the bytes counter */
		Local_u16ByteCounter++;
    184c:	2f 5f       	subi	r18, 0xFF	; 255
    184e:	3f 4f       	sbci	r19, 0xFF	; 255
	uint_16 Local_u16ByteCounter = 0;

	/* Wait for completion of previous write */
	while(EECR & (1<<EEWE));

	while(Local_u16ByteCounter < Copy_u16Size){
    1850:	24 17       	cp	r18, r20
    1852:	35 07       	cpc	r19, r21
    1854:	60 f3       	brcs	.-40     	; 0x182e <EEPROM_voidReadeBlock+0x34>
		/* increase the bytes counter */
		Local_u16ByteCounter++;

	}

}
    1856:	df 91       	pop	r29
    1858:	cf 91       	pop	r28
    185a:	1f 91       	pop	r17
    185c:	0f 91       	pop	r16
    185e:	ff 90       	pop	r15
    1860:	ef 90       	pop	r14
    1862:	08 95       	ret

00001864 <EEPROM_voidWriteByte>:


void EEPROM_voidWriteByte(uint_16 Copy_u16Address, uint_8 Copy_u8Data){
    1864:	9c 01       	movw	r18, r24

	/* Wait for completion of previous write */
	while(EECR & (1<<EEWE));
    1866:	ec e3       	ldi	r30, 0x3C	; 60
    1868:	f0 e0       	ldi	r31, 0x00	; 0
    186a:	80 81       	ld	r24, Z
    186c:	81 fd       	sbrc	r24, 1
    186e:	fd cf       	rjmp	.-6      	; 0x186a <EEPROM_voidWriteByte+0x6>

	/* Set up address register */
	EEAR = Copy_u16Address;
    1870:	3f bb       	out	0x1f, r19	; 31
    1872:	2e bb       	out	0x1e, r18	; 30

	/* Read the byte in the address of EEAR */
	EECR |= (1<<EERE);
    1874:	ec e3       	ldi	r30, 0x3C	; 60
    1876:	f0 e0       	ldi	r31, 0x00	; 0
    1878:	80 81       	ld	r24, Z
    187a:	81 60       	ori	r24, 0x01	; 1
    187c:	80 83       	st	Z, r24

	/* Compare the value read to value to be written */
	if(EEDR != Copy_u8Data){
    187e:	8d b3       	in	r24, 0x1d	; 29
    1880:	86 17       	cp	r24, r22
    1882:	39 f0       	breq	.+14     	; 0x1892 <EEPROM_voidWriteByte+0x2e>

		/* if they are not equal then write the data */
		/* Set up data registers */
		EEDR = Copy_u8Data;
    1884:	6d bb       	out	0x1d, r22	; 29

		/* Write logical one to EEMWE */
		EECR |= (1<<EEMWE);
    1886:	80 81       	ld	r24, Z
    1888:	84 60       	ori	r24, 0x04	; 4
    188a:	80 83       	st	Z, r24

		/* Start eeprom write by setting EEWE */
		EECR |= (1<<EEWE);
    188c:	80 81       	ld	r24, Z
    188e:	82 60       	ori	r24, 0x02	; 2
    1890:	80 83       	st	Z, r24
    1892:	08 95       	ret

00001894 <EEPROM_voidWriteBlock>:
}




void EEPROM_voidWriteBlock(uint_16 Copy_u16Address, uint_8 *Copy_u8Data, uint_16 Copy_u16Size){
    1894:	ef 92       	push	r14
    1896:	ff 92       	push	r15
    1898:	0f 93       	push	r16
    189a:	1f 93       	push	r17
    189c:	cf 93       	push	r28
    189e:	df 93       	push	r29
    18a0:	8c 01       	movw	r16, r24

	uint_16 Local_u16ByteCounter = 0;

	while(Local_u16ByteCounter < Copy_u16Size){
    18a2:	41 15       	cp	r20, r1
    18a4:	51 05       	cpc	r21, r1
    18a6:	51 f1       	breq	.+84     	; 0x18fc <EEPROM_voidWriteBlock+0x68>
    18a8:	20 e0       	ldi	r18, 0x00	; 0
    18aa:	30 e0       	ldi	r19, 0x00	; 0

		/* Wait for completion of previous write */
		while(EECR & (1<<EEWE));
    18ac:	ac e3       	ldi	r26, 0x3C	; 60
    18ae:	b0 e0       	ldi	r27, 0x00	; 0

		/* Set up address register */
		EEAR = Copy_u16Address + Local_u16ByteCounter;
    18b0:	0f 2e       	mov	r0, r31
    18b2:	fe e3       	ldi	r31, 0x3E	; 62
    18b4:	ef 2e       	mov	r14, r31
    18b6:	ff 24       	eor	r15, r15
    18b8:	f0 2d       	mov	r31, r0

		/* Read the byte in the address of EEAR */
		EECR |= (1<<EERE);

		/* Compare the value read to value to be written */
		if(EEDR != (*(Copy_u8Data + Local_u16ByteCounter))){
    18ba:	cd e3       	ldi	r28, 0x3D	; 61
    18bc:	d0 e0       	ldi	r29, 0x00	; 0
	uint_16 Local_u16ByteCounter = 0;

	while(Local_u16ByteCounter < Copy_u16Size){

		/* Wait for completion of previous write */
		while(EECR & (1<<EEWE));
    18be:	8c 91       	ld	r24, X
    18c0:	81 fd       	sbrc	r24, 1
    18c2:	fd cf       	rjmp	.-6      	; 0x18be <EEPROM_voidWriteBlock+0x2a>
    18c4:	c9 01       	movw	r24, r18
    18c6:	80 0f       	add	r24, r16
    18c8:	91 1f       	adc	r25, r17

		/* Set up address register */
		EEAR = Copy_u16Address + Local_u16ByteCounter;
    18ca:	f7 01       	movw	r30, r14
    18cc:	91 83       	std	Z+1, r25	; 0x01
    18ce:	80 83       	st	Z, r24

		/* Read the byte in the address of EEAR */
		EECR |= (1<<EERE);
    18d0:	8c 91       	ld	r24, X
    18d2:	81 60       	ori	r24, 0x01	; 1
    18d4:	8c 93       	st	X, r24

		/* Compare the value read to value to be written */
		if(EEDR != (*(Copy_u8Data + Local_u16ByteCounter))){
    18d6:	88 81       	ld	r24, Y
    18d8:	fb 01       	movw	r30, r22
    18da:	e2 0f       	add	r30, r18
    18dc:	f3 1f       	adc	r31, r19
    18de:	e0 81       	ld	r30, Z
    18e0:	8e 17       	cp	r24, r30
    18e2:	39 f0       	breq	.+14     	; 0x18f2 <EEPROM_voidWriteBlock+0x5e>

			/* if they are not equal then write the data */
			/* Set up data registers */
			EEDR = *(Copy_u8Data + Local_u16ByteCounter);
    18e4:	e8 83       	st	Y, r30

			/* Write logical one to EEMWE */
			EECR |= (1<<EEMWE);
    18e6:	8c 91       	ld	r24, X
    18e8:	84 60       	ori	r24, 0x04	; 4
    18ea:	8c 93       	st	X, r24

			/* Start eeprom write by setting EEWE */
			EECR |= (1<<EEWE);
    18ec:	8c 91       	ld	r24, X
    18ee:	82 60       	ori	r24, 0x02	; 2
    18f0:	8c 93       	st	X, r24
		}

		else{    /* return error */    }

		/* increase the bytes counter */
		Local_u16ByteCounter++;
    18f2:	2f 5f       	subi	r18, 0xFF	; 255
    18f4:	3f 4f       	sbci	r19, 0xFF	; 255

void EEPROM_voidWriteBlock(uint_16 Copy_u16Address, uint_8 *Copy_u8Data, uint_16 Copy_u16Size){

	uint_16 Local_u16ByteCounter = 0;

	while(Local_u16ByteCounter < Copy_u16Size){
    18f6:	24 17       	cp	r18, r20
    18f8:	35 07       	cpc	r19, r21
    18fa:	08 f3       	brcs	.-62     	; 0x18be <EEPROM_voidWriteBlock+0x2a>

		/* increase the bytes counter */
		Local_u16ByteCounter++;
	}

}
    18fc:	df 91       	pop	r29
    18fe:	cf 91       	pop	r28
    1900:	1f 91       	pop	r17
    1902:	0f 91       	pop	r16
    1904:	ff 90       	pop	r15
    1906:	ef 90       	pop	r14
    1908:	08 95       	ret

0000190a <EEPROM_voidReadyInterruptEnable>:



void EEPROM_voidReadyInterruptEnable(void){

	SET_BIT(EECR, EERIE);
    190a:	ec e3       	ldi	r30, 0x3C	; 60
    190c:	f0 e0       	ldi	r31, 0x00	; 0
    190e:	80 81       	ld	r24, Z
    1910:	88 60       	ori	r24, 0x08	; 8
    1912:	80 83       	st	Z, r24
}
    1914:	08 95       	ret

00001916 <EEPROM_voidReadyInterruptDisable>:



void EEPROM_voidReadyInterruptDisable(void){

	CLR_BIT(EECR, EERIE);
    1916:	ec e3       	ldi	r30, 0x3C	; 60
    1918:	f0 e0       	ldi	r31, 0x00	; 0
    191a:	80 81       	ld	r24, Z
    191c:	87 7f       	andi	r24, 0xF7	; 247
    191e:	80 83       	st	Z, r24
}
    1920:	08 95       	ret

00001922 <EEPROM_voidSetCallBack>:
*		          [ Layer Architecture Problem Solved ].                      *
******************************************************************************/

void EEPROM_voidSetCallBack(void(*Local_ptr)(void)){

	EEPROM_CallBack = Local_ptr;
    1922:	90 93 e7 07 	sts	0x07E7, r25
    1926:	80 93 e6 07 	sts	0x07E6, r24

}
    192a:	08 95       	ret

0000192c <__vector_17>:

/******************************************************************************
* !comment  :  ISR Function EEPROM.  							 			  *
******************************************************************************/

ISR(EEPROM_RDY_VECT){
    192c:	1f 92       	push	r1
    192e:	0f 92       	push	r0
    1930:	0f b6       	in	r0, 0x3f	; 63
    1932:	0f 92       	push	r0
    1934:	11 24       	eor	r1, r1
    1936:	2f 93       	push	r18
    1938:	3f 93       	push	r19
    193a:	4f 93       	push	r20
    193c:	5f 93       	push	r21
    193e:	6f 93       	push	r22
    1940:	7f 93       	push	r23
    1942:	8f 93       	push	r24
    1944:	9f 93       	push	r25
    1946:	af 93       	push	r26
    1948:	bf 93       	push	r27
    194a:	ef 93       	push	r30
    194c:	ff 93       	push	r31

	if(EEPROM_CallBack != NULL){
    194e:	e0 91 e6 07 	lds	r30, 0x07E6
    1952:	f0 91 e7 07 	lds	r31, 0x07E7
    1956:	30 97       	sbiw	r30, 0x00	; 0
    1958:	09 f0       	breq	.+2      	; 0x195c <__vector_17+0x30>

		EEPROM_CallBack();
    195a:	09 95       	icall
	}

	else{ /* Return error */ }
}
    195c:	ff 91       	pop	r31
    195e:	ef 91       	pop	r30
    1960:	bf 91       	pop	r27
    1962:	af 91       	pop	r26
    1964:	9f 91       	pop	r25
    1966:	8f 91       	pop	r24
    1968:	7f 91       	pop	r23
    196a:	6f 91       	pop	r22
    196c:	5f 91       	pop	r21
    196e:	4f 91       	pop	r20
    1970:	3f 91       	pop	r19
    1972:	2f 91       	pop	r18
    1974:	0f 90       	pop	r0
    1976:	0f be       	out	0x3f, r0	; 63
    1978:	0f 90       	pop	r0
    197a:	1f 90       	pop	r1
    197c:	18 95       	reti

0000197e <readDataBlockFromEEPROM>:
void writeDataBlockToEEPROM(uint16_t address, uint8_t* data, uint16_t length) {
  eeprom_write_block(data, (void*)address, length);
}

// Function to read a block of data from EEPROM
void readDataBlockFromEEPROM(uint16_t address, uint8_t* data, uint16_t length) {
    197e:	9c 01       	movw	r18, r24
    1980:	cb 01       	movw	r24, r22
  eeprom_read_block(data, (void*)address, length);
    1982:	b9 01       	movw	r22, r18
    1984:	0e 94 fa 2d 	call	0x5bf4	; 0x5bf4 <__eerd_block_m32>
}
    1988:	08 95       	ret

0000198a <writeDataBlockToEEPROM>:
uint8_t readDataFromEEPROM(uint16_t address) {
  return eeprom_read_byte((uint8_t*)address);
}

// Function to write a block of data to EEPROM
void writeDataBlockToEEPROM(uint16_t address, uint8_t* data, uint16_t length) {
    198a:	9c 01       	movw	r18, r24
    198c:	cb 01       	movw	r24, r22
  eeprom_write_block(data, (void*)address, length);
    198e:	b9 01       	movw	r22, r18
    1990:	0e 94 12 2e 	call	0x5c24	; 0x5c24 <__eewr_block_m32>
}
    1994:	08 95       	ret

00001996 <readDataFromEEPROM>:
  eeprom_write_byte((uint8_t*)address, data);
}

// Function to read data from EEPROM
uint8_t readDataFromEEPROM(uint16_t address) {
  return eeprom_read_byte((uint8_t*)address);
    1996:	0e 94 0a 2e 	call	0x5c14	; 0x5c14 <__eerd_byte_m32>
}
    199a:	08 95       	ret

0000199c <writeDataToEEPROM>:



// Function to write data to EEPROM
void writeDataToEEPROM(uint16_t address, uint8_t data) {
  eeprom_write_byte((uint8_t*)address, data);
    199c:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
}
    19a0:	08 95       	ret

000019a2 <ADC_voidInit>:
		CLR_BIT(ADMUX, REFS1);

	#elif VOLTAGE_REF == AVCC

		/* Select Verf = AVCC */
		SET_BIT(ADMUX, REFS0);
    19a2:	e7 e2       	ldi	r30, 0x27	; 39
    19a4:	f0 e0       	ldi	r31, 0x00	; 0
    19a6:	80 81       	ld	r24, Z
    19a8:	80 64       	ori	r24, 0x40	; 64
    19aa:	80 83       	st	Z, r24
		CLR_BIT(ADMUX, REFS1);
    19ac:	80 81       	ld	r24, Z
    19ae:	8f 77       	andi	r24, 0x7F	; 127
    19b0:	80 83       	st	Z, r24
		CLR_BIT(ADMUX, ADLAR);

	#elif ADJUST_RESULT == LEFT_ADJUST

		/* select left adjust result */
		SET_BIT(ADMUX, ADLAR);
    19b2:	80 81       	ld	r24, Z
    19b4:	80 62       	ori	r24, 0x20	; 32
    19b6:	80 83       	st	Z, r24
		CLR_BIT(ADCSRA, ADPS2);

	#elif PRESCALER == DIV_FACTOR_8

		/* Prescaler Select DIV 8 */
		SET_BIT(ADCSRA, ADPS0);
    19b8:	a6 e2       	ldi	r26, 0x26	; 38
    19ba:	b0 e0       	ldi	r27, 0x00	; 0
    19bc:	8c 91       	ld	r24, X
    19be:	81 60       	ori	r24, 0x01	; 1
    19c0:	8c 93       	st	X, r24
		SET_BIT(ADCSRA, ADPS1);
    19c2:	8c 91       	ld	r24, X
    19c4:	82 60       	ori	r24, 0x02	; 2
    19c6:	8c 93       	st	X, r24
		CLR_BIT(ADCSRA, ADPS2);
    19c8:	8c 91       	ld	r24, X
    19ca:	8b 7f       	andi	r24, 0xFB	; 251
    19cc:	8c 93       	st	X, r24
		#endif

	#elif AUTO_TRIGGER == AUTO_TRIGGER_DISABLE

		/* disable of trigger & Select single conversion */
		CLR_BIT(ADCSRA, ADATE);
    19ce:	8c 91       	ld	r24, X
    19d0:	8f 7d       	andi	r24, 0xDF	; 223
    19d2:	8c 93       	st	X, r24
	#else
		#error("You Chose Wrong ADC Auto Trigger!")
	#endif

	/* ADC interrupt disable */
	CLR_BIT(ADCSRA, ADIE);
    19d4:	8c 91       	ld	r24, X
    19d6:	87 7f       	andi	r24, 0xF7	; 247
    19d8:	8c 93       	st	X, r24
	//timer1 OVERFLOW
	SET_BIT(SFIOR,ADTS2);
    19da:	e0 e5       	ldi	r30, 0x50	; 80
    19dc:	f0 e0       	ldi	r31, 0x00	; 0
    19de:	80 81       	ld	r24, Z
    19e0:	80 68       	ori	r24, 0x80	; 128
    19e2:	80 83       	st	Z, r24
	SET_BIT(SFIOR,ADTS1);
    19e4:	80 81       	ld	r24, Z
    19e6:	80 64       	ori	r24, 0x40	; 64
    19e8:	80 83       	st	Z, r24
	CLR_BIT(SFIOR,ADTS0);
    19ea:	80 81       	ld	r24, Z
    19ec:	8f 7d       	andi	r24, 0xDF	; 223
    19ee:	80 83       	st	Z, r24

	/* Enable ADC */
	SET_BIT(ADCSRA, ADEN);
    19f0:	8c 91       	ld	r24, X
    19f2:	80 68       	ori	r24, 0x80	; 128
    19f4:	8c 93       	st	X, r24

}
    19f6:	08 95       	ret

000019f8 <ADC_u16ReadValue>:
	/* channel number must be from A0 --> A7 */
	Copy_u8ChannelNumber &= 0x07;

	/* clear first 5 bits in the ADMUX (channel number MUX4:0 bits)
	   before set the required channel */
	ADMUX &= 0xE0;
    19f8:	e7 e2       	ldi	r30, 0x27	; 39
    19fa:	f0 e0       	ldi	r31, 0x00	; 0
    19fc:	90 81       	ld	r25, Z
    19fe:	90 7e       	andi	r25, 0xE0	; 224
    1a00:	90 83       	st	Z, r25

	/* choose the correct channel by setting the channel number in MUX4:0 bits */
	ADMUX |= Copy_u8ChannelNumber;
    1a02:	90 81       	ld	r25, Z
    1a04:	87 70       	andi	r24, 0x07	; 7
    1a06:	89 2b       	or	r24, r25
    1a08:	80 83       	st	Z, r24

	/* Start conversion */
	SET_BIT(ADCSRA, ADSC);
    1a0a:	e6 e2       	ldi	r30, 0x26	; 38
    1a0c:	f0 e0       	ldi	r31, 0x00	; 0
    1a0e:	80 81       	ld	r24, Z
    1a10:	80 64       	ori	r24, 0x40	; 64
    1a12:	80 83       	st	Z, r24

	/* Wait until end conversion */
	while(0 == GET_BIT(ADCSRA, ADIF));
    1a14:	80 81       	ld	r24, Z
    1a16:	84 ff       	sbrs	r24, 4
    1a18:	fd cf       	rjmp	.-6      	; 0x1a14 <ADC_u16ReadValue+0x1c>

	/* Clear ADC interrupt flag */
	SET_BIT(ADCSRA, ADIF);
    1a1a:	e6 e2       	ldi	r30, 0x26	; 38
    1a1c:	f0 e0       	ldi	r31, 0x00	; 0
    1a1e:	80 81       	ld	r24, Z
    1a20:	80 61       	ori	r24, 0x10	; 16
    1a22:	80 83       	st	Z, r24
	  return ADC;

	#elif ADJUST_RESULT == LEFT_ADJUST

		/* select left adjust result */
		return ADCH;
    1a24:	25 b1       	in	r18, 0x05	; 5
    1a26:	30 e0       	ldi	r19, 0x00	; 0
    1a28:	40 e0       	ldi	r20, 0x00	; 0
    1a2a:	50 e0       	ldi	r21, 0x00	; 0
		#error("You Chose Wrong ADC Adjust Result!")
	#endif
	/* return data */


}
    1a2c:	62 2f       	mov	r22, r18
    1a2e:	73 2f       	mov	r23, r19
    1a30:	84 2f       	mov	r24, r20
    1a32:	95 2f       	mov	r25, r21
    1a34:	08 95       	ret

00001a36 <ADC_u8StartConversion>:

uint_16 ADC_u8StartConversion(uint_8 Copy_u8ChannelNumber)
{
	ADMUX &= ADC_CHANNEL_MASK;
    1a36:	e7 e2       	ldi	r30, 0x27	; 39
    1a38:	f0 e0       	ldi	r31, 0x00	; 0
    1a3a:	90 81       	ld	r25, Z
    1a3c:	90 7e       	andi	r25, 0xE0	; 224
    1a3e:	90 83       	st	Z, r25
	ADMUX |= Copy_u8ChannelNumber;
    1a40:	90 81       	ld	r25, Z
    1a42:	89 2b       	or	r24, r25
    1a44:	80 83       	st	Z, r24

	/*Start Conversion*/
	SET_BIT(ADCSRA, ADSC);
    1a46:	e6 e2       	ldi	r30, 0x26	; 38
    1a48:	f0 e0       	ldi	r31, 0x00	; 0
    1a4a:	80 81       	ld	r24, Z
    1a4c:	80 64       	ori	r24, 0x40	; 64
    1a4e:	80 83       	st	Z, r24

	/* Wait for Conversion Complete falg */
	while (GET_BIT(ADCSRA, ADIF) == 0 );
    1a50:	80 81       	ld	r24, Z
    1a52:	84 ff       	sbrs	r24, 4
    1a54:	fd cf       	rjmp	.-6      	; 0x1a50 <ADC_u8StartConversion+0x1a>


	return ADC;
    1a56:	24 b1       	in	r18, 0x04	; 4
    1a58:	35 b1       	in	r19, 0x05	; 5
}
    1a5a:	82 2f       	mov	r24, r18
    1a5c:	93 2f       	mov	r25, r19
    1a5e:	08 95       	ret

00001a60 <ADC_voidInterruptEnable2>:
******************************************************************************/

void ADC_voidInterruptEnable2(void){

	/* ADC interrupt Enable */
	SET_BIT(ADCSRA, ADIE);
    1a60:	e6 e2       	ldi	r30, 0x26	; 38
    1a62:	f0 e0       	ldi	r31, 0x00	; 0
    1a64:	80 81       	ld	r24, Z
    1a66:	88 60       	ori	r24, 0x08	; 8
    1a68:	80 83       	st	Z, r24
}
    1a6a:	08 95       	ret

00001a6c <ADC_voidInterruptDisable2>:
******************************************************************************/

void ADC_voidInterruptDisable2(void){

	/* ADC interrupt Disable */
	CLR_BIT(ADCSRA, ADIE);
    1a6c:	e6 e2       	ldi	r30, 0x26	; 38
    1a6e:	f0 e0       	ldi	r31, 0x00	; 0
    1a70:	80 81       	ld	r24, Z
    1a72:	87 7f       	andi	r24, 0xF7	; 247
    1a74:	80 83       	st	Z, r24
}
    1a76:	08 95       	ret

00001a78 <ADC_voidSetCallBack>:
*		          [ Layer Architecture Problem Solved ].                      *
******************************************************************************/

void ADC_voidSetCallBack(void(*Local_ptr)(void)){

	ADC_CallBack = Local_ptr;
    1a78:	90 93 e9 07 	sts	0x07E9, r25
    1a7c:	80 93 e8 07 	sts	0x07E8, r24

}
    1a80:	08 95       	ret

00001a82 <EXTI_init>:

void EXTI_init(void)
{
#if (INT0_ENABLE == ENABLE)
	/* SET INTERRUPT 0 TO FALLING EDGE */
	SET_BIT(MCUCR,ISC01);
    1a82:	e5 e5       	ldi	r30, 0x55	; 85
    1a84:	f0 e0       	ldi	r31, 0x00	; 0
    1a86:	80 81       	ld	r24, Z
    1a88:	82 60       	ori	r24, 0x02	; 2
    1a8a:	80 83       	st	Z, r24
	CLR_BIT(MCUCR,ISC00);
    1a8c:	80 81       	ld	r24, Z
    1a8e:	8e 7f       	andi	r24, 0xFE	; 254
    1a90:	80 83       	st	Z, r24
	/* Enable INT0 */
	SET_BIT(GICR,INT0); //PIE
    1a92:	eb e5       	ldi	r30, 0x5B	; 91
    1a94:	f0 e0       	ldi	r31, 0x00	; 0
    1a96:	80 81       	ld	r24, Z
    1a98:	80 64       	ori	r24, 0x40	; 64
    1a9a:	80 83       	st	Z, r24
	SET_BIT(SREG, 7);  //GIE
    1a9c:	ef e5       	ldi	r30, 0x5F	; 95
    1a9e:	f0 e0       	ldi	r31, 0x00	; 0
    1aa0:	80 81       	ld	r24, Z
    1aa2:	80 68       	ori	r24, 0x80	; 128
    1aa4:	80 83       	st	Z, r24
	/* SET INTERRUPT 2 TO FALLING EDGE */
	SET_BIT(MCUCR,ISC2);
	/* Enable INT2 */
	SET_BIT(GICR,INT2);
#endif
}
    1aa6:	08 95       	ret

00001aa8 <EXTI_SetCallBack>:

void EXTI_SetCallBack(void (*ptr_to_fun)(void),uint_8 A_IntID){
	if (A_IntID == 0)
    1aa8:	66 23       	and	r22, r22
    1aaa:	29 f4       	brne	.+10     	; 0x1ab6 <EXTI_SetCallBack+0xe>
	{
		Ptr_To_Int0 = ptr_to_fun;
    1aac:	90 93 eb 07 	sts	0x07EB, r25
    1ab0:	80 93 ea 07 	sts	0x07EA, r24
    1ab4:	08 95       	ret
	}
	else if (A_IntID == 1)
    1ab6:	61 30       	cpi	r22, 0x01	; 1
    1ab8:	29 f4       	brne	.+10     	; 0x1ac4 <EXTI_SetCallBack+0x1c>
	{
		Ptr_To_Int1 = ptr_to_fun;
    1aba:	90 93 ed 07 	sts	0x07ED, r25
    1abe:	80 93 ec 07 	sts	0x07EC, r24
    1ac2:	08 95       	ret
	}
	else if (A_IntID == 2)
    1ac4:	62 30       	cpi	r22, 0x02	; 2
    1ac6:	21 f4       	brne	.+8      	; 0x1ad0 <EXTI_SetCallBack+0x28>
	{
		Ptr_To_Int2 = ptr_to_fun;
    1ac8:	90 93 ef 07 	sts	0x07EF, r25
    1acc:	80 93 ee 07 	sts	0x07EE, r24
    1ad0:	08 95       	ret

00001ad2 <__vector_1>:
	}
}

// INT 0
void __vector_1 (void){
    1ad2:	1f 92       	push	r1
    1ad4:	0f 92       	push	r0
    1ad6:	0f b6       	in	r0, 0x3f	; 63
    1ad8:	0f 92       	push	r0
    1ada:	11 24       	eor	r1, r1
    1adc:	2f 93       	push	r18
    1ade:	3f 93       	push	r19
    1ae0:	4f 93       	push	r20
    1ae2:	5f 93       	push	r21
    1ae4:	6f 93       	push	r22
    1ae6:	7f 93       	push	r23
    1ae8:	8f 93       	push	r24
    1aea:	9f 93       	push	r25
    1aec:	af 93       	push	r26
    1aee:	bf 93       	push	r27
    1af0:	ef 93       	push	r30
    1af2:	ff 93       	push	r31
	if (Ptr_To_Int0 != NULL){
    1af4:	e0 91 ea 07 	lds	r30, 0x07EA
    1af8:	f0 91 eb 07 	lds	r31, 0x07EB
    1afc:	30 97       	sbiw	r30, 0x00	; 0
    1afe:	09 f0       	breq	.+2      	; 0x1b02 <__vector_1+0x30>
		Ptr_To_Int0();
    1b00:	09 95       	icall
	}
}
    1b02:	ff 91       	pop	r31
    1b04:	ef 91       	pop	r30
    1b06:	bf 91       	pop	r27
    1b08:	af 91       	pop	r26
    1b0a:	9f 91       	pop	r25
    1b0c:	8f 91       	pop	r24
    1b0e:	7f 91       	pop	r23
    1b10:	6f 91       	pop	r22
    1b12:	5f 91       	pop	r21
    1b14:	4f 91       	pop	r20
    1b16:	3f 91       	pop	r19
    1b18:	2f 91       	pop	r18
    1b1a:	0f 90       	pop	r0
    1b1c:	0f be       	out	0x3f, r0	; 63
    1b1e:	0f 90       	pop	r0
    1b20:	1f 90       	pop	r1
    1b22:	18 95       	reti

00001b24 <__vector_2>:

// INT 1
void __vector_2 (void){
    1b24:	1f 92       	push	r1
    1b26:	0f 92       	push	r0
    1b28:	0f b6       	in	r0, 0x3f	; 63
    1b2a:	0f 92       	push	r0
    1b2c:	11 24       	eor	r1, r1
    1b2e:	2f 93       	push	r18
    1b30:	3f 93       	push	r19
    1b32:	4f 93       	push	r20
    1b34:	5f 93       	push	r21
    1b36:	6f 93       	push	r22
    1b38:	7f 93       	push	r23
    1b3a:	8f 93       	push	r24
    1b3c:	9f 93       	push	r25
    1b3e:	af 93       	push	r26
    1b40:	bf 93       	push	r27
    1b42:	ef 93       	push	r30
    1b44:	ff 93       	push	r31
	if (Ptr_To_Int1 != NULL){
    1b46:	e0 91 ec 07 	lds	r30, 0x07EC
    1b4a:	f0 91 ed 07 	lds	r31, 0x07ED
    1b4e:	30 97       	sbiw	r30, 0x00	; 0
    1b50:	09 f0       	breq	.+2      	; 0x1b54 <__vector_2+0x30>
		Ptr_To_Int1();
    1b52:	09 95       	icall
	}
}
    1b54:	ff 91       	pop	r31
    1b56:	ef 91       	pop	r30
    1b58:	bf 91       	pop	r27
    1b5a:	af 91       	pop	r26
    1b5c:	9f 91       	pop	r25
    1b5e:	8f 91       	pop	r24
    1b60:	7f 91       	pop	r23
    1b62:	6f 91       	pop	r22
    1b64:	5f 91       	pop	r21
    1b66:	4f 91       	pop	r20
    1b68:	3f 91       	pop	r19
    1b6a:	2f 91       	pop	r18
    1b6c:	0f 90       	pop	r0
    1b6e:	0f be       	out	0x3f, r0	; 63
    1b70:	0f 90       	pop	r0
    1b72:	1f 90       	pop	r1
    1b74:	18 95       	reti

00001b76 <__vector_3>:

// INT 2
void __vector_3 (void){
    1b76:	1f 92       	push	r1
    1b78:	0f 92       	push	r0
    1b7a:	0f b6       	in	r0, 0x3f	; 63
    1b7c:	0f 92       	push	r0
    1b7e:	11 24       	eor	r1, r1
    1b80:	2f 93       	push	r18
    1b82:	3f 93       	push	r19
    1b84:	4f 93       	push	r20
    1b86:	5f 93       	push	r21
    1b88:	6f 93       	push	r22
    1b8a:	7f 93       	push	r23
    1b8c:	8f 93       	push	r24
    1b8e:	9f 93       	push	r25
    1b90:	af 93       	push	r26
    1b92:	bf 93       	push	r27
    1b94:	ef 93       	push	r30
    1b96:	ff 93       	push	r31
	if (Ptr_To_Int2 != NULL){
    1b98:	e0 91 ee 07 	lds	r30, 0x07EE
    1b9c:	f0 91 ef 07 	lds	r31, 0x07EF
    1ba0:	30 97       	sbiw	r30, 0x00	; 0
    1ba2:	09 f0       	breq	.+2      	; 0x1ba6 <__vector_3+0x30>
		Ptr_To_Int2();
    1ba4:	09 95       	icall
	}
}
    1ba6:	ff 91       	pop	r31
    1ba8:	ef 91       	pop	r30
    1baa:	bf 91       	pop	r27
    1bac:	af 91       	pop	r26
    1bae:	9f 91       	pop	r25
    1bb0:	8f 91       	pop	r24
    1bb2:	7f 91       	pop	r23
    1bb4:	6f 91       	pop	r22
    1bb6:	5f 91       	pop	r21
    1bb8:	4f 91       	pop	r20
    1bba:	3f 91       	pop	r19
    1bbc:	2f 91       	pop	r18
    1bbe:	0f 90       	pop	r0
    1bc0:	0f be       	out	0x3f, r0	; 63
    1bc2:	0f 90       	pop	r0
    1bc4:	1f 90       	pop	r1
    1bc6:	18 95       	reti

00001bc8 <DIO_voidSetPinDirection>:
/*-------------- Global Variable Definitions  ---------------*/

/*-------------- APIs Definitions ---------------*/
void DIO_voidSetPinDirection(Port_t copy_u8PortNum, Pin_Position copy_u8PinNum, Pin_Direction copy_u8Mode){

    if(Input == copy_u8Mode){
    1bc8:	44 23       	and	r20, r20
    1bca:	09 f0       	breq	.+2      	; 0x1bce <DIO_voidSetPinDirection+0x6>
    1bcc:	42 c0       	rjmp	.+132    	; 0x1c52 <DIO_voidSetPinDirection+0x8a>
        switch(copy_u8PortNum){
    1bce:	81 30       	cpi	r24, 0x01	; 1
    1bd0:	b1 f0       	breq	.+44     	; 0x1bfe <DIO_voidSetPinDirection+0x36>
    1bd2:	81 30       	cpi	r24, 0x01	; 1
    1bd4:	30 f0       	brcs	.+12     	; 0x1be2 <DIO_voidSetPinDirection+0x1a>
    1bd6:	82 30       	cpi	r24, 0x02	; 2
    1bd8:	01 f1       	breq	.+64     	; 0x1c1a <DIO_voidSetPinDirection+0x52>
    1bda:	83 30       	cpi	r24, 0x03	; 3
    1bdc:	09 f0       	breq	.+2      	; 0x1be0 <DIO_voidSetPinDirection+0x18>
    1bde:	78 c0       	rjmp	.+240    	; 0x1cd0 <DIO_voidSetPinDirection+0x108>
    1be0:	2a c0       	rjmp	.+84     	; 0x1c36 <DIO_voidSetPinDirection+0x6e>
            case DIO_u8PORTA : CLR_BIT(DDRA, copy_u8PinNum); break;
    1be2:	ea e3       	ldi	r30, 0x3A	; 58
    1be4:	f0 e0       	ldi	r31, 0x00	; 0
    1be6:	20 81       	ld	r18, Z
    1be8:	81 e0       	ldi	r24, 0x01	; 1
    1bea:	90 e0       	ldi	r25, 0x00	; 0
    1bec:	02 c0       	rjmp	.+4      	; 0x1bf2 <DIO_voidSetPinDirection+0x2a>
    1bee:	88 0f       	add	r24, r24
    1bf0:	99 1f       	adc	r25, r25
    1bf2:	6a 95       	dec	r22
    1bf4:	e2 f7       	brpl	.-8      	; 0x1bee <DIO_voidSetPinDirection+0x26>
    1bf6:	80 95       	com	r24
    1bf8:	82 23       	and	r24, r18
    1bfa:	80 83       	st	Z, r24
    1bfc:	08 95       	ret
            case DIO_u8PORTB : CLR_BIT(DDRB, copy_u8PinNum); break;
    1bfe:	e7 e3       	ldi	r30, 0x37	; 55
    1c00:	f0 e0       	ldi	r31, 0x00	; 0
    1c02:	20 81       	ld	r18, Z
    1c04:	81 e0       	ldi	r24, 0x01	; 1
    1c06:	90 e0       	ldi	r25, 0x00	; 0
    1c08:	02 c0       	rjmp	.+4      	; 0x1c0e <DIO_voidSetPinDirection+0x46>
    1c0a:	88 0f       	add	r24, r24
    1c0c:	99 1f       	adc	r25, r25
    1c0e:	6a 95       	dec	r22
    1c10:	e2 f7       	brpl	.-8      	; 0x1c0a <DIO_voidSetPinDirection+0x42>
    1c12:	80 95       	com	r24
    1c14:	82 23       	and	r24, r18
    1c16:	80 83       	st	Z, r24
    1c18:	08 95       	ret
            case DIO_u8PORTC : CLR_BIT(DDRC, copy_u8PinNum); break;
    1c1a:	e4 e3       	ldi	r30, 0x34	; 52
    1c1c:	f0 e0       	ldi	r31, 0x00	; 0
    1c1e:	20 81       	ld	r18, Z
    1c20:	81 e0       	ldi	r24, 0x01	; 1
    1c22:	90 e0       	ldi	r25, 0x00	; 0
    1c24:	02 c0       	rjmp	.+4      	; 0x1c2a <DIO_voidSetPinDirection+0x62>
    1c26:	88 0f       	add	r24, r24
    1c28:	99 1f       	adc	r25, r25
    1c2a:	6a 95       	dec	r22
    1c2c:	e2 f7       	brpl	.-8      	; 0x1c26 <DIO_voidSetPinDirection+0x5e>
    1c2e:	80 95       	com	r24
    1c30:	82 23       	and	r24, r18
    1c32:	80 83       	st	Z, r24
    1c34:	08 95       	ret
            case DIO_u8PORTD : CLR_BIT(DDRD, copy_u8PinNum); break;
    1c36:	e1 e3       	ldi	r30, 0x31	; 49
    1c38:	f0 e0       	ldi	r31, 0x00	; 0
    1c3a:	20 81       	ld	r18, Z
    1c3c:	81 e0       	ldi	r24, 0x01	; 1
    1c3e:	90 e0       	ldi	r25, 0x00	; 0
    1c40:	02 c0       	rjmp	.+4      	; 0x1c46 <DIO_voidSetPinDirection+0x7e>
    1c42:	88 0f       	add	r24, r24
    1c44:	99 1f       	adc	r25, r25
    1c46:	6a 95       	dec	r22
    1c48:	e2 f7       	brpl	.-8      	; 0x1c42 <DIO_voidSetPinDirection+0x7a>
    1c4a:	80 95       	com	r24
    1c4c:	82 23       	and	r24, r18
    1c4e:	80 83       	st	Z, r24
    1c50:	08 95       	ret
            default : /* Error */ break;
        }
    }
    else if(Output == copy_u8Mode){
    1c52:	41 30       	cpi	r20, 0x01	; 1
    1c54:	09 f0       	breq	.+2      	; 0x1c58 <DIO_voidSetPinDirection+0x90>
    1c56:	3c c0       	rjmp	.+120    	; 0x1cd0 <DIO_voidSetPinDirection+0x108>
         switch(copy_u8PortNum){
    1c58:	81 30       	cpi	r24, 0x01	; 1
    1c5a:	a1 f0       	breq	.+40     	; 0x1c84 <DIO_voidSetPinDirection+0xbc>
    1c5c:	81 30       	cpi	r24, 0x01	; 1
    1c5e:	28 f0       	brcs	.+10     	; 0x1c6a <DIO_voidSetPinDirection+0xa2>
    1c60:	82 30       	cpi	r24, 0x02	; 2
    1c62:	e9 f0       	breq	.+58     	; 0x1c9e <DIO_voidSetPinDirection+0xd6>
    1c64:	83 30       	cpi	r24, 0x03	; 3
    1c66:	a1 f5       	brne	.+104    	; 0x1cd0 <DIO_voidSetPinDirection+0x108>
    1c68:	27 c0       	rjmp	.+78     	; 0x1cb8 <DIO_voidSetPinDirection+0xf0>
            case DIO_u8PORTA : SET_BIT(DDRA, copy_u8PinNum); break;
    1c6a:	ea e3       	ldi	r30, 0x3A	; 58
    1c6c:	f0 e0       	ldi	r31, 0x00	; 0
    1c6e:	20 81       	ld	r18, Z
    1c70:	81 e0       	ldi	r24, 0x01	; 1
    1c72:	90 e0       	ldi	r25, 0x00	; 0
    1c74:	02 c0       	rjmp	.+4      	; 0x1c7a <DIO_voidSetPinDirection+0xb2>
    1c76:	88 0f       	add	r24, r24
    1c78:	99 1f       	adc	r25, r25
    1c7a:	6a 95       	dec	r22
    1c7c:	e2 f7       	brpl	.-8      	; 0x1c76 <DIO_voidSetPinDirection+0xae>
    1c7e:	28 2b       	or	r18, r24
    1c80:	20 83       	st	Z, r18
    1c82:	08 95       	ret
            case DIO_u8PORTB : SET_BIT(DDRB, copy_u8PinNum); break;
    1c84:	e7 e3       	ldi	r30, 0x37	; 55
    1c86:	f0 e0       	ldi	r31, 0x00	; 0
    1c88:	20 81       	ld	r18, Z
    1c8a:	81 e0       	ldi	r24, 0x01	; 1
    1c8c:	90 e0       	ldi	r25, 0x00	; 0
    1c8e:	02 c0       	rjmp	.+4      	; 0x1c94 <DIO_voidSetPinDirection+0xcc>
    1c90:	88 0f       	add	r24, r24
    1c92:	99 1f       	adc	r25, r25
    1c94:	6a 95       	dec	r22
    1c96:	e2 f7       	brpl	.-8      	; 0x1c90 <DIO_voidSetPinDirection+0xc8>
    1c98:	28 2b       	or	r18, r24
    1c9a:	20 83       	st	Z, r18
    1c9c:	08 95       	ret
            case DIO_u8PORTC : SET_BIT(DDRC, copy_u8PinNum); break;
    1c9e:	e4 e3       	ldi	r30, 0x34	; 52
    1ca0:	f0 e0       	ldi	r31, 0x00	; 0
    1ca2:	20 81       	ld	r18, Z
    1ca4:	81 e0       	ldi	r24, 0x01	; 1
    1ca6:	90 e0       	ldi	r25, 0x00	; 0
    1ca8:	02 c0       	rjmp	.+4      	; 0x1cae <DIO_voidSetPinDirection+0xe6>
    1caa:	88 0f       	add	r24, r24
    1cac:	99 1f       	adc	r25, r25
    1cae:	6a 95       	dec	r22
    1cb0:	e2 f7       	brpl	.-8      	; 0x1caa <DIO_voidSetPinDirection+0xe2>
    1cb2:	28 2b       	or	r18, r24
    1cb4:	20 83       	st	Z, r18
    1cb6:	08 95       	ret
            case DIO_u8PORTD : SET_BIT(DDRD, copy_u8PinNum); break;
    1cb8:	e1 e3       	ldi	r30, 0x31	; 49
    1cba:	f0 e0       	ldi	r31, 0x00	; 0
    1cbc:	20 81       	ld	r18, Z
    1cbe:	81 e0       	ldi	r24, 0x01	; 1
    1cc0:	90 e0       	ldi	r25, 0x00	; 0
    1cc2:	02 c0       	rjmp	.+4      	; 0x1cc8 <DIO_voidSetPinDirection+0x100>
    1cc4:	88 0f       	add	r24, r24
    1cc6:	99 1f       	adc	r25, r25
    1cc8:	6a 95       	dec	r22
    1cca:	e2 f7       	brpl	.-8      	; 0x1cc4 <DIO_voidSetPinDirection+0xfc>
    1ccc:	28 2b       	or	r18, r24
    1cce:	20 83       	st	Z, r18
    1cd0:	08 95       	ret

00001cd2 <DIO_voidSetPinValue>:
        /* Error */
    }
}
void DIO_voidSetPinValue(Port_t copy_u8PortNum, Pin_Position copy_u8PinNum, Pin_Logic copy_u8Logic){

    if(Low == copy_u8Logic){
    1cd2:	44 23       	and	r20, r20
    1cd4:	09 f0       	breq	.+2      	; 0x1cd8 <DIO_voidSetPinValue+0x6>
    1cd6:	42 c0       	rjmp	.+132    	; 0x1d5c <DIO_voidSetPinValue+0x8a>
        switch(copy_u8PortNum){
    1cd8:	81 30       	cpi	r24, 0x01	; 1
    1cda:	b1 f0       	breq	.+44     	; 0x1d08 <DIO_voidSetPinValue+0x36>
    1cdc:	81 30       	cpi	r24, 0x01	; 1
    1cde:	30 f0       	brcs	.+12     	; 0x1cec <DIO_voidSetPinValue+0x1a>
    1ce0:	82 30       	cpi	r24, 0x02	; 2
    1ce2:	01 f1       	breq	.+64     	; 0x1d24 <DIO_voidSetPinValue+0x52>
    1ce4:	83 30       	cpi	r24, 0x03	; 3
    1ce6:	09 f0       	breq	.+2      	; 0x1cea <DIO_voidSetPinValue+0x18>
    1ce8:	78 c0       	rjmp	.+240    	; 0x1dda <DIO_voidSetPinValue+0x108>
    1cea:	2a c0       	rjmp	.+84     	; 0x1d40 <DIO_voidSetPinValue+0x6e>
            case DIO_u8PORTA : CLR_BIT(PORTA, copy_u8PinNum); break;
    1cec:	eb e3       	ldi	r30, 0x3B	; 59
    1cee:	f0 e0       	ldi	r31, 0x00	; 0
    1cf0:	20 81       	ld	r18, Z
    1cf2:	81 e0       	ldi	r24, 0x01	; 1
    1cf4:	90 e0       	ldi	r25, 0x00	; 0
    1cf6:	02 c0       	rjmp	.+4      	; 0x1cfc <DIO_voidSetPinValue+0x2a>
    1cf8:	88 0f       	add	r24, r24
    1cfa:	99 1f       	adc	r25, r25
    1cfc:	6a 95       	dec	r22
    1cfe:	e2 f7       	brpl	.-8      	; 0x1cf8 <DIO_voidSetPinValue+0x26>
    1d00:	80 95       	com	r24
    1d02:	82 23       	and	r24, r18
    1d04:	80 83       	st	Z, r24
    1d06:	08 95       	ret
            case DIO_u8PORTB : CLR_BIT(PORTB, copy_u8PinNum); break;
    1d08:	e8 e3       	ldi	r30, 0x38	; 56
    1d0a:	f0 e0       	ldi	r31, 0x00	; 0
    1d0c:	20 81       	ld	r18, Z
    1d0e:	81 e0       	ldi	r24, 0x01	; 1
    1d10:	90 e0       	ldi	r25, 0x00	; 0
    1d12:	02 c0       	rjmp	.+4      	; 0x1d18 <DIO_voidSetPinValue+0x46>
    1d14:	88 0f       	add	r24, r24
    1d16:	99 1f       	adc	r25, r25
    1d18:	6a 95       	dec	r22
    1d1a:	e2 f7       	brpl	.-8      	; 0x1d14 <DIO_voidSetPinValue+0x42>
    1d1c:	80 95       	com	r24
    1d1e:	82 23       	and	r24, r18
    1d20:	80 83       	st	Z, r24
    1d22:	08 95       	ret
            case DIO_u8PORTC : CLR_BIT(PORTC, copy_u8PinNum); break;
    1d24:	e5 e3       	ldi	r30, 0x35	; 53
    1d26:	f0 e0       	ldi	r31, 0x00	; 0
    1d28:	20 81       	ld	r18, Z
    1d2a:	81 e0       	ldi	r24, 0x01	; 1
    1d2c:	90 e0       	ldi	r25, 0x00	; 0
    1d2e:	02 c0       	rjmp	.+4      	; 0x1d34 <DIO_voidSetPinValue+0x62>
    1d30:	88 0f       	add	r24, r24
    1d32:	99 1f       	adc	r25, r25
    1d34:	6a 95       	dec	r22
    1d36:	e2 f7       	brpl	.-8      	; 0x1d30 <DIO_voidSetPinValue+0x5e>
    1d38:	80 95       	com	r24
    1d3a:	82 23       	and	r24, r18
    1d3c:	80 83       	st	Z, r24
    1d3e:	08 95       	ret
            case DIO_u8PORTD : CLR_BIT(PORTD, copy_u8PinNum); break;
    1d40:	e2 e3       	ldi	r30, 0x32	; 50
    1d42:	f0 e0       	ldi	r31, 0x00	; 0
    1d44:	20 81       	ld	r18, Z
    1d46:	81 e0       	ldi	r24, 0x01	; 1
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	02 c0       	rjmp	.+4      	; 0x1d50 <DIO_voidSetPinValue+0x7e>
    1d4c:	88 0f       	add	r24, r24
    1d4e:	99 1f       	adc	r25, r25
    1d50:	6a 95       	dec	r22
    1d52:	e2 f7       	brpl	.-8      	; 0x1d4c <DIO_voidSetPinValue+0x7a>
    1d54:	80 95       	com	r24
    1d56:	82 23       	and	r24, r18
    1d58:	80 83       	st	Z, r24
    1d5a:	08 95       	ret
            default : /* Error */ break;
        }
    }
    else if(High == copy_u8Logic){
    1d5c:	41 30       	cpi	r20, 0x01	; 1
    1d5e:	09 f0       	breq	.+2      	; 0x1d62 <DIO_voidSetPinValue+0x90>
    1d60:	3c c0       	rjmp	.+120    	; 0x1dda <DIO_voidSetPinValue+0x108>
         switch(copy_u8PortNum){
    1d62:	81 30       	cpi	r24, 0x01	; 1
    1d64:	a1 f0       	breq	.+40     	; 0x1d8e <DIO_voidSetPinValue+0xbc>
    1d66:	81 30       	cpi	r24, 0x01	; 1
    1d68:	28 f0       	brcs	.+10     	; 0x1d74 <DIO_voidSetPinValue+0xa2>
    1d6a:	82 30       	cpi	r24, 0x02	; 2
    1d6c:	e9 f0       	breq	.+58     	; 0x1da8 <DIO_voidSetPinValue+0xd6>
    1d6e:	83 30       	cpi	r24, 0x03	; 3
    1d70:	a1 f5       	brne	.+104    	; 0x1dda <DIO_voidSetPinValue+0x108>
    1d72:	27 c0       	rjmp	.+78     	; 0x1dc2 <DIO_voidSetPinValue+0xf0>
            case DIO_u8PORTA : SET_BIT(PORTA, copy_u8PinNum); break;
    1d74:	eb e3       	ldi	r30, 0x3B	; 59
    1d76:	f0 e0       	ldi	r31, 0x00	; 0
    1d78:	20 81       	ld	r18, Z
    1d7a:	81 e0       	ldi	r24, 0x01	; 1
    1d7c:	90 e0       	ldi	r25, 0x00	; 0
    1d7e:	02 c0       	rjmp	.+4      	; 0x1d84 <DIO_voidSetPinValue+0xb2>
    1d80:	88 0f       	add	r24, r24
    1d82:	99 1f       	adc	r25, r25
    1d84:	6a 95       	dec	r22
    1d86:	e2 f7       	brpl	.-8      	; 0x1d80 <DIO_voidSetPinValue+0xae>
    1d88:	28 2b       	or	r18, r24
    1d8a:	20 83       	st	Z, r18
    1d8c:	08 95       	ret
            case DIO_u8PORTB : SET_BIT(PORTB, copy_u8PinNum); break;
    1d8e:	e8 e3       	ldi	r30, 0x38	; 56
    1d90:	f0 e0       	ldi	r31, 0x00	; 0
    1d92:	20 81       	ld	r18, Z
    1d94:	81 e0       	ldi	r24, 0x01	; 1
    1d96:	90 e0       	ldi	r25, 0x00	; 0
    1d98:	02 c0       	rjmp	.+4      	; 0x1d9e <DIO_voidSetPinValue+0xcc>
    1d9a:	88 0f       	add	r24, r24
    1d9c:	99 1f       	adc	r25, r25
    1d9e:	6a 95       	dec	r22
    1da0:	e2 f7       	brpl	.-8      	; 0x1d9a <DIO_voidSetPinValue+0xc8>
    1da2:	28 2b       	or	r18, r24
    1da4:	20 83       	st	Z, r18
    1da6:	08 95       	ret
            case DIO_u8PORTC : SET_BIT(PORTC, copy_u8PinNum); break;
    1da8:	e5 e3       	ldi	r30, 0x35	; 53
    1daa:	f0 e0       	ldi	r31, 0x00	; 0
    1dac:	20 81       	ld	r18, Z
    1dae:	81 e0       	ldi	r24, 0x01	; 1
    1db0:	90 e0       	ldi	r25, 0x00	; 0
    1db2:	02 c0       	rjmp	.+4      	; 0x1db8 <DIO_voidSetPinValue+0xe6>
    1db4:	88 0f       	add	r24, r24
    1db6:	99 1f       	adc	r25, r25
    1db8:	6a 95       	dec	r22
    1dba:	e2 f7       	brpl	.-8      	; 0x1db4 <DIO_voidSetPinValue+0xe2>
    1dbc:	28 2b       	or	r18, r24
    1dbe:	20 83       	st	Z, r18
    1dc0:	08 95       	ret
            case DIO_u8PORTD : SET_BIT(PORTD, copy_u8PinNum); break;
    1dc2:	e2 e3       	ldi	r30, 0x32	; 50
    1dc4:	f0 e0       	ldi	r31, 0x00	; 0
    1dc6:	20 81       	ld	r18, Z
    1dc8:	81 e0       	ldi	r24, 0x01	; 1
    1dca:	90 e0       	ldi	r25, 0x00	; 0
    1dcc:	02 c0       	rjmp	.+4      	; 0x1dd2 <DIO_voidSetPinValue+0x100>
    1dce:	88 0f       	add	r24, r24
    1dd0:	99 1f       	adc	r25, r25
    1dd2:	6a 95       	dec	r22
    1dd4:	e2 f7       	brpl	.-8      	; 0x1dce <DIO_voidSetPinValue+0xfc>
    1dd6:	28 2b       	or	r18, r24
    1dd8:	20 83       	st	Z, r18
    1dda:	08 95       	ret

00001ddc <DIO_u8GetPinValue>:
        /* Error */
    }
}
Pin_Logic DIO_u8GetPinValue(Port_t copy_u8PortNum, Pin_Position copy_u8PinNum){
    Pin_Logic Local_u8Result = 0;
    switch(copy_u8PortNum){
    1ddc:	81 30       	cpi	r24, 0x01	; 1
    1dde:	89 f0       	breq	.+34     	; 0x1e02 <DIO_u8GetPinValue+0x26>
    1de0:	81 30       	cpi	r24, 0x01	; 1
    1de2:	30 f0       	brcs	.+12     	; 0x1df0 <DIO_u8GetPinValue+0x14>
    1de4:	82 30       	cpi	r24, 0x02	; 2
    1de6:	b1 f0       	breq	.+44     	; 0x1e14 <DIO_u8GetPinValue+0x38>
    1de8:	83 30       	cpi	r24, 0x03	; 3
    1dea:	e9 f0       	breq	.+58     	; 0x1e26 <DIO_u8GetPinValue+0x4a>
    1dec:	80 e0       	ldi	r24, 0x00	; 0
    1dee:	08 95       	ret
        case DIO_u8PORTA : Local_u8Result = GET_BIT(PINA, copy_u8PinNum); break;
    1df0:	89 b3       	in	r24, 0x19	; 25
    1df2:	90 e0       	ldi	r25, 0x00	; 0
    1df4:	02 c0       	rjmp	.+4      	; 0x1dfa <DIO_u8GetPinValue+0x1e>
    1df6:	95 95       	asr	r25
    1df8:	87 95       	ror	r24
    1dfa:	6a 95       	dec	r22
    1dfc:	e2 f7       	brpl	.-8      	; 0x1df6 <DIO_u8GetPinValue+0x1a>
    1dfe:	81 70       	andi	r24, 0x01	; 1
    1e00:	08 95       	ret
        case DIO_u8PORTB : Local_u8Result = GET_BIT(PINB, copy_u8PinNum); break;
    1e02:	86 b3       	in	r24, 0x16	; 22
    1e04:	90 e0       	ldi	r25, 0x00	; 0
    1e06:	02 c0       	rjmp	.+4      	; 0x1e0c <DIO_u8GetPinValue+0x30>
    1e08:	95 95       	asr	r25
    1e0a:	87 95       	ror	r24
    1e0c:	6a 95       	dec	r22
    1e0e:	e2 f7       	brpl	.-8      	; 0x1e08 <DIO_u8GetPinValue+0x2c>
    1e10:	81 70       	andi	r24, 0x01	; 1
    1e12:	08 95       	ret
        case DIO_u8PORTC : Local_u8Result = GET_BIT(PINC, copy_u8PinNum); break;
    1e14:	83 b3       	in	r24, 0x13	; 19
    1e16:	90 e0       	ldi	r25, 0x00	; 0
    1e18:	02 c0       	rjmp	.+4      	; 0x1e1e <DIO_u8GetPinValue+0x42>
    1e1a:	95 95       	asr	r25
    1e1c:	87 95       	ror	r24
    1e1e:	6a 95       	dec	r22
    1e20:	e2 f7       	brpl	.-8      	; 0x1e1a <DIO_u8GetPinValue+0x3e>
    1e22:	81 70       	andi	r24, 0x01	; 1
    1e24:	08 95       	ret
        case DIO_u8PORTD : Local_u8Result = GET_BIT(PIND, copy_u8PinNum); break;
    1e26:	80 b3       	in	r24, 0x10	; 16
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	02 c0       	rjmp	.+4      	; 0x1e30 <DIO_u8GetPinValue+0x54>
    1e2c:	95 95       	asr	r25
    1e2e:	87 95       	ror	r24
    1e30:	6a 95       	dec	r22
    1e32:	e2 f7       	brpl	.-8      	; 0x1e2c <DIO_u8GetPinValue+0x50>
    1e34:	81 70       	andi	r24, 0x01	; 1
        default : /* Error */ break;
    }

    return Local_u8Result;
}
    1e36:	08 95       	ret

00001e38 <DIO_u8GetPinDirection>:
Pin_Logic DIO_u8GetPinDirection(Port_t copy_u8PortNum, Pin_Position copy_u8PinNum){
    Pin_Logic Local_u8Result = 0;
    switch(copy_u8PortNum){
    1e38:	81 30       	cpi	r24, 0x01	; 1
    1e3a:	89 f0       	breq	.+34     	; 0x1e5e <DIO_u8GetPinDirection+0x26>
    1e3c:	81 30       	cpi	r24, 0x01	; 1
    1e3e:	30 f0       	brcs	.+12     	; 0x1e4c <DIO_u8GetPinDirection+0x14>
    1e40:	82 30       	cpi	r24, 0x02	; 2
    1e42:	b1 f0       	breq	.+44     	; 0x1e70 <DIO_u8GetPinDirection+0x38>
    1e44:	83 30       	cpi	r24, 0x03	; 3
    1e46:	e9 f0       	breq	.+58     	; 0x1e82 <DIO_u8GetPinDirection+0x4a>
    1e48:	80 e0       	ldi	r24, 0x00	; 0
    1e4a:	08 95       	ret
        case DIO_u8PORTA : Local_u8Result = GET_BIT(DDRA, copy_u8PinNum); break;
    1e4c:	8a b3       	in	r24, 0x1a	; 26
    1e4e:	90 e0       	ldi	r25, 0x00	; 0
    1e50:	02 c0       	rjmp	.+4      	; 0x1e56 <DIO_u8GetPinDirection+0x1e>
    1e52:	95 95       	asr	r25
    1e54:	87 95       	ror	r24
    1e56:	6a 95       	dec	r22
    1e58:	e2 f7       	brpl	.-8      	; 0x1e52 <DIO_u8GetPinDirection+0x1a>
    1e5a:	81 70       	andi	r24, 0x01	; 1
    1e5c:	08 95       	ret
        case DIO_u8PORTB : Local_u8Result = GET_BIT(DDRB, copy_u8PinNum); break;
    1e5e:	87 b3       	in	r24, 0x17	; 23
    1e60:	90 e0       	ldi	r25, 0x00	; 0
    1e62:	02 c0       	rjmp	.+4      	; 0x1e68 <DIO_u8GetPinDirection+0x30>
    1e64:	95 95       	asr	r25
    1e66:	87 95       	ror	r24
    1e68:	6a 95       	dec	r22
    1e6a:	e2 f7       	brpl	.-8      	; 0x1e64 <DIO_u8GetPinDirection+0x2c>
    1e6c:	81 70       	andi	r24, 0x01	; 1
    1e6e:	08 95       	ret
        case DIO_u8PORTC : Local_u8Result = GET_BIT(DDRC, copy_u8PinNum); break;
    1e70:	84 b3       	in	r24, 0x14	; 20
    1e72:	90 e0       	ldi	r25, 0x00	; 0
    1e74:	02 c0       	rjmp	.+4      	; 0x1e7a <DIO_u8GetPinDirection+0x42>
    1e76:	95 95       	asr	r25
    1e78:	87 95       	ror	r24
    1e7a:	6a 95       	dec	r22
    1e7c:	e2 f7       	brpl	.-8      	; 0x1e76 <DIO_u8GetPinDirection+0x3e>
    1e7e:	81 70       	andi	r24, 0x01	; 1
    1e80:	08 95       	ret
        case DIO_u8PORTD : Local_u8Result = GET_BIT(DDRD, copy_u8PinNum); break;
    1e82:	81 b3       	in	r24, 0x11	; 17
    1e84:	90 e0       	ldi	r25, 0x00	; 0
    1e86:	02 c0       	rjmp	.+4      	; 0x1e8c <DIO_u8GetPinDirection+0x54>
    1e88:	95 95       	asr	r25
    1e8a:	87 95       	ror	r24
    1e8c:	6a 95       	dec	r22
    1e8e:	e2 f7       	brpl	.-8      	; 0x1e88 <DIO_u8GetPinDirection+0x50>
    1e90:	81 70       	andi	r24, 0x01	; 1
        default : /* Error */ break;
    }

    return Local_u8Result;
}
    1e92:	08 95       	ret

00001e94 <DIO_voidTogglePin>:
void DIO_voidTogglePin(uint_8 copy_u8PortNum, uint_8 copy_u8PinNum){

    switch(copy_u8PortNum){
    1e94:	81 30       	cpi	r24, 0x01	; 1
    1e96:	a1 f0       	breq	.+40     	; 0x1ec0 <DIO_voidTogglePin+0x2c>
    1e98:	81 30       	cpi	r24, 0x01	; 1
    1e9a:	28 f0       	brcs	.+10     	; 0x1ea6 <DIO_voidTogglePin+0x12>
    1e9c:	82 30       	cpi	r24, 0x02	; 2
    1e9e:	e9 f0       	breq	.+58     	; 0x1eda <DIO_voidTogglePin+0x46>
    1ea0:	83 30       	cpi	r24, 0x03	; 3
    1ea2:	a1 f5       	brne	.+104    	; 0x1f0c <DIO_voidTogglePin+0x78>
    1ea4:	27 c0       	rjmp	.+78     	; 0x1ef4 <DIO_voidTogglePin+0x60>
        case DIO_u8PORTA : TOG_BIT(PORTA, copy_u8PinNum); break;
    1ea6:	eb e3       	ldi	r30, 0x3B	; 59
    1ea8:	f0 e0       	ldi	r31, 0x00	; 0
    1eaa:	20 81       	ld	r18, Z
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	90 e0       	ldi	r25, 0x00	; 0
    1eb0:	02 c0       	rjmp	.+4      	; 0x1eb6 <DIO_voidTogglePin+0x22>
    1eb2:	88 0f       	add	r24, r24
    1eb4:	99 1f       	adc	r25, r25
    1eb6:	6a 95       	dec	r22
    1eb8:	e2 f7       	brpl	.-8      	; 0x1eb2 <DIO_voidTogglePin+0x1e>
    1eba:	28 27       	eor	r18, r24
    1ebc:	20 83       	st	Z, r18
    1ebe:	08 95       	ret
        case DIO_u8PORTB : TOG_BIT(PORTB, copy_u8PinNum); break;
    1ec0:	e8 e3       	ldi	r30, 0x38	; 56
    1ec2:	f0 e0       	ldi	r31, 0x00	; 0
    1ec4:	20 81       	ld	r18, Z
    1ec6:	81 e0       	ldi	r24, 0x01	; 1
    1ec8:	90 e0       	ldi	r25, 0x00	; 0
    1eca:	02 c0       	rjmp	.+4      	; 0x1ed0 <DIO_voidTogglePin+0x3c>
    1ecc:	88 0f       	add	r24, r24
    1ece:	99 1f       	adc	r25, r25
    1ed0:	6a 95       	dec	r22
    1ed2:	e2 f7       	brpl	.-8      	; 0x1ecc <DIO_voidTogglePin+0x38>
    1ed4:	28 27       	eor	r18, r24
    1ed6:	20 83       	st	Z, r18
    1ed8:	08 95       	ret
        case DIO_u8PORTC : TOG_BIT(PORTC, copy_u8PinNum); break;
    1eda:	e5 e3       	ldi	r30, 0x35	; 53
    1edc:	f0 e0       	ldi	r31, 0x00	; 0
    1ede:	20 81       	ld	r18, Z
    1ee0:	81 e0       	ldi	r24, 0x01	; 1
    1ee2:	90 e0       	ldi	r25, 0x00	; 0
    1ee4:	02 c0       	rjmp	.+4      	; 0x1eea <DIO_voidTogglePin+0x56>
    1ee6:	88 0f       	add	r24, r24
    1ee8:	99 1f       	adc	r25, r25
    1eea:	6a 95       	dec	r22
    1eec:	e2 f7       	brpl	.-8      	; 0x1ee6 <DIO_voidTogglePin+0x52>
    1eee:	28 27       	eor	r18, r24
    1ef0:	20 83       	st	Z, r18
    1ef2:	08 95       	ret
        case DIO_u8PORTD : TOG_BIT(PORTD, copy_u8PinNum); break;
    1ef4:	e2 e3       	ldi	r30, 0x32	; 50
    1ef6:	f0 e0       	ldi	r31, 0x00	; 0
    1ef8:	20 81       	ld	r18, Z
    1efa:	81 e0       	ldi	r24, 0x01	; 1
    1efc:	90 e0       	ldi	r25, 0x00	; 0
    1efe:	02 c0       	rjmp	.+4      	; 0x1f04 <DIO_voidTogglePin+0x70>
    1f00:	88 0f       	add	r24, r24
    1f02:	99 1f       	adc	r25, r25
    1f04:	6a 95       	dec	r22
    1f06:	e2 f7       	brpl	.-8      	; 0x1f00 <DIO_voidTogglePin+0x6c>
    1f08:	28 27       	eor	r18, r24
    1f0a:	20 83       	st	Z, r18
    1f0c:	08 95       	ret

00001f0e <DIO_voidSetPortDirection>:
        default : /* Error */ break;
    }
}
void DIO_voidSetPortDirection(Port_t copy_u8PortNum, uint_8 copy_u8Mode){
     
    switch(copy_u8PortNum){
    1f0e:	81 30       	cpi	r24, 0x01	; 1
    1f10:	49 f0       	breq	.+18     	; 0x1f24 <DIO_voidSetPortDirection+0x16>
    1f12:	81 30       	cpi	r24, 0x01	; 1
    1f14:	28 f0       	brcs	.+10     	; 0x1f20 <DIO_voidSetPortDirection+0x12>
    1f16:	82 30       	cpi	r24, 0x02	; 2
    1f18:	39 f0       	breq	.+14     	; 0x1f28 <DIO_voidSetPortDirection+0x1a>
    1f1a:	83 30       	cpi	r24, 0x03	; 3
    1f1c:	41 f4       	brne	.+16     	; 0x1f2e <DIO_voidSetPortDirection+0x20>
    1f1e:	06 c0       	rjmp	.+12     	; 0x1f2c <DIO_voidSetPortDirection+0x1e>
        case DIO_u8PORTA : DDRA = copy_u8Mode; break;
    1f20:	6a bb       	out	0x1a, r22	; 26
    1f22:	08 95       	ret
        case DIO_u8PORTB : DDRB = copy_u8Mode; break;
    1f24:	67 bb       	out	0x17, r22	; 23
    1f26:	08 95       	ret
        case DIO_u8PORTC : DDRC = copy_u8Mode; break;
    1f28:	64 bb       	out	0x14, r22	; 20
    1f2a:	08 95       	ret
        case DIO_u8PORTD : DDRD = copy_u8Mode; break;
    1f2c:	61 bb       	out	0x11, r22	; 17
    1f2e:	08 95       	ret

00001f30 <DIO_voidSetPortValue>:
    }

}
void DIO_voidSetPortValue(Port_t copy_u8PortNum, uint_8 copy_u8Logic){

    switch(copy_u8PortNum){
    1f30:	81 30       	cpi	r24, 0x01	; 1
    1f32:	49 f0       	breq	.+18     	; 0x1f46 <DIO_voidSetPortValue+0x16>
    1f34:	81 30       	cpi	r24, 0x01	; 1
    1f36:	28 f0       	brcs	.+10     	; 0x1f42 <DIO_voidSetPortValue+0x12>
    1f38:	82 30       	cpi	r24, 0x02	; 2
    1f3a:	39 f0       	breq	.+14     	; 0x1f4a <DIO_voidSetPortValue+0x1a>
    1f3c:	83 30       	cpi	r24, 0x03	; 3
    1f3e:	41 f4       	brne	.+16     	; 0x1f50 <DIO_voidSetPortValue+0x20>
    1f40:	06 c0       	rjmp	.+12     	; 0x1f4e <DIO_voidSetPortValue+0x1e>
        case DIO_u8PORTA : PORTA = copy_u8Logic; break;
    1f42:	6b bb       	out	0x1b, r22	; 27
    1f44:	08 95       	ret
        case DIO_u8PORTB : PORTB = copy_u8Logic; break;
    1f46:	68 bb       	out	0x18, r22	; 24
    1f48:	08 95       	ret
        case DIO_u8PORTC : PORTC = copy_u8Logic; break;
    1f4a:	65 bb       	out	0x15, r22	; 21
    1f4c:	08 95       	ret
        case DIO_u8PORTD : PORTD = copy_u8Logic; break;
    1f4e:	62 bb       	out	0x12, r22	; 18
    1f50:	08 95       	ret

00001f52 <TEMP_u16GetValue>:
uint_16 TEMP_u16GetValue(uint_8 Copy_u8ChannelNumber){

	uint_16 Local_u16AnalogValue = 0;
	uint_16 Local_u16Temperature = 0;

	Local_u16AnalogValue = ADC_u16ReadValue(Copy_u8ChannelNumber);
    1f52:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <ADC_u16ReadValue>
    1f56:	2e ee       	ldi	r18, 0xEE	; 238
    1f58:	32 e0       	ldi	r19, 0x02	; 2
    1f5a:	ab 01       	movw	r20, r22
    1f5c:	42 9f       	mul	r20, r18
    1f5e:	b0 01       	movw	r22, r0
    1f60:	43 9f       	mul	r20, r19
    1f62:	70 0d       	add	r23, r0
    1f64:	52 9f       	mul	r21, r18
    1f66:	70 0d       	add	r23, r0
    1f68:	11 24       	eor	r1, r1
    1f6a:	80 e0       	ldi	r24, 0x00	; 0
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	0e 94 93 03 	call	0x726	; 0x726 <__floatunsisf>
    1f72:	20 e0       	ldi	r18, 0x00	; 0
    1f74:	30 ed       	ldi	r19, 0xD0	; 208
    1f76:	4f eb       	ldi	r20, 0xBF	; 191
    1f78:	54 e4       	ldi	r21, 0x44	; 68
    1f7a:	0e 94 63 02 	call	0x4c6	; 0x4c6 <__divsf3>
    1f7e:	0e 94 8d 00 	call	0x11a	; 0x11a <__fixunssfsi>
    1f82:	9b 01       	movw	r18, r22
    1f84:	ac 01       	movw	r20, r24

	Local_u16Temperature = (Local_u16AnalogValue*150*5)/(1023*1.5);

	return Local_u16Temperature;

}
    1f86:	86 2f       	mov	r24, r22
    1f88:	93 2f       	mov	r25, r19
    1f8a:	08 95       	ret

00001f8c <TEMP_voidInit>:
***************************** Function Implementation *************************
******************************************************************************/

void TEMP_voidInit(void){

	ADC_voidInit();
    1f8c:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <ADC_voidInit>

}
    1f90:	08 95       	ret

00001f92 <SERVO_voidSetAngle>:


void SERVO_voidSetAngle(uint_32  _u8Angle ){

	uint_16 Local_u16Result = (((uint_32)_u8Angle * 1000) / 180) + 1000;
	TIMER1_voidSetOCR1B(Local_u16Result);
    1f92:	28 ee       	ldi	r18, 0xE8	; 232
    1f94:	33 e0       	ldi	r19, 0x03	; 3
    1f96:	40 e0       	ldi	r20, 0x00	; 0
    1f98:	50 e0       	ldi	r21, 0x00	; 0
    1f9a:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <__mulsi3>
    1f9e:	24 eb       	ldi	r18, 0xB4	; 180
    1fa0:	30 e0       	ldi	r19, 0x00	; 0
    1fa2:	40 e0       	ldi	r20, 0x00	; 0
    1fa4:	50 e0       	ldi	r21, 0x00	; 0
    1fa6:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
    1faa:	da 01       	movw	r26, r20
    1fac:	c9 01       	movw	r24, r18
    1fae:	88 51       	subi	r24, 0x18	; 24
    1fb0:	9c 4f       	sbci	r25, 0xFC	; 252
    1fb2:	0e 94 1f 09 	call	0x123e	; 0x123e <TIMER1_voidSetOCR1B>
}
    1fb6:	08 95       	ret

00001fb8 <SERVO_voidInit>:
	 * use fast mode with top value at OCRA reg to set the freq of servo
	 * diconnect OC1A PIN ,and generate the PWM on OC1B PIN with non inverting mode
	 * to use OCR1B reg as the ton value 
	 */
	//DIO_voidSetPortDirection(DIO_u8PORTD,0xFF);
	TIMER1_voidInit(TIMER1_FAST_PWM_ICR1_MODE, TIMER1_SCALER_8);
    1fb8:	8d e0       	ldi	r24, 0x0D	; 13
    1fba:	62 e0       	ldi	r22, 0x02	; 2
    1fbc:	0e 94 6d 07 	call	0xeda	; 0xeda <TIMER1_voidInit>
	TIMER1_voidOutputCompareInit(TIMER1_OC1_NON_INVERTING_MODE, TIMER1_OCR1A);
    1fc0:	82 e0       	ldi	r24, 0x02	; 2
    1fc2:	60 e0       	ldi	r22, 0x00	; 0
    1fc4:	0e 94 af 08 	call	0x115e	; 0x115e <TIMER1_voidOutputCompareInit>
	//TIMER1_voidSetOCR1A(2000);
	//_delay_ms(200);
	/* 2000us Ton to get angle zero */
	//TIMER1_voidSetOCR1A(4000); //180
	//_delay_ms(200);
}
    1fc8:	08 95       	ret

00001fca <Ecual_DC_Motor_Status>:
void Ecual_DC_Motor_Stop(const uint_8 copy_u8Port, const uint_8 copy_u8PinsNum[2]){
	DIO_voidSetPinValue(copy_u8Port, copy_u8PinsNum[FIRST_PIN], MOTOR_OFF);
	DIO_voidSetPinValue(copy_u8Port, copy_u8PinsNum[SECOND_PIN], MOTOR_OFF);
}

Motor_State Ecual_DC_Motor_Status(const uint_8 copy_u8PortNum, const uint_8 copy_u8PinsNum[2]){
    1fca:	0f 93       	push	r16
    1fcc:	1f 93       	push	r17
    1fce:	cf 93       	push	r28
    1fd0:	df 93       	push	r29
    1fd2:	08 2f       	mov	r16, r24
    1fd4:	eb 01       	movw	r28, r22

	Motor_State Local_u8State = MotorStop;
	if(DIO_u8GetPinValue(copy_u8PortNum, copy_u8PinsNum[FIRST_PIN]) != DIO_u8GetPinValue(copy_u8PortNum, copy_u8PinsNum[SECOND_PIN]))
    1fd6:	68 81       	ld	r22, Y
    1fd8:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <DIO_u8GetPinValue>
    1fdc:	18 2f       	mov	r17, r24
    1fde:	80 2f       	mov	r24, r16
    1fe0:	69 81       	ldd	r22, Y+1	; 0x01
    1fe2:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <DIO_u8GetPinValue>
    1fe6:	18 17       	cp	r17, r24
    1fe8:	11 f4       	brne	.+4      	; 0x1fee <Ecual_DC_Motor_Status+0x24>
    1fea:	80 e0       	ldi	r24, 0x00	; 0
    1fec:	09 c0       	rjmp	.+18     	; 0x2000 <Ecual_DC_Motor_Status+0x36>
	{
		if(MOTOR_ON == DIO_u8GetPinValue(copy_u8PortNum, copy_u8PinsNum[FIRST_PIN])){
    1fee:	80 2f       	mov	r24, r16
    1ff0:	68 81       	ld	r22, Y
    1ff2:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <DIO_u8GetPinValue>
    1ff6:	81 30       	cpi	r24, 0x01	; 1
    1ff8:	11 f0       	breq	.+4      	; 0x1ffe <Ecual_DC_Motor_Status+0x34>
    1ffa:	82 e0       	ldi	r24, 0x02	; 2
    1ffc:	01 c0       	rjmp	.+2      	; 0x2000 <Ecual_DC_Motor_Status+0x36>
    1ffe:	81 e0       	ldi	r24, 0x01	; 1
	else{
		Local_u8State = MotorStop;
	}

	return Local_u8State;
}
    2000:	df 91       	pop	r29
    2002:	cf 91       	pop	r28
    2004:	1f 91       	pop	r17
    2006:	0f 91       	pop	r16
    2008:	08 95       	ret

0000200a <Ecual_DC_Motor_Stop>:
}
void Ecual_DC_Motor_Reverse(const uint_8 copy_u8Port, const uint_8 copy_u8PinsNum[2]){
	DIO_voidSetPinValue(copy_u8Port, copy_u8PinsNum[FIRST_PIN], MOTOR_OFF);
	DIO_voidSetPinValue(copy_u8Port, copy_u8PinsNum[SECOND_PIN], MOTOR_ON);
}
void Ecual_DC_Motor_Stop(const uint_8 copy_u8Port, const uint_8 copy_u8PinsNum[2]){
    200a:	ff 92       	push	r15
    200c:	0f 93       	push	r16
    200e:	1f 93       	push	r17
    2010:	f8 2e       	mov	r15, r24
    2012:	8b 01       	movw	r16, r22
	DIO_voidSetPinValue(copy_u8Port, copy_u8PinsNum[FIRST_PIN], MOTOR_OFF);
    2014:	fb 01       	movw	r30, r22
    2016:	60 81       	ld	r22, Z
    2018:	40 e0       	ldi	r20, 0x00	; 0
    201a:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(copy_u8Port, copy_u8PinsNum[SECOND_PIN], MOTOR_OFF);
    201e:	8f 2d       	mov	r24, r15
    2020:	f8 01       	movw	r30, r16
    2022:	61 81       	ldd	r22, Z+1	; 0x01
    2024:	40 e0       	ldi	r20, 0x00	; 0
    2026:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
}
    202a:	1f 91       	pop	r17
    202c:	0f 91       	pop	r16
    202e:	ff 90       	pop	r15
    2030:	08 95       	ret

00002032 <Ecual_DC_Motor_Reverse>:
}
void Ecual_DC_Motor_Forward(const uint_8 copy_u8Port, const uint_8 copy_u8PinsNum[2]){
	DIO_voidSetPinValue(copy_u8Port, copy_u8PinsNum[FIRST_PIN], MOTOR_ON);
	//DIO_voidSetPinValue(copy_u8Port, copy_u8PinsNum[SECOND_PIN], MOTOR_OFF);
}
void Ecual_DC_Motor_Reverse(const uint_8 copy_u8Port, const uint_8 copy_u8PinsNum[2]){
    2032:	ff 92       	push	r15
    2034:	0f 93       	push	r16
    2036:	1f 93       	push	r17
    2038:	f8 2e       	mov	r15, r24
    203a:	8b 01       	movw	r16, r22
	DIO_voidSetPinValue(copy_u8Port, copy_u8PinsNum[FIRST_PIN], MOTOR_OFF);
    203c:	fb 01       	movw	r30, r22
    203e:	60 81       	ld	r22, Z
    2040:	40 e0       	ldi	r20, 0x00	; 0
    2042:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
	DIO_voidSetPinValue(copy_u8Port, copy_u8PinsNum[SECOND_PIN], MOTOR_ON);
    2046:	8f 2d       	mov	r24, r15
    2048:	f8 01       	movw	r30, r16
    204a:	61 81       	ldd	r22, Z+1	; 0x01
    204c:	41 e0       	ldi	r20, 0x01	; 1
    204e:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
}
    2052:	1f 91       	pop	r17
    2054:	0f 91       	pop	r16
    2056:	ff 90       	pop	r15
    2058:	08 95       	ret

0000205a <Ecual_DC_Motor_Forward>:
}
void Ecual_DC_Motor_Intialize(const uint_8 copy_u8Port, const uint_8 copy_u8PinsNum[2], const uint_8 copy_u8State){
	DIO_voidSetPinDirection(copy_u8Port, copy_u8PinsNum[FIRST_PIN], copy_u8State);
	//DIO_voidSetPinDirection(copy_u8Port, copy_u8PinsNum[SECOND_PIN], Output);
}
void Ecual_DC_Motor_Forward(const uint_8 copy_u8Port, const uint_8 copy_u8PinsNum[2]){
    205a:	fb 01       	movw	r30, r22
	DIO_voidSetPinValue(copy_u8Port, copy_u8PinsNum[FIRST_PIN], MOTOR_ON);
    205c:	60 81       	ld	r22, Z
    205e:	41 e0       	ldi	r20, 0x01	; 1
    2060:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
	//DIO_voidSetPinValue(copy_u8Port, copy_u8PinsNum[SECOND_PIN], MOTOR_OFF);
}
    2064:	08 95       	ret

00002066 <Motor_void_stop>:
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR1_2,Low);
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR2_1,High);
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR2_2,Low);
}
void Motor_void_stop(void){
	DIO_voidSetPinValue(MOTOR_PORT,MOTOR1_1,Low);
    2066:	80 e0       	ldi	r24, 0x00	; 0
    2068:	61 e0       	ldi	r22, 0x01	; 1
    206a:	40 e0       	ldi	r20, 0x00	; 0
    206c:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR1_2,Low);
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR2_1,Low);
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR2_2,Low);
}
    2070:	08 95       	ret

00002072 <Motor_void_ck>:
	//DIO_voidSetPinDirection(MOTOR_PORT,MOTOR1_2,Output);
	//DIO_voidSetPinDirection(MOTOR_PORT,MOTOR2_1,Output);
	//DIO_voidSetPinDirection(MOTOR_PORT,MOTOR2_2,Output);
}
void Motor_void_ck(void){
	DIO_voidSetPinValue(MOTOR_PORT,MOTOR1_1,High);
    2072:	80 e0       	ldi	r24, 0x00	; 0
    2074:	61 e0       	ldi	r22, 0x01	; 1
    2076:	41 e0       	ldi	r20, 0x01	; 1
    2078:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR1_2,Low);
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR2_1,High);
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR2_2,Low);
}
    207c:	08 95       	ret

0000207e <Ecual_DC_Motor_Intialize>:
	DIO_voidSetPinValue(MOTOR_PORT,MOTOR1_1,Low);
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR1_2,Low);
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR2_1,Low);
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR2_2,Low);
}
void Ecual_DC_Motor_Intialize(const uint_8 copy_u8Port, const uint_8 copy_u8PinsNum[2], const uint_8 copy_u8State){
    207e:	fb 01       	movw	r30, r22
	DIO_voidSetPinDirection(copy_u8Port, copy_u8PinsNum[FIRST_PIN], copy_u8State);
    2080:	60 81       	ld	r22, Z
    2082:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
	//DIO_voidSetPinDirection(copy_u8Port, copy_u8PinsNum[SECOND_PIN], Output);
}
    2086:	08 95       	ret

00002088 <Motor_void_Intilize>:
/*-------------- Global Variable Definitions  ---------------*/

/*-------------- APIs Definitions ---------------*/

void Motor_void_Intilize(void){
	DIO_voidSetPinDirection(MOTOR_PORT,MOTOR1_1,Output);
    2088:	80 e0       	ldi	r24, 0x00	; 0
    208a:	61 e0       	ldi	r22, 0x01	; 1
    208c:	41 e0       	ldi	r20, 0x01	; 1
    208e:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
	//DIO_voidSetPinValue(MOTOR_PORT,MOTOR1_1,Low);
	//DIO_voidSetPinDirection(MOTOR_PORT,MOTOR1_2,Output);
	//DIO_voidSetPinDirection(MOTOR_PORT,MOTOR2_1,Output);
	//DIO_voidSetPinDirection(MOTOR_PORT,MOTOR2_2,Output);
}
    2092:	08 95       	ret

00002094 <Ecual_Led_GetStatus>:
    	DIO_voidTogglePin(Led->Port, Led->Pin);
    }
    return ret;
}

Std_ReturnType Ecual_Led_GetStatus(const Led_t* Led, Led_State *Led_Status){
    2094:	cf 93       	push	r28
    2096:	df 93       	push	r29
    2098:	fc 01       	movw	r30, r24
    209a:	eb 01       	movw	r28, r22
	Std_ReturnType ret = E_OK;

	    if(0 == Led)
    209c:	00 97       	sbiw	r24, 0x00	; 0
    209e:	11 f4       	brne	.+4      	; 0x20a4 <Ecual_Led_GetStatus+0x10>
    20a0:	81 e0       	ldi	r24, 0x01	; 1
    20a2:	16 c0       	rjmp	.+44     	; 0x20d0 <Ecual_Led_GetStatus+0x3c>
	    {
	        ret = E_NOT_OK;
	    }
	    else
	    {
	    	*Led_Status = DIO_u8GetPinValue(Led->Port, Led->Pin);
    20a4:	80 81       	ld	r24, Z
    20a6:	68 2f       	mov	r22, r24
    20a8:	66 95       	lsr	r22
    20aa:	66 95       	lsr	r22
    20ac:	66 95       	lsr	r22
    20ae:	67 70       	andi	r22, 0x07	; 7
    20b0:	87 70       	andi	r24, 0x07	; 7
    20b2:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <DIO_u8GetPinValue>
    20b6:	88 83       	st	Y, r24
	    	switch(*Led_Status)
    20b8:	88 23       	and	r24, r24
    20ba:	21 f0       	breq	.+8      	; 0x20c4 <Ecual_Led_GetStatus+0x30>
    20bc:	81 30       	cpi	r24, 0x01	; 1
    20be:	29 f0       	breq	.+10     	; 0x20ca <Ecual_Led_GetStatus+0x36>
    20c0:	80 e0       	ldi	r24, 0x00	; 0
    20c2:	06 c0       	rjmp	.+12     	; 0x20d0 <Ecual_Led_GetStatus+0x3c>
	    	{
	    		case Low:
	    			*Led_Status = LedOff;
    20c4:	18 82       	st	Y, r1
    20c6:	80 e0       	ldi	r24, 0x00	; 0
    20c8:	03 c0       	rjmp	.+6      	; 0x20d0 <Ecual_Led_GetStatus+0x3c>
	    			break;
	    		case High:
	    			*Led_Status = LedOn;
    20ca:	81 e0       	ldi	r24, 0x01	; 1
    20cc:	88 83       	st	Y, r24
    20ce:	80 e0       	ldi	r24, 0x00	; 0
	    			 break;
	    	}
	    }
	    return ret;
}
    20d0:	df 91       	pop	r29
    20d2:	cf 91       	pop	r28
    20d4:	08 95       	ret

000020d6 <Ecual_Led_Toggle>:
    {
    	DIO_voidSetPinValue(Led->Port, Led->Pin, Low);
    }
    return ret;
}
Std_ReturnType Ecual_Led_Toggle(const Led_t* Led){
    20d6:	fc 01       	movw	r30, r24
    Std_ReturnType ret = E_OK;
    if(0 == Led)
    20d8:	00 97       	sbiw	r24, 0x00	; 0
    20da:	11 f4       	brne	.+4      	; 0x20e0 <Ecual_Led_Toggle+0xa>
    20dc:	81 e0       	ldi	r24, 0x01	; 1
    20de:	08 95       	ret
    {
        ret = E_NOT_OK;
    }
    else
    {
    	DIO_voidTogglePin(Led->Port, Led->Pin);
    20e0:	80 81       	ld	r24, Z
    20e2:	68 2f       	mov	r22, r24
    20e4:	66 95       	lsr	r22
    20e6:	66 95       	lsr	r22
    20e8:	66 95       	lsr	r22
    20ea:	67 70       	andi	r22, 0x07	; 7
    20ec:	87 70       	andi	r24, 0x07	; 7
    20ee:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <DIO_voidTogglePin>
    20f2:	80 e0       	ldi	r24, 0x00	; 0
    }
    return ret;
}
    20f4:	08 95       	ret

000020f6 <Ecual_Led_TurnOff>:
    {
    	DIO_voidSetPinValue(Led->Port, Led->Pin, High);
    }
    return ret;
}
Std_ReturnType Ecual_Led_TurnOff(const Led_t* Led){
    20f6:	fc 01       	movw	r30, r24
    Std_ReturnType ret = E_OK;
    if(0 == Led)
    20f8:	00 97       	sbiw	r24, 0x00	; 0
    20fa:	11 f4       	brne	.+4      	; 0x2100 <Ecual_Led_TurnOff+0xa>
    20fc:	81 e0       	ldi	r24, 0x01	; 1
    20fe:	08 95       	ret
    {
        ret = E_NOT_OK;
    }
    else
    {
    	DIO_voidSetPinValue(Led->Port, Led->Pin, Low);
    2100:	80 81       	ld	r24, Z
    2102:	68 2f       	mov	r22, r24
    2104:	66 95       	lsr	r22
    2106:	66 95       	lsr	r22
    2108:	66 95       	lsr	r22
    210a:	67 70       	andi	r22, 0x07	; 7
    210c:	87 70       	andi	r24, 0x07	; 7
    210e:	40 e0       	ldi	r20, 0x00	; 0
    2110:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
    2114:	80 e0       	ldi	r24, 0x00	; 0
    }
    return ret;
}
    2116:	08 95       	ret

00002118 <Ecual_Led_TurnOn>:
    {
    	DIO_voidSetPinDirection(Led->Port, Led->Pin, Led->State);
    }
    return ret;
}
Std_ReturnType Ecual_Led_TurnOn(const Led_t* Led){
    2118:	fc 01       	movw	r30, r24
    Std_ReturnType ret = E_OK;
    if(0 == Led)
    211a:	00 97       	sbiw	r24, 0x00	; 0
    211c:	11 f4       	brne	.+4      	; 0x2122 <Ecual_Led_TurnOn+0xa>
    211e:	81 e0       	ldi	r24, 0x01	; 1
    2120:	08 95       	ret
    {
        ret = E_NOT_OK;
    }
    else
    {
    	DIO_voidSetPinValue(Led->Port, Led->Pin, High);
    2122:	80 81       	ld	r24, Z
    2124:	68 2f       	mov	r22, r24
    2126:	66 95       	lsr	r22
    2128:	66 95       	lsr	r22
    212a:	66 95       	lsr	r22
    212c:	67 70       	andi	r22, 0x07	; 7
    212e:	87 70       	andi	r24, 0x07	; 7
    2130:	41 e0       	ldi	r20, 0x01	; 1
    2132:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
    2136:	80 e0       	ldi	r24, 0x00	; 0
    }
    return ret;
}
    2138:	08 95       	ret

0000213a <Ecual_Led_Intialize>:
/**
 * 
 * @param Led
 * @return 
 */
uint_8 Ecual_Led_Intialize(const Led_t* Led){
    213a:	fc 01       	movw	r30, r24
    Std_ReturnType ret = E_OK;
    if(0 == Led)
    213c:	00 97       	sbiw	r24, 0x00	; 0
    213e:	11 f4       	brne	.+4      	; 0x2144 <Ecual_Led_Intialize+0xa>
    2140:	81 e0       	ldi	r24, 0x01	; 1
    2142:	08 95       	ret
    {
        ret = E_NOT_OK;
    }
    else
    {
    	DIO_voidSetPinDirection(Led->Port, Led->Pin, Led->State);
    2144:	80 81       	ld	r24, Z
    2146:	68 2f       	mov	r22, r24
    2148:	66 95       	lsr	r22
    214a:	66 95       	lsr	r22
    214c:	66 95       	lsr	r22
    214e:	67 70       	andi	r22, 0x07	; 7
    2150:	48 2f       	mov	r20, r24
    2152:	42 95       	swap	r20
    2154:	46 95       	lsr	r20
    2156:	46 95       	lsr	r20
    2158:	43 70       	andi	r20, 0x03	; 3
    215a:	41 70       	andi	r20, 0x01	; 1
    215c:	87 70       	andi	r24, 0x07	; 7
    215e:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
    2162:	80 e0       	ldi	r24, 0x00	; 0
    }
    return ret;
}
    2164:	08 95       	ret

00002166 <Keypad_u8GetPressed>:
	DIO_voidSetPortDirection(KEYPAD_U8PORT, 0X0F);
	DIO_voidSetPortValue(KEYPAD_U8PORT, 0XFF);
}

uint_8 Keypad_u8GetPressed(const uint_8 Copy_u8Keypad[KEYPAD_ROW][KEYPAD_COL])
{
    2166:	cf 92       	push	r12
    2168:	df 92       	push	r13
    216a:	ef 92       	push	r14
    216c:	ff 92       	push	r15
    216e:	0f 93       	push	r16
    2170:	1f 93       	push	r17
    2172:	cf 93       	push	r28
    2174:	df 93       	push	r29
    2176:	7c 01       	movw	r14, r24
    2178:	0f 2e       	mov	r0, r31
    217a:	fb e2       	ldi	r31, 0x2B	; 43
    217c:	df 2e       	mov	r13, r31
    217e:	f0 2d       	mov	r31, r0
    2180:	00 e0       	ldi	r16, 0x00	; 0

	uint_8 Local_u8Key = '+', Local_u8Row = 0, Local_u8Col = 0;

	for(Local_u8Row = 0; Local_u8Row < KEYPAD_ROW; Local_u8Row++){
		DIO_voidSetPinValue(KEYPAD_U8PORT, Local_u8Row, Low);
    2182:	cc 24       	eor	r12, r12
    2184:	68 94       	set
    2186:	c2 f8       	bld	r12, 2
    2188:	81 e0       	ldi	r24, 0x01	; 1
    218a:	60 2f       	mov	r22, r16
    218c:	40 e0       	ldi	r20, 0x00	; 0
    218e:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
    2192:	e7 01       	movw	r28, r14
    2194:	1c 2d       	mov	r17, r12

		for(Local_u8Col = 0; Local_u8Col < KEYPAD_COL; Local_u8Col++){
			if(0 == DIO_u8GetPinValue(KEYPAD_U8PORT, Local_u8Col+KEYPAD_ROW)){
    2196:	81 e0       	ldi	r24, 0x01	; 1
    2198:	61 2f       	mov	r22, r17
    219a:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <DIO_u8GetPinValue>
    219e:	88 23       	and	r24, r24
    21a0:	09 f4       	brne	.+2      	; 0x21a4 <Keypad_u8GetPressed+0x3e>
				Local_u8Key = Copy_u8Keypad[Local_u8Row][Local_u8Col];
    21a2:	d8 80       	ld	r13, Y
			/* If you use this line ( break; ) here instead of ( while(0 == DIO_u8GetPinLogic(KEYPAD_U8PORT, Local_u8Col)); ),
			   the function will execute right and it will return the right number but you should know that the function is
			   used in while(1) in the (main function) so if you press on the button, the function will execute more than once
			   because of the high speed of the processor. So if you want to use (break) you have to change the main function */
			}
			while(0 == DIO_u8GetPinValue(KEYPAD_U8PORT, Local_u8Col+KEYPAD_ROW));
    21a4:	81 e0       	ldi	r24, 0x01	; 1
    21a6:	61 2f       	mov	r22, r17
    21a8:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <DIO_u8GetPinValue>
    21ac:	88 23       	and	r24, r24
    21ae:	d1 f3       	breq	.-12     	; 0x21a4 <Keypad_u8GetPressed+0x3e>
    21b0:	1f 5f       	subi	r17, 0xFF	; 255
    21b2:	21 96       	adiw	r28, 0x01	; 1
	uint_8 Local_u8Key = '+', Local_u8Row = 0, Local_u8Col = 0;

	for(Local_u8Row = 0; Local_u8Row < KEYPAD_ROW; Local_u8Row++){
		DIO_voidSetPinValue(KEYPAD_U8PORT, Local_u8Row, Low);

		for(Local_u8Col = 0; Local_u8Col < KEYPAD_COL; Local_u8Col++){
    21b4:	18 30       	cpi	r17, 0x08	; 8
    21b6:	79 f7       	brne	.-34     	; 0x2196 <Keypad_u8GetPressed+0x30>
			}
			while(0 == DIO_u8GetPinValue(KEYPAD_U8PORT, Local_u8Col+KEYPAD_ROW));
			/* But here there are no return from the function (it will stuck) until you release the pressed button */
		}

		DIO_voidSetPinValue(KEYPAD_U8PORT, Local_u8Row, High);
    21b8:	81 e0       	ldi	r24, 0x01	; 1
    21ba:	60 2f       	mov	r22, r16
    21bc:	41 e0       	ldi	r20, 0x01	; 1
    21be:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
uint_8 Keypad_u8GetPressed(const uint_8 Copy_u8Keypad[KEYPAD_ROW][KEYPAD_COL])
{

	uint_8 Local_u8Key = '+', Local_u8Row = 0, Local_u8Col = 0;

	for(Local_u8Row = 0; Local_u8Row < KEYPAD_ROW; Local_u8Row++){
    21c2:	0f 5f       	subi	r16, 0xFF	; 255
    21c4:	84 e0       	ldi	r24, 0x04	; 4
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	e8 0e       	add	r14, r24
    21ca:	f9 1e       	adc	r15, r25
    21cc:	04 30       	cpi	r16, 0x04	; 4
    21ce:	e1 f6       	brne	.-72     	; 0x2188 <Keypad_u8GetPressed+0x22>

		DIO_voidSetPinValue(KEYPAD_U8PORT, Local_u8Row, High);
	}

	return Local_u8Key;
}
    21d0:	8d 2d       	mov	r24, r13
    21d2:	df 91       	pop	r29
    21d4:	cf 91       	pop	r28
    21d6:	1f 91       	pop	r17
    21d8:	0f 91       	pop	r16
    21da:	ff 90       	pop	r15
    21dc:	ef 90       	pop	r14
    21de:	df 90       	pop	r13
    21e0:	cf 90       	pop	r12
    21e2:	08 95       	ret

000021e4 <Keypad_voidInit>:


/*-------------- APIs Definitions ---------------*/
void Keypad_voidInit(void)
{
	DIO_voidSetPortDirection(KEYPAD_U8PORT, 0X0F);
    21e4:	81 e0       	ldi	r24, 0x01	; 1
    21e6:	6f e0       	ldi	r22, 0x0F	; 15
    21e8:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <DIO_voidSetPortDirection>
	DIO_voidSetPortValue(KEYPAD_U8PORT, 0XFF);
    21ec:	81 e0       	ldi	r24, 0x01	; 1
    21ee:	6f ef       	ldi	r22, 0xFF	; 255
    21f0:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <DIO_voidSetPortValue>
}
    21f4:	08 95       	ret

000021f6 <CLCD_voidWriteData>:
	_delay_ms(1);
	DIO_voidSetPinValue(CLCD_CONTROL_PORT, CLCD_EN_PIN, Low);
	_delay_ms(1);
}

void CLCD_voidWriteData(uint_8 Copy_u8Data){
    21f6:	0f 93       	push	r16
    21f8:	1f 93       	push	r17
    21fa:	18 2f       	mov	r17, r24
	DIO_voidSetPinValue(CLCD_CONTROL_PORT, CLCD_RS_PIN, High); //Send Data
    21fc:	83 e0       	ldi	r24, 0x03	; 3
    21fe:	66 e0       	ldi	r22, 0x06	; 6
    2200:	41 e0       	ldi	r20, 0x01	; 1
    2202:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
	DIO_voidSetPortValue(CLCD_DATA_PORT, Copy_u8Data); //Data
    2206:	82 e0       	ldi	r24, 0x02	; 2
    2208:	61 2f       	mov	r22, r17
    220a:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <DIO_voidSetPortValue>
	DIO_voidSetPinValue(CLCD_CONTROL_PORT, CLCD_EN_PIN, High);
    220e:	83 e0       	ldi	r24, 0x03	; 3
    2210:	67 e0       	ldi	r22, 0x07	; 7
    2212:	41 e0       	ldi	r20, 0x01	; 1
    2214:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2218:	00 ed       	ldi	r16, 0xD0	; 208
    221a:	17 e0       	ldi	r17, 0x07	; 7
    221c:	c8 01       	movw	r24, r16
    221e:	01 97       	sbiw	r24, 0x01	; 1
    2220:	f1 f7       	brne	.-4      	; 0x221e <CLCD_voidWriteData+0x28>
	_delay_ms(1);
	DIO_voidSetPinValue(CLCD_CONTROL_PORT, CLCD_EN_PIN, Low);
    2222:	83 e0       	ldi	r24, 0x03	; 3
    2224:	67 e0       	ldi	r22, 0x07	; 7
    2226:	40 e0       	ldi	r20, 0x00	; 0
    2228:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
    222c:	c8 01       	movw	r24, r16
    222e:	01 97       	sbiw	r24, 0x01	; 1
    2230:	f1 f7       	brne	.-4      	; 0x222e <CLCD_voidWriteData+0x38>
	_delay_ms(1);
}
    2232:	1f 91       	pop	r17
    2234:	0f 91       	pop	r16
    2236:	08 95       	ret

00002238 <CLCD_voidWriteNumbers>:
		case 4 : CLCD_voidSendCommand(0xD0+Copy_u8Coloum); break;
		default : /* Error */ break;
	}
}

void CLCD_voidWriteNumbers(uint_32 Copy_u32Number){
    2238:	cf 92       	push	r12
    223a:	df 92       	push	r13
    223c:	ef 92       	push	r14
    223e:	ff 92       	push	r15
    2240:	0f 93       	push	r16
    2242:	1f 93       	push	r17
    2244:	cf 93       	push	r28
    2246:	df 93       	push	r29
    2248:	6b 01       	movw	r12, r22
    224a:	7c 01       	movw	r14, r24
	int remainder = 0, reverse = 1;
	while (Copy_u32Number != 0) {
    224c:	61 15       	cp	r22, r1
    224e:	71 05       	cpc	r23, r1
    2250:	81 05       	cpc	r24, r1
    2252:	91 05       	cpc	r25, r1
    2254:	79 f1       	breq	.+94     	; 0x22b4 <CLCD_voidWriteNumbers+0x7c>
    2256:	c1 e0       	ldi	r28, 0x01	; 1
    2258:	d0 e0       	ldi	r29, 0x00	; 0
	    remainder = Copy_u32Number % 10;
	    reverse = reverse * 10 + remainder;
    225a:	8e 01       	movw	r16, r28
    225c:	00 0f       	add	r16, r16
    225e:	11 1f       	adc	r17, r17
    2260:	ce 01       	movw	r24, r28
    2262:	88 0f       	add	r24, r24
    2264:	99 1f       	adc	r25, r25
    2266:	88 0f       	add	r24, r24
    2268:	99 1f       	adc	r25, r25
    226a:	88 0f       	add	r24, r24
    226c:	99 1f       	adc	r25, r25
    226e:	08 0f       	add	r16, r24
    2270:	19 1f       	adc	r17, r25
    2272:	c7 01       	movw	r24, r14
    2274:	b6 01       	movw	r22, r12
    2276:	2a e0       	ldi	r18, 0x0A	; 10
    2278:	30 e0       	ldi	r19, 0x00	; 0
    227a:	40 e0       	ldi	r20, 0x00	; 0
    227c:	50 e0       	ldi	r21, 0x00	; 0
    227e:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
    2282:	e8 01       	movw	r28, r16
    2284:	c6 0f       	add	r28, r22
    2286:	d7 1f       	adc	r29, r23
	    Copy_u32Number /= 10;
    2288:	c7 01       	movw	r24, r14
    228a:	b6 01       	movw	r22, r12
    228c:	2a e0       	ldi	r18, 0x0A	; 10
    228e:	30 e0       	ldi	r19, 0x00	; 0
    2290:	40 e0       	ldi	r20, 0x00	; 0
    2292:	50 e0       	ldi	r21, 0x00	; 0
    2294:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
    2298:	82 2f       	mov	r24, r18
    229a:	93 2f       	mov	r25, r19
    229c:	a4 2f       	mov	r26, r20
    229e:	b5 2f       	mov	r27, r21
    22a0:	6c 01       	movw	r12, r24
    22a2:	7d 01       	movw	r14, r26
	}
}

void CLCD_voidWriteNumbers(uint_32 Copy_u32Number){
	int remainder = 0, reverse = 1;
	while (Copy_u32Number != 0) {
    22a4:	c1 14       	cp	r12, r1
    22a6:	d1 04       	cpc	r13, r1
    22a8:	e1 04       	cpc	r14, r1
    22aa:	f1 04       	cpc	r15, r1
    22ac:	b1 f6       	brne	.-84     	; 0x225a <CLCD_voidWriteNumbers+0x22>
	    remainder = Copy_u32Number % 10;
	    reverse = reverse * 10 + remainder;
	    Copy_u32Number /= 10;

	}
	if(reverse == 1)
    22ae:	c1 30       	cpi	r28, 0x01	; 1
    22b0:	d1 05       	cpc	r29, r1
    22b2:	21 f4       	brne	.+8      	; 0x22bc <CLCD_voidWriteNumbers+0x84>
	{
			CLCD_voidWriteData(48);
    22b4:	80 e3       	ldi	r24, 0x30	; 48
    22b6:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
    22ba:	13 c0       	rjmp	.+38     	; 0x22e2 <CLCD_voidWriteNumbers+0xaa>
	}
	while (reverse != 1){
	CLCD_voidWriteData((reverse%10)+48);
    22bc:	ce 01       	movw	r24, r28
    22be:	6a e0       	ldi	r22, 0x0A	; 10
    22c0:	70 e0       	ldi	r23, 0x00	; 0
    22c2:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__divmodhi4>
    22c6:	80 5d       	subi	r24, 0xD0	; 208
    22c8:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
	reverse /=10;
    22cc:	ce 01       	movw	r24, r28
    22ce:	6a e0       	ldi	r22, 0x0A	; 10
    22d0:	70 e0       	ldi	r23, 0x00	; 0
    22d2:	0e 94 8e 2d 	call	0x5b1c	; 0x5b1c <__divmodhi4>
    22d6:	86 2f       	mov	r24, r22
    22d8:	97 2f       	mov	r25, r23
    22da:	ec 01       	movw	r28, r24
	}
	if(reverse == 1)
	{
			CLCD_voidWriteData(48);
	}
	while (reverse != 1){
    22dc:	c1 30       	cpi	r28, 0x01	; 1
    22de:	d1 05       	cpc	r29, r1
    22e0:	69 f7       	brne	.-38     	; 0x22bc <CLCD_voidWriteNumbers+0x84>
	CLCD_voidWriteData((reverse%10)+48);
	reverse /=10;
	}

}
    22e2:	df 91       	pop	r29
    22e4:	cf 91       	pop	r28
    22e6:	1f 91       	pop	r17
    22e8:	0f 91       	pop	r16
    22ea:	ff 90       	pop	r15
    22ec:	ef 90       	pop	r14
    22ee:	df 90       	pop	r13
    22f0:	cf 90       	pop	r12
    22f2:	08 95       	ret

000022f4 <CLCD_voidWriteString>:
	_delay_ms(1);
	DIO_voidSetPinValue(CLCD_CONTROL_PORT, CLCD_EN_PIN, Low);
	_delay_ms(1);
}

void CLCD_voidWriteString(char String[]){
    22f4:	0f 93       	push	r16
    22f6:	1f 93       	push	r17
    22f8:	cf 93       	push	r28
    22fa:	df 93       	push	r29
    22fc:	8c 01       	movw	r16, r24
    22fe:	c0 e0       	ldi	r28, 0x00	; 0
    2300:	d0 e0       	ldi	r29, 0x00	; 0
    2302:	07 c0       	rjmp	.+14     	; 0x2312 <CLCD_voidWriteString+0x1e>
	uint_16 Counter = 0;
	for(Counter = 0; Counter < strlen(String); Counter++)
	{
		CLCD_voidWriteData(String[Counter]);
    2304:	f8 01       	movw	r30, r16
    2306:	ec 0f       	add	r30, r28
    2308:	fd 1f       	adc	r31, r29
    230a:	80 81       	ld	r24, Z
    230c:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
	_delay_ms(1);
}

void CLCD_voidWriteString(char String[]){
	uint_16 Counter = 0;
	for(Counter = 0; Counter < strlen(String); Counter++)
    2310:	21 96       	adiw	r28, 0x01	; 1
    2312:	a0 2f       	mov	r26, r16
    2314:	b1 2f       	mov	r27, r17
    2316:	fd 01       	movw	r30, r26
    2318:	01 90       	ld	r0, Z+
    231a:	00 20       	and	r0, r0
    231c:	e9 f7       	brne	.-6      	; 0x2318 <CLCD_voidWriteString+0x24>
    231e:	31 97       	sbiw	r30, 0x01	; 1
    2320:	ea 1b       	sub	r30, r26
    2322:	fb 0b       	sbc	r31, r27
    2324:	ce 17       	cp	r28, r30
    2326:	df 07       	cpc	r29, r31
    2328:	68 f3       	brcs	.-38     	; 0x2304 <CLCD_voidWriteString+0x10>
	{
		CLCD_voidWriteData(String[Counter]);
	}
}
    232a:	df 91       	pop	r29
    232c:	cf 91       	pop	r28
    232e:	1f 91       	pop	r17
    2330:	0f 91       	pop	r16
    2332:	08 95       	ret

00002334 <CLCD_voidWriteNumbersInBinary>:
}

void CLCD_voidWriteNumbersInBinary(uint_32 Copy_u32Number){

	sint_8 Counter = 0;
	CLCD_voidWriteString("0b");
    2334:	80 e6       	ldi	r24, 0x60	; 96
    2336:	90 e0       	ldi	r25, 0x00	; 0
    2338:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
			Copy_u32Number = Copy_u32Number/2;
			Local_u32Num--;
		}
	}*/

}
    233c:	08 95       	ret

0000233e <CLCD_voidSendCommand>:
	CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
	_delay_ms(1);
	CLCD_voidSendCommand(0X06);
}

void CLCD_voidSendCommand(uint_8 Copy_u8Command){
    233e:	0f 93       	push	r16
    2340:	1f 93       	push	r17
    2342:	18 2f       	mov	r17, r24
	DIO_voidSetPinValue(CLCD_CONTROL_PORT, CLCD_RS_PIN, Low);
    2344:	83 e0       	ldi	r24, 0x03	; 3
    2346:	66 e0       	ldi	r22, 0x06	; 6
    2348:	40 e0       	ldi	r20, 0x00	; 0
    234a:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
	DIO_voidSetPortValue(CLCD_DATA_PORT, Copy_u8Command); //Function Set
    234e:	82 e0       	ldi	r24, 0x02	; 2
    2350:	61 2f       	mov	r22, r17
    2352:	0e 94 98 0f 	call	0x1f30	; 0x1f30 <DIO_voidSetPortValue>
	DIO_voidSetPinValue(CLCD_CONTROL_PORT, CLCD_EN_PIN, High);
    2356:	83 e0       	ldi	r24, 0x03	; 3
    2358:	67 e0       	ldi	r22, 0x07	; 7
    235a:	41 e0       	ldi	r20, 0x01	; 1
    235c:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
    2360:	00 ed       	ldi	r16, 0xD0	; 208
    2362:	17 e0       	ldi	r17, 0x07	; 7
    2364:	c8 01       	movw	r24, r16
    2366:	01 97       	sbiw	r24, 0x01	; 1
    2368:	f1 f7       	brne	.-4      	; 0x2366 <CLCD_voidSendCommand+0x28>
	_delay_ms(1);
	DIO_voidSetPinValue(CLCD_CONTROL_PORT, CLCD_EN_PIN, Low);
    236a:	83 e0       	ldi	r24, 0x03	; 3
    236c:	67 e0       	ldi	r22, 0x07	; 7
    236e:	40 e0       	ldi	r20, 0x00	; 0
    2370:	0e 94 69 0e 	call	0x1cd2	; 0x1cd2 <DIO_voidSetPinValue>
    2374:	c8 01       	movw	r24, r16
    2376:	01 97       	sbiw	r24, 0x01	; 1
    2378:	f1 f7       	brne	.-4      	; 0x2376 <CLCD_voidSendCommand+0x38>
	_delay_ms(1);
}
    237a:	1f 91       	pop	r17
    237c:	0f 91       	pop	r16
    237e:	08 95       	ret

00002380 <CLCD_voidStoreCustomChar>:
		CLCD_voidGoto(1,4);
		CLCD_voidWriteData(Lower+'A'-10);
	}
}

void CLCD_voidStoreCustomChar(uint_8 Copy_u8CharAddress, uint_8 customChar[8]){
    2380:	0f 93       	push	r16
    2382:	1f 93       	push	r17
    2384:	cf 93       	push	r28
    2386:	df 93       	push	r29
    2388:	8b 01       	movw	r16, r22
	uint_8 Counter = 0;

		CLCD_voidSendCommand(0X40 + 0X08*Copy_u8CharAddress);
    238a:	88 0f       	add	r24, r24
    238c:	88 0f       	add	r24, r24
    238e:	88 0f       	add	r24, r24
    2390:	80 5c       	subi	r24, 0xC0	; 192
    2392:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
    2396:	c0 e0       	ldi	r28, 0x00	; 0
    2398:	d0 e0       	ldi	r29, 0x00	; 0

		for(Counter = 0; Counter < 8; Counter++){
			CLCD_voidWriteData(customChar[Counter]);
    239a:	f8 01       	movw	r30, r16
    239c:	ec 0f       	add	r30, r28
    239e:	fd 1f       	adc	r31, r29
    23a0:	80 81       	ld	r24, Z
    23a2:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
    23a6:	21 96       	adiw	r28, 0x01	; 1
void CLCD_voidStoreCustomChar(uint_8 Copy_u8CharAddress, uint_8 customChar[8]){
	uint_8 Counter = 0;

		CLCD_voidSendCommand(0X40 + 0X08*Copy_u8CharAddress);

		for(Counter = 0; Counter < 8; Counter++){
    23a8:	c8 30       	cpi	r28, 0x08	; 8
    23aa:	d1 05       	cpc	r29, r1
    23ac:	b1 f7       	brne	.-20     	; 0x239a <CLCD_voidStoreCustomChar+0x1a>
			CLCD_voidWriteData(customChar[Counter]);
		}

}
    23ae:	df 91       	pop	r29
    23b0:	cf 91       	pop	r28
    23b2:	1f 91       	pop	r17
    23b4:	0f 91       	pop	r16
    23b6:	08 95       	ret

000023b8 <CLCD_voidGoto>:
	}
}


void CLCD_voidGoto(uint_8 Copy_u8Row, uint_8 Copy_u8Coloum){
	Copy_u8Coloum--;
    23b8:	61 50       	subi	r22, 0x01	; 1
	switch(Copy_u8Row)
    23ba:	82 30       	cpi	r24, 0x02	; 2
    23bc:	79 f0       	breq	.+30     	; 0x23dc <CLCD_voidGoto+0x24>
    23be:	83 30       	cpi	r24, 0x03	; 3
    23c0:	18 f4       	brcc	.+6      	; 0x23c8 <CLCD_voidGoto+0x10>
    23c2:	81 30       	cpi	r24, 0x01	; 1
    23c4:	c9 f4       	brne	.+50     	; 0x23f8 <CLCD_voidGoto+0x40>
    23c6:	05 c0       	rjmp	.+10     	; 0x23d2 <CLCD_voidGoto+0x1a>
    23c8:	83 30       	cpi	r24, 0x03	; 3
    23ca:	69 f0       	breq	.+26     	; 0x23e6 <CLCD_voidGoto+0x2e>
    23cc:	84 30       	cpi	r24, 0x04	; 4
    23ce:	a1 f4       	brne	.+40     	; 0x23f8 <CLCD_voidGoto+0x40>
    23d0:	0f c0       	rjmp	.+30     	; 0x23f0 <CLCD_voidGoto+0x38>
	{
		case 1 : CLCD_voidSendCommand(0X80+Copy_u8Coloum); break;
    23d2:	86 2f       	mov	r24, r22
    23d4:	80 58       	subi	r24, 0x80	; 128
    23d6:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
    23da:	08 95       	ret
		case 2 : CLCD_voidSendCommand(0XC0+Copy_u8Coloum); break;
    23dc:	86 2f       	mov	r24, r22
    23de:	80 54       	subi	r24, 0x40	; 64
    23e0:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
    23e4:	08 95       	ret
		case 3 : CLCD_voidSendCommand(0x90+Copy_u8Coloum); break;
    23e6:	86 2f       	mov	r24, r22
    23e8:	80 57       	subi	r24, 0x70	; 112
    23ea:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
    23ee:	08 95       	ret
		case 4 : CLCD_voidSendCommand(0xD0+Copy_u8Coloum); break;
    23f0:	86 2f       	mov	r24, r22
    23f2:	80 53       	subi	r24, 0x30	; 48
    23f4:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
    23f8:	08 95       	ret

000023fa <CLCD_voidWriteNumbersInHexa>:
		}
	}

}*/

void CLCD_voidWriteNumbersInHexa(uint_32 Copy_u32Number){
    23fa:	ef 92       	push	r14
    23fc:	ff 92       	push	r15
    23fe:	0f 93       	push	r16
    2400:	1f 93       	push	r17
    2402:	7b 01       	movw	r14, r22
    2404:	8c 01       	movw	r16, r24
	uint_8 Upper = 0, Lower = 0;
	CLCD_voidWriteString("0X");
    2406:	83 e6       	ldi	r24, 0x63	; 99
    2408:	90 e0       	ldi	r25, 0x00	; 0
    240a:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>

	Upper = Copy_u32Number >> 4; //0b0000 0010
    240e:	d8 01       	movw	r26, r16
    2410:	c7 01       	movw	r24, r14
    2412:	68 94       	set
    2414:	13 f8       	bld	r1, 3
    2416:	b6 95       	lsr	r27
    2418:	a7 95       	ror	r26
    241a:	97 95       	ror	r25
    241c:	87 95       	ror	r24
    241e:	16 94       	lsr	r1
    2420:	d1 f7       	brne	.-12     	; 0x2416 <CLCD_voidWriteNumbersInHexa+0x1c>
    2422:	18 2f       	mov	r17, r24
	Lower = Copy_u32Number & 0X0F; //0b0000 0000
    2424:	0e 2d       	mov	r16, r14
    2426:	0f 70       	andi	r16, 0x0F	; 15

	if(Upper < 10){
    2428:	8a 30       	cpi	r24, 0x0A	; 10
    242a:	48 f4       	brcc	.+18     	; 0x243e <CLCD_voidWriteNumbersInHexa+0x44>
		CLCD_voidGoto(1,3);
    242c:	81 e0       	ldi	r24, 0x01	; 1
    242e:	63 e0       	ldi	r22, 0x03	; 3
    2430:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteData(Upper+'0');
    2434:	81 2f       	mov	r24, r17
    2436:	80 5d       	subi	r24, 0xD0	; 208
    2438:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
    243c:	08 c0       	rjmp	.+16     	; 0x244e <CLCD_voidWriteNumbersInHexa+0x54>
	}
	else{
		CLCD_voidGoto(1,3);
    243e:	81 e0       	ldi	r24, 0x01	; 1
    2440:	63 e0       	ldi	r22, 0x03	; 3
    2442:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteData(Upper+'A'-10);
    2446:	81 2f       	mov	r24, r17
    2448:	89 5c       	subi	r24, 0xC9	; 201
    244a:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
	}

	if(Lower < 10){
    244e:	0a 30       	cpi	r16, 0x0A	; 10
    2450:	48 f4       	brcc	.+18     	; 0x2464 <CLCD_voidWriteNumbersInHexa+0x6a>
		CLCD_voidGoto(1,4);
    2452:	81 e0       	ldi	r24, 0x01	; 1
    2454:	64 e0       	ldi	r22, 0x04	; 4
    2456:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteData(Lower+'0');
    245a:	80 2f       	mov	r24, r16
    245c:	80 5d       	subi	r24, 0xD0	; 208
    245e:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
    2462:	08 c0       	rjmp	.+16     	; 0x2474 <CLCD_voidWriteNumbersInHexa+0x7a>
	}
	else{
		CLCD_voidGoto(1,4);
    2464:	81 e0       	ldi	r24, 0x01	; 1
    2466:	64 e0       	ldi	r22, 0x04	; 4
    2468:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteData(Lower+'A'-10);
    246c:	80 2f       	mov	r24, r16
    246e:	89 5c       	subi	r24, 0xC9	; 201
    2470:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
	}
}
    2474:	1f 91       	pop	r17
    2476:	0f 91       	pop	r16
    2478:	ff 90       	pop	r15
    247a:	ef 90       	pop	r14
    247c:	08 95       	ret

0000247e <CLCD_voidWriteCustomChar>:
		for(Counter = 0; Counter < 8; Counter++){
			CLCD_voidWriteData(customChar[Counter]);
		}

}
void CLCD_voidWriteCustomChar(uint_8 Copy_u8CharAddress, uint_8 customChar[8], uint_8 copy_u8Line){
    247e:	ef 92       	push	r14
    2480:	ff 92       	push	r15
    2482:	0f 93       	push	r16
    2484:	1f 93       	push	r17
    2486:	cf 93       	push	r28
    2488:	df 93       	push	r29
    248a:	f8 2e       	mov	r15, r24
    248c:	8b 01       	movw	r16, r22
    248e:	e4 2e       	mov	r14, r20
	uint_8 Counter = 0;

	CLCD_voidSendCommand(0X40 + 0X08*Copy_u8CharAddress);
    2490:	88 0f       	add	r24, r24
    2492:	88 0f       	add	r24, r24
    2494:	88 0f       	add	r24, r24
    2496:	80 5c       	subi	r24, 0xC0	; 192
    2498:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
    249c:	c0 e0       	ldi	r28, 0x00	; 0
    249e:	d0 e0       	ldi	r29, 0x00	; 0

	for(Counter = 0; Counter < 8; Counter++){
		CLCD_voidWriteData(customChar[Counter]);
    24a0:	f8 01       	movw	r30, r16
    24a2:	ec 0f       	add	r30, r28
    24a4:	fd 1f       	adc	r31, r29
    24a6:	80 81       	ld	r24, Z
    24a8:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
    24ac:	21 96       	adiw	r28, 0x01	; 1
void CLCD_voidWriteCustomChar(uint_8 Copy_u8CharAddress, uint_8 customChar[8], uint_8 copy_u8Line){
	uint_8 Counter = 0;

	CLCD_voidSendCommand(0X40 + 0X08*Copy_u8CharAddress);

	for(Counter = 0; Counter < 8; Counter++){
    24ae:	c8 30       	cpi	r28, 0x08	; 8
    24b0:	d1 05       	cpc	r29, r1
    24b2:	b1 f7       	brne	.-20     	; 0x24a0 <CLCD_voidWriteCustomChar+0x22>
		CLCD_voidWriteData(customChar[Counter]);
	}

	CLCD_voidGoto(copy_u8Line,16-Copy_u8CharAddress);
    24b4:	60 e1       	ldi	r22, 0x10	; 16
    24b6:	6f 19       	sub	r22, r15
    24b8:	8e 2d       	mov	r24, r14
    24ba:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
	CLCD_voidWriteData(Copy_u8CharAddress);
    24be:	8f 2d       	mov	r24, r15
    24c0:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>

}
    24c4:	df 91       	pop	r29
    24c6:	cf 91       	pop	r28
    24c8:	1f 91       	pop	r17
    24ca:	0f 91       	pop	r16
    24cc:	ff 90       	pop	r15
    24ce:	ef 90       	pop	r14
    24d0:	08 95       	ret

000024d2 <CLCD_voidWriteArabicNames>:

void CLCD_voidWriteArabicNames(uint_8 Copy_u8Name[][8], uint_8 copy_u8CharNumbers, uint_8 copy_u8Line)
{
    24d2:	df 92       	push	r13
    24d4:	ef 92       	push	r14
    24d6:	ff 92       	push	r15
    24d8:	0f 93       	push	r16
    24da:	1f 93       	push	r17
    24dc:	cf 93       	push	r28
    24de:	df 93       	push	r29
    24e0:	7c 01       	movw	r14, r24
    24e2:	06 2f       	mov	r16, r22
    24e4:	d4 2e       	mov	r13, r20
	uint_8 Counter = 0;
	for(Counter = 0; Counter < copy_u8CharNumbers; Counter++)
    24e6:	66 23       	and	r22, r22
    24e8:	71 f0       	breq	.+28     	; 0x2506 <CLCD_voidWriteArabicNames+0x34>
    24ea:	10 e0       	ldi	r17, 0x00	; 0
    24ec:	c0 e0       	ldi	r28, 0x00	; 0
    24ee:	d0 e0       	ldi	r29, 0x00	; 0
	{
		CLCD_voidWriteCustomChar(Counter, Copy_u8Name[Counter], copy_u8Line);
    24f0:	b7 01       	movw	r22, r14
    24f2:	6c 0f       	add	r22, r28
    24f4:	7d 1f       	adc	r23, r29
    24f6:	81 2f       	mov	r24, r17
    24f8:	4d 2d       	mov	r20, r13
    24fa:	0e 94 3f 12 	call	0x247e	; 0x247e <CLCD_voidWriteCustomChar>
}

void CLCD_voidWriteArabicNames(uint_8 Copy_u8Name[][8], uint_8 copy_u8CharNumbers, uint_8 copy_u8Line)
{
	uint_8 Counter = 0;
	for(Counter = 0; Counter < copy_u8CharNumbers; Counter++)
    24fe:	1f 5f       	subi	r17, 0xFF	; 255
    2500:	28 96       	adiw	r28, 0x08	; 8
    2502:	10 17       	cp	r17, r16
    2504:	a8 f3       	brcs	.-22     	; 0x24f0 <CLCD_voidWriteArabicNames+0x1e>
	{
		CLCD_voidWriteCustomChar(Counter, Copy_u8Name[Counter], copy_u8Line);
	}

}
    2506:	df 91       	pop	r29
    2508:	cf 91       	pop	r28
    250a:	1f 91       	pop	r17
    250c:	0f 91       	pop	r16
    250e:	ff 90       	pop	r15
    2510:	ef 90       	pop	r14
    2512:	df 90       	pop	r13
    2514:	08 95       	ret

00002516 <CLCD_voidInit>:
/*-------------- Global Variable Definitions  ---------------*/

/*-------------- APIs Definitions ---------------*/
void CLCD_voidInit(void)
{
	DIO_voidSetPortDirection(CLCD_DATA_PORT, 0XFF);
    2516:	82 e0       	ldi	r24, 0x02	; 2
    2518:	6f ef       	ldi	r22, 0xFF	; 255
    251a:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <DIO_voidSetPortDirection>
	DIO_voidSetPinDirection(CLCD_CONTROL_PORT, CLCD_RS_PIN, Output);
    251e:	83 e0       	ldi	r24, 0x03	; 3
    2520:	66 e0       	ldi	r22, 0x06	; 6
    2522:	41 e0       	ldi	r20, 0x01	; 1
    2524:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(CLCD_CONTROL_PORT, CLCD_RW_PIN, Output);
    2528:	83 e0       	ldi	r24, 0x03	; 3
    252a:	61 e0       	ldi	r22, 0x01	; 1
    252c:	41 e0       	ldi	r20, 0x01	; 1
    252e:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(CLCD_CONTROL_PORT, CLCD_EN_PIN, Output);
    2532:	83 e0       	ldi	r24, 0x03	; 3
    2534:	67 e0       	ldi	r22, 0x07	; 7
    2536:	41 e0       	ldi	r20, 0x01	; 1
    2538:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
    253c:	24 ef       	ldi	r18, 0xF4	; 244
    253e:	31 e0       	ldi	r19, 0x01	; 1
    2540:	48 ec       	ldi	r20, 0xC8	; 200
    2542:	50 e0       	ldi	r21, 0x00	; 0
    2544:	ca 01       	movw	r24, r20
    2546:	01 97       	sbiw	r24, 0x01	; 1
    2548:	f1 f7       	brne	.-4      	; 0x2546 <CLCD_voidInit+0x30>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    254a:	21 50       	subi	r18, 0x01	; 1
    254c:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    254e:	d1 f7       	brne	.-12     	; 0x2544 <CLCD_voidInit+0x2e>

	_delay_ms(50);
	CLCD_voidSendCommand(CLCD_FUNCTION_SET);
    2550:	88 e3       	ldi	r24, 0x38	; 56
    2552:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
	CLCD_voidSendCommand(0X0C);
    2556:	8c e0       	ldi	r24, 0x0C	; 12
    2558:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
	CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    255c:	81 e0       	ldi	r24, 0x01	; 1
    255e:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
    2562:	80 ed       	ldi	r24, 0xD0	; 208
    2564:	97 e0       	ldi	r25, 0x07	; 7
    2566:	01 97       	sbiw	r24, 0x01	; 1
    2568:	f1 f7       	brne	.-4      	; 0x2566 <CLCD_voidInit+0x50>
	_delay_ms(1);
	CLCD_voidSendCommand(0X06);
    256a:	86 e0       	ldi	r24, 0x06	; 6
    256c:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
}
    2570:	08 95       	ret

00002572 <BUZZER_voidVariableSound>:


void BUZZER_voidVariableSound(uint_8 Copy_u8SoundValue){

	/* Set sound value from 1 to 100 */
	TIMER0_voidUpdateDutyCycle(Copy_u8SoundValue);
    2572:	90 e0       	ldi	r25, 0x00	; 0
    2574:	0e 94 b9 0b 	call	0x1772	; 0x1772 <TIMER0_voidUpdateDutyCycle>
	
}
    2578:	08 95       	ret

0000257a <BUZZER_voidSoundMode>:
	DIO_voidTogglePin(DIO_u8PORTA, DIO_PIN2);
}

void BUZZER_voidSoundMode(Buzzer_State_t State){
	
	switch(State){
    257a:	88 23       	and	r24, r24
    257c:	39 f0       	breq	.+14     	; 0x258c <BUZZER_voidSoundMode+0x12>
    257e:	81 30       	cpi	r24, 0x01	; 1
    2580:	49 f4       	brne	.+18     	; 0x2594 <BUZZER_voidSoundMode+0x1a>
		  
		case BUZZER_ON :
			/* Sound mode ---> on */		
			TIMER0_voidUpdateDutyCycle(BUZZER_MAX_SOUND);
    2582:	8f e5       	ldi	r24, 0x5F	; 95
    2584:	90 e0       	ldi	r25, 0x00	; 0
    2586:	0e 94 b9 0b 	call	0x1772	; 0x1772 <TIMER0_voidUpdateDutyCycle>
    258a:	08 95       	ret
		break;
		
		case BUZZER_OFF:  
			/* Sound mode ---> off */
			TIMER0_voidUpdateDutyCycle(BUZZER_SOUND_OFF);
    258c:	80 e0       	ldi	r24, 0x00	; 0
    258e:	90 e0       	ldi	r25, 0x00	; 0
    2590:	0e 94 b9 0b 	call	0x1772	; 0x1772 <TIMER0_voidUpdateDutyCycle>
    2594:	08 95       	ret

00002596 <BUZZER_voidToggle>:

}

void BUZZER_voidToggle(void)
{
	DIO_voidTogglePin(DIO_u8PORTA, DIO_PIN2);
    2596:	80 e0       	ldi	r24, 0x00	; 0
    2598:	62 e0       	ldi	r22, 0x02	; 2
    259a:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <DIO_voidTogglePin>
}
    259e:	08 95       	ret

000025a0 <BUZZER_voidInit>:
******************************************************************************/

void BUZZER_voidInit(void){

	/* Set PIN3 (OC0) PORT B as output */
	DIO_voidSetPinDirection(DIO_u8PORTA, DIO_PIN2, Output);
    25a0:	80 e0       	ldi	r24, 0x00	; 0
    25a2:	62 e0       	ldi	r22, 0x02	; 2
    25a4:	41 e0       	ldi	r20, 0x01	; 1
    25a6:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
	//TIMER0_voidInit(TIMER0_FAST_PWM_MODE, TIMER0_SCALER_8);
	
	/* Set timer0 output compare mode --> non inverting mode */
	//TIMER0_voidOutputCompareInit(TIMER0_OC0_NON_INVERTING_MODE);

}
    25aa:	08 95       	ret

000025ac <UART_Init>:
}


// Function to initialize UART communication
void UART_Init(unsigned int baud_rate) {
  unsigned int ubrr_value = F_CPU / (16UL * baud_rate) - 1;
    25ac:	9c 01       	movw	r18, r24
    25ae:	40 e0       	ldi	r20, 0x00	; 0
    25b0:	50 e0       	ldi	r21, 0x00	; 0
    25b2:	22 0f       	add	r18, r18
    25b4:	33 1f       	adc	r19, r19
    25b6:	44 1f       	adc	r20, r20
    25b8:	55 1f       	adc	r21, r21
    25ba:	22 0f       	add	r18, r18
    25bc:	33 1f       	adc	r19, r19
    25be:	44 1f       	adc	r20, r20
    25c0:	55 1f       	adc	r21, r21
    25c2:	22 0f       	add	r18, r18
    25c4:	33 1f       	adc	r19, r19
    25c6:	44 1f       	adc	r20, r20
    25c8:	55 1f       	adc	r21, r21
    25ca:	22 0f       	add	r18, r18
    25cc:	33 1f       	adc	r19, r19
    25ce:	44 1f       	adc	r20, r20
    25d0:	55 1f       	adc	r21, r21
    25d2:	60 e0       	ldi	r22, 0x00	; 0
    25d4:	72 e1       	ldi	r23, 0x12	; 18
    25d6:	8a e7       	ldi	r24, 0x7A	; 122
    25d8:	90 e0       	ldi	r25, 0x00	; 0
    25da:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
    25de:	21 50       	subi	r18, 0x01	; 1
    25e0:	30 40       	sbci	r19, 0x00	; 0

  // Set baud rate
  UBRRH = (unsigned char)(ubrr_value >> 8);
    25e2:	e0 e4       	ldi	r30, 0x40	; 64
    25e4:	f0 e0       	ldi	r31, 0x00	; 0
    25e6:	30 83       	st	Z, r19
  UBRRL = (unsigned char)ubrr_value;
    25e8:	29 b9       	out	0x09, r18	; 9

  // Enable receiver and transmitter
  UCSRB = (1 << RXEN) | (1 << TXEN);
    25ea:	88 e1       	ldi	r24, 0x18	; 24
    25ec:	8a b9       	out	0x0a, r24	; 10

  // Set frame format: 8 data bits, 1 stop bit
  UCSRC = (1 << URSEL) | (1 << UCSZ1) | (1 << UCSZ0);
    25ee:	86 e8       	ldi	r24, 0x86	; 134
    25f0:	80 83       	st	Z, r24
}
    25f2:	08 95       	ret

000025f4 <UART_TransmitChar>:

// Function to transmit a single character over UART
void UART_TransmitChar(unsigned char data) {
    25f4:	98 2f       	mov	r25, r24
  while (!(UCSRA & (1 << UDRE)))
    25f6:	eb e2       	ldi	r30, 0x2B	; 43
    25f8:	f0 e0       	ldi	r31, 0x00	; 0
    25fa:	80 81       	ld	r24, Z
    25fc:	85 ff       	sbrs	r24, 5
    25fe:	fd cf       	rjmp	.-6      	; 0x25fa <UART_TransmitChar+0x6>
    ;
  UDR = data;
    2600:	9c b9       	out	0x0c, r25	; 12
}
    2602:	08 95       	ret

00002604 <UART_ReceiveChar>:

// Function to receive a single character over UART
unsigned char UART_ReceiveChar() {
  while (!(UCSRA & (1 << RXC)));
    2604:	eb e2       	ldi	r30, 0x2B	; 43
    2606:	f0 e0       	ldi	r31, 0x00	; 0
    2608:	80 81       	ld	r24, Z
    260a:	88 23       	and	r24, r24
    260c:	ec f7       	brge	.-6      	; 0x2608 <UART_ReceiveChar+0x4>
  return UDR;
    260e:	8c b1       	in	r24, 0x0c	; 12
}
    2610:	08 95       	ret

00002612 <UART_ReceiveCharfrist>:

// Function to receive a single character over UART
unsigned char UART_ReceiveCharfrist() {
	uint_16 cou =0;
  while ((!(UCSRA & (1 << RXC)))  && (cou < 8000 ))
    2612:	8b b1       	in	r24, 0x0b	; 11
    2614:	88 23       	and	r24, r24
    2616:	6c f0       	brlt	.+26     	; 0x2632 <UART_ReceiveCharfrist+0x20>
    2618:	20 e0       	ldi	r18, 0x00	; 0
    261a:	30 e0       	ldi	r19, 0x00	; 0
    261c:	eb e2       	ldi	r30, 0x2B	; 43
    261e:	f0 e0       	ldi	r31, 0x00	; 0
    2620:	80 81       	ld	r24, Z
    2622:	88 23       	and	r24, r24
    2624:	34 f0       	brlt	.+12     	; 0x2632 <UART_ReceiveCharfrist+0x20>
  {
	  cou++;
    2626:	2f 5f       	subi	r18, 0xFF	; 255
    2628:	3f 4f       	sbci	r19, 0xFF	; 255
}

// Function to receive a single character over UART
unsigned char UART_ReceiveCharfrist() {
	uint_16 cou =0;
  while ((!(UCSRA & (1 << RXC)))  && (cou < 8000 ))
    262a:	8f e1       	ldi	r24, 0x1F	; 31
    262c:	20 34       	cpi	r18, 0x40	; 64
    262e:	38 07       	cpc	r19, r24
    2630:	b9 f7       	brne	.-18     	; 0x2620 <UART_ReceiveCharfrist+0xe>
  {
	  cou++;
  }
  return UDR;
    2632:	8c b1       	in	r24, 0x0c	; 12
}
    2634:	08 95       	ret

00002636 <transmitDataBlockOverBluetooth>:

// Function to transmit a block of data over Bluetooth
void transmitDataBlockOverBluetooth(uint8_t* data, uint8_t length) {
    2636:	ef 92       	push	r14
    2638:	ff 92       	push	r15
    263a:	0f 93       	push	r16
    263c:	1f 93       	push	r17
    263e:	cf 93       	push	r28
    2640:	df 93       	push	r29
    2642:	e6 2e       	mov	r14, r22
  for (uint8_t i = 0; i < length; i++) {
    2644:	66 23       	and	r22, r22
    2646:	81 f0       	breq	.+32     	; 0x2668 <transmitDataBlockOverBluetooth+0x32>
    2648:	f8 2e       	mov	r15, r24
    264a:	28 2f       	mov	r18, r24
    264c:	39 2f       	mov	r19, r25
    264e:	e9 01       	movw	r28, r18
    2650:	00 e2       	ldi	r16, 0x20	; 32
    2652:	1e e4       	ldi	r17, 0x4E	; 78
    UART_TransmitChar(data[i]);
    2654:	89 91       	ld	r24, Y+
    2656:	0e 94 fa 12 	call	0x25f4	; 0x25f4 <UART_TransmitChar>
    265a:	c8 01       	movw	r24, r16
    265c:	01 97       	sbiw	r24, 0x01	; 1
    265e:	f1 f7       	brne	.-4      	; 0x265c <transmitDataBlockOverBluetooth+0x26>
  return UDR;
}

// Function to transmit a block of data over Bluetooth
void transmitDataBlockOverBluetooth(uint8_t* data, uint8_t length) {
  for (uint8_t i = 0; i < length; i++) {
    2660:	9e 01       	movw	r18, r28
    2662:	2f 19       	sub	r18, r15
    2664:	2e 15       	cp	r18, r14
    2666:	b0 f3       	brcs	.-20     	; 0x2654 <transmitDataBlockOverBluetooth+0x1e>
    UART_TransmitChar(data[i]);
    _delay_ms(10); // Delay to allow time for transmission
  }
}
    2668:	df 91       	pop	r29
    266a:	cf 91       	pop	r28
    266c:	1f 91       	pop	r17
    266e:	0f 91       	pop	r16
    2670:	ff 90       	pop	r15
    2672:	ef 90       	pop	r14
    2674:	08 95       	ret

00002676 <receiveDataBlockOverBluetooth>:

// Function to receive a block of data over Bluetooth
void receiveDataBlockOverBluetooth(uint8_t* data, uint8_t length) {
    2676:	ef 92       	push	r14
    2678:	ff 92       	push	r15
    267a:	0f 93       	push	r16
    267c:	1f 93       	push	r17
    267e:	cf 93       	push	r28
    2680:	df 93       	push	r29
    2682:	e6 2e       	mov	r14, r22
  for (uint8_t i = 0; i < length; i++) {
    2684:	66 23       	and	r22, r22
    2686:	81 f0       	breq	.+32     	; 0x26a8 <receiveDataBlockOverBluetooth+0x32>
    2688:	f8 2e       	mov	r15, r24
    268a:	28 2f       	mov	r18, r24
    268c:	39 2f       	mov	r19, r25
    268e:	e9 01       	movw	r28, r18
    2690:	00 e2       	ldi	r16, 0x20	; 32
    2692:	1e e4       	ldi	r17, 0x4E	; 78
    data[i] = UART_ReceiveChar();
    2694:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
    2698:	89 93       	st	Y+, r24
    269a:	c8 01       	movw	r24, r16
    269c:	01 97       	sbiw	r24, 0x01	; 1
    269e:	f1 f7       	brne	.-4      	; 0x269c <receiveDataBlockOverBluetooth+0x26>
  }
}

// Function to receive a block of data over Bluetooth
void receiveDataBlockOverBluetooth(uint8_t* data, uint8_t length) {
  for (uint8_t i = 0; i < length; i++) {
    26a0:	9e 01       	movw	r18, r28
    26a2:	2f 19       	sub	r18, r15
    26a4:	2e 15       	cp	r18, r14
    26a6:	b0 f3       	brcs	.-20     	; 0x2694 <receiveDataBlockOverBluetooth+0x1e>
    data[i] = UART_ReceiveChar();
    _delay_ms(10); // Delay to allow time for reception
  }
}
    26a8:	df 91       	pop	r29
    26aa:	cf 91       	pop	r28
    26ac:	1f 91       	pop	r17
    26ae:	0f 91       	pop	r16
    26b0:	ff 90       	pop	r15
    26b2:	ef 90       	pop	r14
    26b4:	08 95       	ret

000026b6 <BLUETOOTH_voidSendString>:


void BLUETOOTH_voidSendString(uint_8 *Copy_u8Data){

	/* Send string data */
	UART_voidSendStringBlocking(Copy_u8Data);
    26b6:	0e 94 23 06 	call	0xc46	; 0xc46 <UART_voidSendStringBlocking>

}
    26ba:	08 95       	ret

000026bc <BLUETOOTH_voidSendChar>:


void BLUETOOTH_voidSendChar(uint_8 Copy_u8Data){

	/* Send data char */
	UART_voidSendByte(Copy_u8Data);
    26bc:	0e 94 14 06 	call	0xc28	; 0xc28 <UART_voidSendByte>

}
    26c0:	08 95       	ret

000026c2 <BLUETOOTH_voidWriteNumber>:

}



void BLUETOOTH_voidWriteNumber(uint_32 Copy_u32Number){
    26c2:	af 92       	push	r10
    26c4:	bf 92       	push	r11
    26c6:	cf 92       	push	r12
    26c8:	df 92       	push	r13
    26ca:	ef 92       	push	r14
    26cc:	ff 92       	push	r15
    26ce:	0f 93       	push	r16
    26d0:	1f 93       	push	r17
    26d2:	5b 01       	movw	r10, r22
    26d4:	6c 01       	movw	r12, r24

	uint_32 Local_u8Reversed = 1;

	if(0 == Copy_u32Number){
    26d6:	61 15       	cp	r22, r1
    26d8:	71 05       	cpc	r23, r1
    26da:	81 05       	cpc	r24, r1
    26dc:	91 05       	cpc	r25, r1
    26de:	59 f4       	brne	.+22     	; 0x26f6 <BLUETOOTH_voidWriteNumber+0x34>

		BLUETOOTH_voidSendChar('0');
    26e0:	80 e3       	ldi	r24, 0x30	; 48
    26e2:	0e 94 5e 13 	call	0x26bc	; 0x26bc <BLUETOOTH_voidSendChar>
    26e6:	51 c0       	rjmp	.+162    	; 0x278a <BLUETOOTH_voidWriteNumber+0xc8>
	while(0 != Copy_u32Number){

		Local_u8Reversed = ((Local_u8Reversed * 10) + (Copy_u32Number % 10));
		Copy_u32Number /= 10;
	}
	while(1 != Local_u8Reversed){
    26e8:	81 e0       	ldi	r24, 0x01	; 1
    26ea:	e8 16       	cp	r14, r24
    26ec:	f1 04       	cpc	r15, r1
    26ee:	01 05       	cpc	r16, r1
    26f0:	11 05       	cpc	r17, r1
    26f2:	59 f5       	brne	.+86     	; 0x274a <BLUETOOTH_voidWriteNumber+0x88>
    26f4:	4a c0       	rjmp	.+148    	; 0x278a <BLUETOOTH_voidWriteNumber+0xc8>
    26f6:	ee 24       	eor	r14, r14
    26f8:	ff 24       	eor	r15, r15
    26fa:	87 01       	movw	r16, r14
    26fc:	e3 94       	inc	r14

		BLUETOOTH_voidSendChar('0');
	}
	while(0 != Copy_u32Number){

		Local_u8Reversed = ((Local_u8Reversed * 10) + (Copy_u32Number % 10));
    26fe:	c8 01       	movw	r24, r16
    2700:	b7 01       	movw	r22, r14
    2702:	2a e0       	ldi	r18, 0x0A	; 10
    2704:	30 e0       	ldi	r19, 0x00	; 0
    2706:	40 e0       	ldi	r20, 0x00	; 0
    2708:	50 e0       	ldi	r21, 0x00	; 0
    270a:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <__mulsi3>
    270e:	7b 01       	movw	r14, r22
    2710:	8c 01       	movw	r16, r24
    2712:	c6 01       	movw	r24, r12
    2714:	b5 01       	movw	r22, r10
    2716:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
    271a:	e6 0e       	add	r14, r22
    271c:	f7 1e       	adc	r15, r23
    271e:	08 1f       	adc	r16, r24
    2720:	19 1f       	adc	r17, r25
		Copy_u32Number /= 10;
    2722:	c6 01       	movw	r24, r12
    2724:	b5 01       	movw	r22, r10
    2726:	2a e0       	ldi	r18, 0x0A	; 10
    2728:	30 e0       	ldi	r19, 0x00	; 0
    272a:	40 e0       	ldi	r20, 0x00	; 0
    272c:	50 e0       	ldi	r21, 0x00	; 0
    272e:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
    2732:	82 2f       	mov	r24, r18
    2734:	93 2f       	mov	r25, r19
    2736:	a4 2f       	mov	r26, r20
    2738:	b5 2f       	mov	r27, r21
    273a:	5c 01       	movw	r10, r24
    273c:	6d 01       	movw	r12, r26

	if(0 == Copy_u32Number){

		BLUETOOTH_voidSendChar('0');
	}
	while(0 != Copy_u32Number){
    273e:	a1 14       	cp	r10, r1
    2740:	b1 04       	cpc	r11, r1
    2742:	c1 04       	cpc	r12, r1
    2744:	d1 04       	cpc	r13, r1
    2746:	d9 f6       	brne	.-74     	; 0x26fe <BLUETOOTH_voidWriteNumber+0x3c>
    2748:	cf cf       	rjmp	.-98     	; 0x26e8 <BLUETOOTH_voidWriteNumber+0x26>
		Local_u8Reversed = ((Local_u8Reversed * 10) + (Copy_u32Number % 10));
		Copy_u32Number /= 10;
	}
	while(1 != Local_u8Reversed){

		BLUETOOTH_voidSendChar((Local_u8Reversed % 10 ) + 48);
    274a:	c8 01       	movw	r24, r16
    274c:	b7 01       	movw	r22, r14
    274e:	2a e0       	ldi	r18, 0x0A	; 10
    2750:	30 e0       	ldi	r19, 0x00	; 0
    2752:	40 e0       	ldi	r20, 0x00	; 0
    2754:	50 e0       	ldi	r21, 0x00	; 0
    2756:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
    275a:	86 2f       	mov	r24, r22
    275c:	80 5d       	subi	r24, 0xD0	; 208
    275e:	0e 94 5e 13 	call	0x26bc	; 0x26bc <BLUETOOTH_voidSendChar>
		Local_u8Reversed /= 10;
    2762:	c8 01       	movw	r24, r16
    2764:	b7 01       	movw	r22, r14
    2766:	2a e0       	ldi	r18, 0x0A	; 10
    2768:	30 e0       	ldi	r19, 0x00	; 0
    276a:	40 e0       	ldi	r20, 0x00	; 0
    276c:	50 e0       	ldi	r21, 0x00	; 0
    276e:	0e 94 a1 2d 	call	0x5b42	; 0x5b42 <__udivmodsi4>
    2772:	82 2f       	mov	r24, r18
    2774:	93 2f       	mov	r25, r19
    2776:	a4 2f       	mov	r26, r20
    2778:	b5 2f       	mov	r27, r21
    277a:	7c 01       	movw	r14, r24
    277c:	8d 01       	movw	r16, r26
	while(0 != Copy_u32Number){

		Local_u8Reversed = ((Local_u8Reversed * 10) + (Copy_u32Number % 10));
		Copy_u32Number /= 10;
	}
	while(1 != Local_u8Reversed){
    277e:	81 e0       	ldi	r24, 0x01	; 1
    2780:	e8 16       	cp	r14, r24
    2782:	f1 04       	cpc	r15, r1
    2784:	01 05       	cpc	r16, r1
    2786:	11 05       	cpc	r17, r1
    2788:	01 f7       	brne	.-64     	; 0x274a <BLUETOOTH_voidWriteNumber+0x88>

		BLUETOOTH_voidSendChar((Local_u8Reversed % 10 ) + 48);
		Local_u8Reversed /= 10;
	}

}
    278a:	1f 91       	pop	r17
    278c:	0f 91       	pop	r16
    278e:	ff 90       	pop	r15
    2790:	ef 90       	pop	r14
    2792:	df 90       	pop	r13
    2794:	cf 90       	pop	r12
    2796:	bf 90       	pop	r11
    2798:	af 90       	pop	r10
    279a:	08 95       	ret

0000279c <BLUETOOTH_u8Receive>:


uint_8 BLUETOOTH_u8Receive(void){

	/* Receive data char */
	return UART_u8ReceiveByte();
    279c:	0e 94 1c 06 	call	0xc38	; 0xc38 <UART_u8ReceiveByte>

}
    27a0:	08 95       	ret

000027a2 <BLUETOOTH_voidInit>:
******************************************************************************/

void BLUETOOTH_voidInit(void){

	/* RX Set the direction input for the Pin connected to the bluetooth */
	DIO_voidSetPinDirection(DIO_u8PORTD, DIO_PIN0, Input);
    27a2:	83 e0       	ldi	r24, 0x03	; 3
    27a4:	60 e0       	ldi	r22, 0x00	; 0
    27a6:	40 e0       	ldi	r20, 0x00	; 0
    27a8:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
	
	/* TX Set the direction output for the Pin connected to the bluetooth */
	DIO_voidSetPinDirection(DIO_u8PORTD, DIO_PIN1, Output);
    27ac:	83 e0       	ldi	r24, 0x03	; 3
    27ae:	61 e0       	ldi	r22, 0x01	; 1
    27b0:	41 e0       	ldi	r20, 0x01	; 1
    27b2:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>

	/* init uart protocol */
	UART_voidInit();
    27b6:	0e 94 01 06 	call	0xc02	; 0xc02 <UART_voidInit>

}
    27ba:	08 95       	ret

000027bc <APP_voidWelcom>:
	CLCD_voidStoreCustomChar(1, Body);
	CLCD_voidStoreCustomChar(2, DegMark);
}
/********************************************************************************** DONE**/
void APP_voidWelcom(void)
{
    27bc:	ef 92       	push	r14
    27be:	ff 92       	push	r15
    27c0:	1f 93       	push	r17
    27c2:	cf 93       	push	r28
    27c4:	df 93       	push	r29
	CLCD_voidGoto(1,6);
    27c6:	81 e0       	ldi	r24, 0x01	; 1
    27c8:	66 e0       	ldi	r22, 0x06	; 6
    27ca:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
	CLCD_voidWriteString("WELCOM");
    27ce:	86 e6       	ldi	r24, 0x66	; 102
    27d0:	90 e0       	ldi	r25, 0x00	; 0
    27d2:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    27d6:	10 e0       	ldi	r17, 0x00	; 0
	for(uint_8 Counter = 0; Counter < 5; Counter++)
	{
		CLCD_voidGoto(2,7);
		CLCD_voidWriteData(1);
		CLCD_voidGoto(2,10);
		CLCD_voidWriteData(1);
    27d8:	0f 2e       	mov	r0, r31
    27da:	f8 ee       	ldi	r31, 0xE8	; 232
    27dc:	ef 2e       	mov	r14, r31
    27de:	f3 e0       	ldi	r31, 0x03	; 3
    27e0:	ff 2e       	mov	r15, r31
    27e2:	f0 2d       	mov	r31, r0
    27e4:	c8 ec       	ldi	r28, 0xC8	; 200
    27e6:	d0 e0       	ldi	r29, 0x00	; 0
	CLCD_voidGoto(1,6);
	CLCD_voidWriteString("WELCOM");

	for(uint_8 Counter = 0; Counter < 5; Counter++)
	{
		CLCD_voidGoto(2,7);
    27e8:	82 e0       	ldi	r24, 0x02	; 2
    27ea:	67 e0       	ldi	r22, 0x07	; 7
    27ec:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteData(1);
    27f0:	81 e0       	ldi	r24, 0x01	; 1
    27f2:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
		CLCD_voidGoto(2,10);
    27f6:	82 e0       	ldi	r24, 0x02	; 2
    27f8:	6a e0       	ldi	r22, 0x0A	; 10
    27fa:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteData(1);
    27fe:	81 e0       	ldi	r24, 0x01	; 1
    2800:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
    2804:	97 01       	movw	r18, r14
    2806:	ce 01       	movw	r24, r28
    2808:	01 97       	sbiw	r24, 0x01	; 1
    280a:	f1 f7       	brne	.-4      	; 0x2808 <APP_voidWelcom+0x4c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    280c:	21 50       	subi	r18, 0x01	; 1
    280e:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2810:	d1 f7       	brne	.-12     	; 0x2806 <APP_voidWelcom+0x4a>
		_delay_ms(100);
		CLCD_voidGoto(2,7);
    2812:	82 e0       	ldi	r24, 0x02	; 2
    2814:	67 e0       	ldi	r22, 0x07	; 7
    2816:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteData(0);
    281a:	80 e0       	ldi	r24, 0x00	; 0
    281c:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
		CLCD_voidGoto(2,10);
    2820:	82 e0       	ldi	r24, 0x02	; 2
    2822:	6a e0       	ldi	r22, 0x0A	; 10
    2824:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteData(0);
    2828:	80 e0       	ldi	r24, 0x00	; 0
    282a:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
    282e:	97 01       	movw	r18, r14
    2830:	ce 01       	movw	r24, r28
    2832:	01 97       	sbiw	r24, 0x01	; 1
    2834:	f1 f7       	brne	.-4      	; 0x2832 <APP_voidWelcom+0x76>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2836:	21 50       	subi	r18, 0x01	; 1
    2838:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    283a:	d1 f7       	brne	.-12     	; 0x2830 <APP_voidWelcom+0x74>
void APP_voidWelcom(void)
{
	CLCD_voidGoto(1,6);
	CLCD_voidWriteString("WELCOM");

	for(uint_8 Counter = 0; Counter < 5; Counter++)
    283c:	1f 5f       	subi	r17, 0xFF	; 255
    283e:	15 30       	cpi	r17, 0x05	; 5
    2840:	99 f6       	brne	.-90     	; 0x27e8 <APP_voidWelcom+0x2c>
		CLCD_voidWriteData(0);
		CLCD_voidGoto(2,10);
		CLCD_voidWriteData(0);
		_delay_ms(100);
	}
	CLCD_voidSendCommand(0X01);
    2842:	81 e0       	ldi	r24, 0x01	; 1
    2844:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
}
    2848:	df 91       	pop	r29
    284a:	cf 91       	pop	r28
    284c:	1f 91       	pop	r17
    284e:	ff 90       	pop	r15
    2850:	ef 90       	pop	r14
    2852:	08 95       	ret

00002854 <APP_SystemState>:
		}
	}
	return Next;
}

static void APP_SystemState(void){
    2854:	ef 92       	push	r14
    2856:	ff 92       	push	r15
    2858:	0f 93       	push	r16
    285a:	1f 93       	push	r17
}
static void APP_TempToDigit(void){
	uint32_t reads_digital_value=0;
	uint16_t reads_analog_value=0;

	reads_digital_value=(ADC_u16ReadValue(CH_A0));
    285c:	80 e0       	ldi	r24, 0x00	; 0
    285e:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <ADC_u16ReadValue>
    2862:	7b 01       	movw	r14, r22
    2864:	8c 01       	movw	r16, r24

	reads_analog_value=(uint16_t)((((uint32_t)reads_digital_value*500UL)/256UL)+1U);

	CLCD_voidGoto(1,1);
    2866:	81 e0       	ldi	r24, 0x01	; 1
    2868:	61 e0       	ldi	r22, 0x01	; 1
    286a:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
	CLCD_voidWriteString("Temp = ");
    286e:	8d e6       	ldi	r24, 0x6D	; 109
    2870:	90 e0       	ldi	r25, 0x00	; 0
    2872:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
	CLCD_voidWriteNumbers(reads_analog_value);
    2876:	c8 01       	movw	r24, r16
    2878:	b7 01       	movw	r22, r14
    287a:	24 ef       	ldi	r18, 0xF4	; 244
    287c:	31 e0       	ldi	r19, 0x01	; 1
    287e:	40 e0       	ldi	r20, 0x00	; 0
    2880:	50 e0       	ldi	r21, 0x00	; 0
    2882:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <__mulsi3>
    2886:	67 2f       	mov	r22, r23
    2888:	78 2f       	mov	r23, r24
    288a:	89 2f       	mov	r24, r25
    288c:	99 27       	eor	r25, r25
    288e:	6f 5f       	subi	r22, 0xFF	; 255
    2890:	7f 4f       	sbci	r23, 0xFF	; 255
    2892:	80 e0       	ldi	r24, 0x00	; 0
    2894:	90 e0       	ldi	r25, 0x00	; 0
    2896:	0e 94 1c 11 	call	0x2238	; 0x2238 <CLCD_voidWriteNumbers>
	CLCD_voidWriteData(2);
    289a:	82 e0       	ldi	r24, 0x02	; 2
    289c:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
}

static void APP_SystemState(void){
	APP_TempToDigit();

}
    28a0:	1f 91       	pop	r17
    28a2:	0f 91       	pop	r16
    28a4:	ff 90       	pop	r15
    28a6:	ef 90       	pop	r14
    28a8:	08 95       	ret

000028aa <APP_FAST_PWM_TIMER1>:

}

void APP_FAST_PWM_TIMER1(void)
{
	TIMER1_voidSetICR1(40000U);//START 180 THIS IS OVERFLOW VALUE & NEED COMPARE VALUE2
    28aa:	80 e4       	ldi	r24, 0x40	; 64
    28ac:	9c e9       	ldi	r25, 0x9C	; 156
    28ae:	0e 94 22 09 	call	0x1244	; 0x1244 <TIMER1_voidSetICR1>
    28b2:	20 ed       	ldi	r18, 0xD0	; 208
    28b4:	37 e0       	ldi	r19, 0x07	; 7
    28b6:	48 ec       	ldi	r20, 0xC8	; 200
    28b8:	50 e0       	ldi	r21, 0x00	; 0
    28ba:	ca 01       	movw	r24, r20
    28bc:	01 97       	sbiw	r24, 0x01	; 1
    28be:	f1 f7       	brne	.-4      	; 0x28bc <APP_FAST_PWM_TIMER1+0x12>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    28c0:	21 50       	subi	r18, 0x01	; 1
    28c2:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    28c4:	d1 f7       	brne	.-12     	; 0x28ba <APP_FAST_PWM_TIMER1+0x10>
	_delay_ms(200);

}
    28c6:	08 95       	ret

000028c8 <APP_FAST_PWM3_TIMER1>:
	_delay_ms(200);
}

void APP_FAST_PWM3_TIMER1(void)
{
	TIMER1_voidSetICR1(40000U);
    28c8:	80 e4       	ldi	r24, 0x40	; 64
    28ca:	9c e9       	ldi	r25, 0x9C	; 156
    28cc:	0e 94 22 09 	call	0x1244	; 0x1244 <TIMER1_voidSetICR1>
	TIMER1_voidSetOCR1A(2000U);
    28d0:	80 ed       	ldi	r24, 0xD0	; 208
    28d2:	97 e0       	ldi	r25, 0x07	; 7
    28d4:	0e 94 1c 09 	call	0x1238	; 0x1238 <TIMER1_voidSetOCR1A>
    28d8:	20 ed       	ldi	r18, 0xD0	; 208
    28da:	37 e0       	ldi	r19, 0x07	; 7
    28dc:	48 ec       	ldi	r20, 0xC8	; 200
    28de:	50 e0       	ldi	r21, 0x00	; 0
    28e0:	ca 01       	movw	r24, r20
    28e2:	01 97       	sbiw	r24, 0x01	; 1
    28e4:	f1 f7       	brne	.-4      	; 0x28e2 <APP_FAST_PWM3_TIMER1+0x1a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    28e6:	21 50       	subi	r18, 0x01	; 1
    28e8:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    28ea:	d1 f7       	brne	.-12     	; 0x28e0 <APP_FAST_PWM3_TIMER1+0x18>
	_delay_ms(200);
	/* 2000us Ton to get angle zero */
	TIMER1_voidSetOCR1A(4000U);
    28ec:	80 ea       	ldi	r24, 0xA0	; 160
    28ee:	9f e0       	ldi	r25, 0x0F	; 15
    28f0:	0e 94 1c 09 	call	0x1238	; 0x1238 <TIMER1_voidSetOCR1A>
    28f4:	20 ed       	ldi	r18, 0xD0	; 208
    28f6:	37 e0       	ldi	r19, 0x07	; 7
    28f8:	48 ec       	ldi	r20, 0xC8	; 200
    28fa:	50 e0       	ldi	r21, 0x00	; 0
    28fc:	ca 01       	movw	r24, r20
    28fe:	01 97       	sbiw	r24, 0x01	; 1
    2900:	f1 f7       	brne	.-4      	; 0x28fe <APP_FAST_PWM3_TIMER1+0x36>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2902:	21 50       	subi	r18, 0x01	; 1
    2904:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2906:	d1 f7       	brne	.-12     	; 0x28fc <APP_FAST_PWM3_TIMER1+0x34>
	_delay_ms(200);

}
    2908:	08 95       	ret

0000290a <APP_FAST_PWM2_TIMER1>:
	TIMER1_voidSetICR1(0);
}

void APP_FAST_PWM2_TIMER1(void){

	TIMER1_voidSetOCR1A(2000U);
    290a:	80 ed       	ldi	r24, 0xD0	; 208
    290c:	97 e0       	ldi	r25, 0x07	; 7
    290e:	0e 94 1c 09 	call	0x1238	; 0x1238 <TIMER1_voidSetOCR1A>
    2912:	20 ed       	ldi	r18, 0xD0	; 208
    2914:	37 e0       	ldi	r19, 0x07	; 7
    2916:	48 ec       	ldi	r20, 0xC8	; 200
    2918:	50 e0       	ldi	r21, 0x00	; 0
    291a:	ca 01       	movw	r24, r20
    291c:	01 97       	sbiw	r24, 0x01	; 1
    291e:	f1 f7       	brne	.-4      	; 0x291c <APP_FAST_PWM2_TIMER1+0x12>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2920:	21 50       	subi	r18, 0x01	; 1
    2922:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2924:	d1 f7       	brne	.-12     	; 0x291a <APP_FAST_PWM2_TIMER1+0x10>
	_delay_ms(200);
	/* 2000us Ton to get angle zero */
	TIMER1_voidSetOCR1A(4000U);
    2926:	80 ea       	ldi	r24, 0xA0	; 160
    2928:	9f e0       	ldi	r25, 0x0F	; 15
    292a:	0e 94 1c 09 	call	0x1238	; 0x1238 <TIMER1_voidSetOCR1A>
    292e:	20 ed       	ldi	r18, 0xD0	; 208
    2930:	37 e0       	ldi	r19, 0x07	; 7
    2932:	48 ec       	ldi	r20, 0xC8	; 200
    2934:	50 e0       	ldi	r21, 0x00	; 0
    2936:	ca 01       	movw	r24, r20
    2938:	01 97       	sbiw	r24, 0x01	; 1
    293a:	f1 f7       	brne	.-4      	; 0x2938 <APP_FAST_PWM2_TIMER1+0x2e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    293c:	21 50       	subi	r18, 0x01	; 1
    293e:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2940:	d1 f7       	brne	.-12     	; 0x2936 <APP_FAST_PWM2_TIMER1+0x2c>
	_delay_ms(200);
}
    2942:	08 95       	ret

00002944 <APP_SERVO_INTILIZE>:
		Motor_void_stop();
	}

}
void APP_SERVO_INTILIZE(void){
	SERVO_voidInit();
    2944:	0e 94 dc 0f 	call	0x1fb8	; 0x1fb8 <SERVO_voidInit>

	TIMER1_voidSetICR1(0);
    2948:	80 e0       	ldi	r24, 0x00	; 0
    294a:	90 e0       	ldi	r25, 0x00	; 0
    294c:	0e 94 22 09 	call	0x1244	; 0x1244 <TIMER1_voidSetICR1>
}
    2950:	08 95       	ret

00002952 <APP_TEMP_MOTOR>:
void APP_TEMP_MOTOR(void){
	uint8_t Count_Tmperture=0;
	uint32_t reads_digital_value=0;
	uint16_t reads_analog_value=0;

	reads_digital_value=(ADC_u16ReadValue(CH_A0));
    2952:	80 e0       	ldi	r24, 0x00	; 0
    2954:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <ADC_u16ReadValue>

	reads_analog_value=(uint16_t)((((uint32_t)reads_digital_value*500UL)/256UL)+1U);
    2958:	24 ef       	ldi	r18, 0xF4	; 244
    295a:	31 e0       	ldi	r19, 0x01	; 1
    295c:	40 e0       	ldi	r20, 0x00	; 0
    295e:	50 e0       	ldi	r21, 0x00	; 0
    2960:	0e 94 5b 2d 	call	0x5ab6	; 0x5ab6 <__mulsi3>
    2964:	67 2f       	mov	r22, r23
    2966:	78 2f       	mov	r23, r24
    2968:	89 2f       	mov	r24, r25
    296a:	99 27       	eor	r25, r25
    296c:	6f 5f       	subi	r22, 0xFF	; 255
    296e:	7f 4f       	sbci	r23, 0xFF	; 255
	if(reads_analog_value>21){
    2970:	66 31       	cpi	r22, 0x16	; 22
    2972:	71 05       	cpc	r23, r1
    2974:	38 f0       	brcs	.+14     	; 0x2984 <APP_TEMP_MOTOR+0x32>
		Count_Tmperture=(uint8_t)reads_analog_value;
		Count_Tmperture++;
		if(Count_Tmperture>=28 && Count_Tmperture<50){
    2976:	86 2f       	mov	r24, r22
    2978:	8b 51       	subi	r24, 0x1B	; 27
    297a:	86 31       	cpi	r24, 0x16	; 22
    297c:	28 f4       	brcc	.+10     	; 0x2988 <APP_TEMP_MOTOR+0x36>
			Motor_void_ck();
    297e:	0e 94 39 10 	call	0x2072	; 0x2072 <Motor_void_ck>
    2982:	08 95       	ret
		}
	}
	else if(reads_analog_value<=21){
		reads_analog_value=0;
		Count_Tmperture=0;
		Motor_void_stop();
    2984:	0e 94 33 10 	call	0x2066	; 0x2066 <Motor_void_stop>
    2988:	08 95       	ret

0000298a <APP_HomePageMode>:
		}
	}
	return Next;
}

static state APP_HomePageMode(Login_t Copy_LoginType){
    298a:	df 93       	push	r29
    298c:	cf 93       	push	r28
    298e:	0f 92       	push	r0
    2990:	cd b7       	in	r28, 0x3d	; 61
    2992:	de b7       	in	r29, 0x3e	; 62
    2994:	98 2f       	mov	r25, r24
	volatile uint_8 Read = 1;
    2996:	81 e0       	ldi	r24, 0x01	; 1
    2998:	89 83       	std	Y+1, r24	; 0x01
	uint_8 Count = 1;

	switch(Copy_LoginType)
    299a:	91 30       	cpi	r25, 0x01	; 1
    299c:	09 f4       	brne	.+2      	; 0x29a0 <APP_HomePageMode+0x16>
    299e:	5f c0       	rjmp	.+190    	; 0x2a5e <APP_HomePageMode+0xd4>
    29a0:	91 30       	cpi	r25, 0x01	; 1
    29a2:	08 f4       	brcc	.+2      	; 0x29a6 <APP_HomePageMode+0x1c>
    29a4:	8d c0       	rjmp	.+282    	; 0x2ac0 <APP_HomePageMode+0x136>
    29a6:	92 30       	cpi	r25, 0x02	; 2
    29a8:	09 f0       	breq	.+2      	; 0x29ac <APP_HomePageMode+0x22>
    29aa:	d6 c0       	rjmp	.+428    	; 0x2b58 <APP_HomePageMode+0x1ce>
	{
	case Admin :
		transmitDataBlockOverBluetooth("[1] Control\n",13);
    29ac:	85 e7       	ldi	r24, 0x75	; 117
    29ae:	90 e0       	ldi	r25, 0x00	; 0
    29b0:	6d e0       	ldi	r22, 0x0D	; 13
    29b2:	70 e0       	ldi	r23, 0x00	; 0
    29b4:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] Status\n",12);
    29b8:	82 e8       	ldi	r24, 0x82	; 130
    29ba:	90 e0       	ldi	r25, 0x00	; 0
    29bc:	6c e0       	ldi	r22, 0x0C	; 12
    29be:	70 e0       	ldi	r23, 0x00	; 0
    29c0:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[3] Add User\n",14);
    29c4:	8e e8       	ldi	r24, 0x8E	; 142
    29c6:	90 e0       	ldi	r25, 0x00	; 0
    29c8:	6e e0       	ldi	r22, 0x0E	; 14
    29ca:	70 e0       	ldi	r23, 0x00	; 0
    29cc:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[4] Remove User\n",17);
    29d0:	8c e9       	ldi	r24, 0x9C	; 156
    29d2:	90 e0       	ldi	r25, 0x00	; 0
    29d4:	61 e1       	ldi	r22, 0x11	; 17
    29d6:	70 e0       	ldi	r23, 0x00	; 0
    29d8:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[5] Change Password\n",21);
    29dc:	8d ea       	ldi	r24, 0xAD	; 173
    29de:	90 e0       	ldi	r25, 0x00	; 0
    29e0:	65 e1       	ldi	r22, 0x15	; 21
    29e2:	70 e0       	ldi	r23, 0x00	; 0
    29e4:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[6] Logout\n",12);
    29e8:	82 ec       	ldi	r24, 0xC2	; 194
    29ea:	90 e0       	ldi	r25, 0x00	; 0
    29ec:	6c e0       	ldi	r22, 0x0C	; 12
    29ee:	70 e0       	ldi	r23, 0x00	; 0
    29f0:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
			APP_SystemState();
    29f4:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
			APP_TEMP_MOTOR();
    29f8:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
			Read = UART_ReceiveCharfrist();
    29fc:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    2a00:	89 83       	std	Y+1, r24	; 0x01
			switch (Read) {
    2a02:	89 81       	ldd	r24, Y+1	; 0x01
    2a04:	83 33       	cpi	r24, 0x33	; 51
    2a06:	b1 f0       	breq	.+44     	; 0x2a34 <APP_HomePageMode+0xaa>
    2a08:	84 33       	cpi	r24, 0x34	; 52
    2a0a:	28 f4       	brcc	.+10     	; 0x2a16 <APP_HomePageMode+0x8c>
    2a0c:	81 33       	cpi	r24, 0x31	; 49
    2a0e:	51 f0       	breq	.+20     	; 0x2a24 <APP_HomePageMode+0x9a>
    2a10:	82 33       	cpi	r24, 0x32	; 50
    2a12:	81 f7       	brne	.-32     	; 0x29f4 <APP_HomePageMode+0x6a>
    2a14:	0b c0       	rjmp	.+22     	; 0x2a2c <APP_HomePageMode+0xa2>
    2a16:	85 33       	cpi	r24, 0x35	; 53
    2a18:	a9 f0       	breq	.+42     	; 0x2a44 <APP_HomePageMode+0xba>
    2a1a:	85 33       	cpi	r24, 0x35	; 53
    2a1c:	78 f0       	brcs	.+30     	; 0x2a3c <APP_HomePageMode+0xb2>
    2a1e:	86 33       	cpi	r24, 0x36	; 54
    2a20:	49 f7       	brne	.-46     	; 0x29f4 <APP_HomePageMode+0x6a>
    2a22:	14 c0       	rjmp	.+40     	; 0x2a4c <APP_HomePageMode+0xc2>
			case '1':
				Count = 0;
				Next =RSt5;
    2a24:	8a e1       	ldi	r24, 0x1A	; 26
    2a26:	80 93 06 08 	sts	0x0806, r24
    2a2a:	96 c0       	rjmp	.+300    	; 0x2b58 <APP_HomePageMode+0x1ce>
				break;
			case '2':
				Count = 0;
				Next =RSt6;
    2a2c:	8b e1       	ldi	r24, 0x1B	; 27
    2a2e:	80 93 06 08 	sts	0x0806, r24
    2a32:	92 c0       	rjmp	.+292    	; 0x2b58 <APP_HomePageMode+0x1ce>
				break;
			case '3':
				Count = 0;
				Next =RSt7;
    2a34:	8c e1       	ldi	r24, 0x1C	; 28
    2a36:	80 93 06 08 	sts	0x0806, r24
    2a3a:	8e c0       	rjmp	.+284    	; 0x2b58 <APP_HomePageMode+0x1ce>
				break;
			case '4':
				Count = 0;
				Next =RSt8;
    2a3c:	8d e1       	ldi	r24, 0x1D	; 29
    2a3e:	80 93 06 08 	sts	0x0806, r24
    2a42:	8a c0       	rjmp	.+276    	; 0x2b58 <APP_HomePageMode+0x1ce>
				break;
			case '5':
				Count = 0;
				Next =RSt9;
    2a44:	8e e1       	ldi	r24, 0x1E	; 30
    2a46:	80 93 06 08 	sts	0x0806, r24
    2a4a:	86 c0       	rjmp	.+268    	; 0x2b58 <APP_HomePageMode+0x1ce>
				break;
			case '6':
				CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2a4c:	81 e0       	ldi	r24, 0x01	; 1
    2a4e:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
				Count = 0;
				MotorFlag = 0;
    2a52:	10 92 f2 07 	sts	0x07F2, r1
				Next =RSt0;
    2a56:	85 e1       	ldi	r24, 0x15	; 21
    2a58:	80 93 06 08 	sts	0x0806, r24
    2a5c:	7d c0       	rjmp	.+250    	; 0x2b58 <APP_HomePageMode+0x1ce>
			}
		}
		break;

	case User_Remote :
		transmitDataBlockOverBluetooth("[1] Control\n",13);
    2a5e:	85 e7       	ldi	r24, 0x75	; 117
    2a60:	90 e0       	ldi	r25, 0x00	; 0
    2a62:	6d e0       	ldi	r22, 0x0D	; 13
    2a64:	70 e0       	ldi	r23, 0x00	; 0
    2a66:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] Status\n",12);
    2a6a:	82 e8       	ldi	r24, 0x82	; 130
    2a6c:	90 e0       	ldi	r25, 0x00	; 0
    2a6e:	6c e0       	ldi	r22, 0x0C	; 12
    2a70:	70 e0       	ldi	r23, 0x00	; 0
    2a72:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[3] Logout\n",12);
    2a76:	8e ec       	ldi	r24, 0xCE	; 206
    2a78:	90 e0       	ldi	r25, 0x00	; 0
    2a7a:	6c e0       	ldi	r22, 0x0C	; 12
    2a7c:	70 e0       	ldi	r23, 0x00	; 0
    2a7e:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
			APP_SystemState();
    2a82:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
			APP_TEMP_MOTOR();
    2a86:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
			Read = UART_ReceiveCharfrist();
    2a8a:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    2a8e:	89 83       	std	Y+1, r24	; 0x01
			switch (Read) {
    2a90:	89 81       	ldd	r24, Y+1	; 0x01
    2a92:	82 33       	cpi	r24, 0x32	; 50
    2a94:	41 f0       	breq	.+16     	; 0x2aa6 <APP_HomePageMode+0x11c>
    2a96:	83 33       	cpi	r24, 0x33	; 51
    2a98:	51 f0       	breq	.+20     	; 0x2aae <APP_HomePageMode+0x124>
    2a9a:	81 33       	cpi	r24, 0x31	; 49
    2a9c:	91 f7       	brne	.-28     	; 0x2a82 <APP_HomePageMode+0xf8>
			case '1':
				Count = 0;
				Next =RSt10;
    2a9e:	8f e1       	ldi	r24, 0x1F	; 31
    2aa0:	80 93 06 08 	sts	0x0806, r24
    2aa4:	59 c0       	rjmp	.+178    	; 0x2b58 <APP_HomePageMode+0x1ce>
				break;
			case '2':
				Count = 0;
				Next =RSt11;
    2aa6:	80 e2       	ldi	r24, 0x20	; 32
    2aa8:	80 93 06 08 	sts	0x0806, r24
    2aac:	55 c0       	rjmp	.+170    	; 0x2b58 <APP_HomePageMode+0x1ce>
				break;
			case '3':
				CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2aae:	81 e0       	ldi	r24, 0x01	; 1
    2ab0:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
				MotorFlag = 0;
    2ab4:	10 92 f2 07 	sts	0x07F2, r1
				Count = 0;
				Next =RSt0;
    2ab8:	85 e1       	ldi	r24, 0x15	; 21
    2aba:	80 93 06 08 	sts	0x0806, r24
    2abe:	4c c0       	rjmp	.+152    	; 0x2b58 <APP_HomePageMode+0x1ce>
			}
		}
		break;

	case User_Keypad :
		CLCD_voidGoto(1,1);
    2ac0:	81 e0       	ldi	r24, 0x01	; 1
    2ac2:	61 e0       	ldi	r22, 0x01	; 1
    2ac4:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[1]CONTROL");
    2ac8:	8a ed       	ldi	r24, 0xDA	; 218
    2aca:	90 e0       	ldi	r25, 0x00	; 0
    2acc:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    2ad0:	82 e0       	ldi	r24, 0x02	; 2
    2ad2:	61 e0       	ldi	r22, 0x01	; 1
    2ad4:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[2]STATUS");
    2ad8:	85 ee       	ldi	r24, 0xE5	; 229
    2ada:	90 e0       	ldi	r25, 0x00	; 0
    2adc:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(3,1);
    2ae0:	83 e0       	ldi	r24, 0x03	; 3
    2ae2:	61 e0       	ldi	r22, 0x01	; 1
    2ae4:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[3]LOGOUT");
    2ae8:	8f ee       	ldi	r24, 0xEF	; 239
    2aea:	90 e0       	ldi	r25, 0x00	; 0
    2aec:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>

		switch(Local_u8Key)
    2af0:	80 91 fb 07 	lds	r24, 0x07FB
    2af4:	83 33       	cpi	r24, 0x33	; 51
    2af6:	d1 f0       	breq	.+52     	; 0x2b2c <APP_HomePageMode+0x1a2>
    2af8:	84 33       	cpi	r24, 0x34	; 52
    2afa:	28 f4       	brcc	.+10     	; 0x2b06 <APP_HomePageMode+0x17c>
    2afc:	81 33       	cpi	r24, 0x31	; 49
    2afe:	41 f0       	breq	.+16     	; 0x2b10 <APP_HomePageMode+0x186>
    2b00:	82 33       	cpi	r24, 0x32	; 50
    2b02:	51 f5       	brne	.+84     	; 0x2b58 <APP_HomePageMode+0x1ce>
    2b04:	0c c0       	rjmp	.+24     	; 0x2b1e <APP_HomePageMode+0x194>
    2b06:	83 34       	cpi	r24, 0x43	; 67
    2b08:	09 f1       	breq	.+66     	; 0x2b4c <APP_HomePageMode+0x1c2>
    2b0a:	82 35       	cpi	r24, 0x52	; 82
    2b0c:	29 f5       	brne	.+74     	; 0x2b58 <APP_HomePageMode+0x1ce>
    2b0e:	17 c0       	rjmp	.+46     	; 0x2b3e <APP_HomePageMode+0x1b4>
		{
		case '1' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2b10:	81 e0       	ldi	r24, 0x01	; 1
    2b12:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt3;
    2b16:	83 e0       	ldi	r24, 0x03	; 3
    2b18:	80 93 06 08 	sts	0x0806, r24
    2b1c:	1d c0       	rjmp	.+58     	; 0x2b58 <APP_HomePageMode+0x1ce>
			break;
		case '2' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2b1e:	81 e0       	ldi	r24, 0x01	; 1
    2b20:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt2;
    2b24:	82 e0       	ldi	r24, 0x02	; 2
    2b26:	80 93 06 08 	sts	0x0806, r24
    2b2a:	16 c0       	rjmp	.+44     	; 0x2b58 <APP_HomePageMode+0x1ce>
			break;
		case '3' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2b2c:	81 e0       	ldi	r24, 0x01	; 1
    2b2e:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			MotorFlag = 0;
    2b32:	10 92 f2 07 	sts	0x07F2, r1
			Next = RSt0;
    2b36:	85 e1       	ldi	r24, 0x15	; 21
    2b38:	80 93 06 08 	sts	0x0806, r24
    2b3c:	0d c0       	rjmp	.+26     	; 0x2b58 <APP_HomePageMode+0x1ce>
			break;
		case 'R' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2b3e:	81 e0       	ldi	r24, 0x01	; 1
    2b40:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    2b44:	81 e0       	ldi	r24, 0x01	; 1
    2b46:	80 93 06 08 	sts	0x0806, r24
    2b4a:	06 c0       	rjmp	.+12     	; 0x2b58 <APP_HomePageMode+0x1ce>
			break;

		case 'C' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2b4c:	81 e0       	ldi	r24, 0x01	; 1
    2b4e:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    2b52:	81 e0       	ldi	r24, 0x01	; 1
    2b54:	80 93 06 08 	sts	0x0806, r24
		break;
	}

	return Next;

}
    2b58:	80 91 06 08 	lds	r24, 0x0806
    2b5c:	0f 90       	pop	r0
    2b5e:	cf 91       	pop	r28
    2b60:	df 91       	pop	r29
    2b62:	08 95       	ret

00002b64 <APP_ControlMenu>:

static state APP_ControlMenu(Login_t Copy_LoginType){
    2b64:	df 93       	push	r29
    2b66:	cf 93       	push	r28
    2b68:	0f 92       	push	r0
    2b6a:	cd b7       	in	r28, 0x3d	; 61
    2b6c:	de b7       	in	r29, 0x3e	; 62
    2b6e:	98 2f       	mov	r25, r24
	volatile uint_8 Read = 1;
    2b70:	81 e0       	ldi	r24, 0x01	; 1
    2b72:	89 83       	std	Y+1, r24	; 0x01
	uint_8 Count = 1;
	switch(Copy_LoginType)
    2b74:	91 30       	cpi	r25, 0x01	; 1
    2b76:	09 f4       	brne	.+2      	; 0x2b7a <APP_ControlMenu+0x16>
    2b78:	4e c0       	rjmp	.+156    	; 0x2c16 <APP_ControlMenu+0xb2>
    2b7a:	91 30       	cpi	r25, 0x01	; 1
    2b7c:	08 f4       	brcc	.+2      	; 0x2b80 <APP_ControlMenu+0x1c>
    2b7e:	87 c0       	rjmp	.+270    	; 0x2c8e <APP_ControlMenu+0x12a>
    2b80:	92 30       	cpi	r25, 0x02	; 2
    2b82:	09 f0       	breq	.+2      	; 0x2b86 <APP_ControlMenu+0x22>
    2b84:	ce c0       	rjmp	.+412    	; 0x2d22 <APP_ControlMenu+0x1be>
	{
	case Admin :
		transmitDataBlockOverBluetooth("[1] ROOMS\n",11);
    2b86:	89 ef       	ldi	r24, 0xF9	; 249
    2b88:	90 e0       	ldi	r25, 0x00	; 0
    2b8a:	6b e0       	ldi	r22, 0x0B	; 11
    2b8c:	70 e0       	ldi	r23, 0x00	; 0
    2b8e:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] DIMMIR\n",12);
    2b92:	84 e0       	ldi	r24, 0x04	; 4
    2b94:	91 e0       	ldi	r25, 0x01	; 1
    2b96:	6c e0       	ldi	r22, 0x0C	; 12
    2b98:	70 e0       	ldi	r23, 0x00	; 0
    2b9a:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[3] AC\n",8);
    2b9e:	80 e1       	ldi	r24, 0x10	; 16
    2ba0:	91 e0       	ldi	r25, 0x01	; 1
    2ba2:	68 e0       	ldi	r22, 0x08	; 8
    2ba4:	70 e0       	ldi	r23, 0x00	; 0
    2ba6:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[4] DOOR\n",10);
    2baa:	88 e1       	ldi	r24, 0x18	; 24
    2bac:	91 e0       	ldi	r25, 0x01	; 1
    2bae:	6a e0       	ldi	r22, 0x0A	; 10
    2bb0:	70 e0       	ldi	r23, 0x00	; 0
    2bb2:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		while(Count){
			APP_SystemState();
    2bb6:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
			APP_TEMP_MOTOR();
    2bba:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
			Read = UART_ReceiveCharfrist();
    2bbe:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    2bc2:	89 83       	std	Y+1, r24	; 0x01

			switch (Read) {
    2bc4:	89 81       	ldd	r24, Y+1	; 0x01
    2bc6:	82 33       	cpi	r24, 0x32	; 50
    2bc8:	91 f0       	breq	.+36     	; 0x2bee <APP_ControlMenu+0x8a>
    2bca:	83 33       	cpi	r24, 0x33	; 51
    2bcc:	28 f4       	brcc	.+10     	; 0x2bd8 <APP_ControlMenu+0x74>
    2bce:	80 33       	cpi	r24, 0x30	; 48
    2bd0:	d1 f0       	breq	.+52     	; 0x2c06 <APP_ControlMenu+0xa2>
    2bd2:	81 33       	cpi	r24, 0x31	; 49
    2bd4:	81 f7       	brne	.-32     	; 0x2bb6 <APP_ControlMenu+0x52>
    2bd6:	07 c0       	rjmp	.+14     	; 0x2be6 <APP_ControlMenu+0x82>
    2bd8:	84 33       	cpi	r24, 0x34	; 52
    2bda:	89 f0       	breq	.+34     	; 0x2bfe <APP_ControlMenu+0x9a>
    2bdc:	84 33       	cpi	r24, 0x34	; 52
    2bde:	58 f0       	brcs	.+22     	; 0x2bf6 <APP_ControlMenu+0x92>
    2be0:	83 34       	cpi	r24, 0x43	; 67
    2be2:	49 f7       	brne	.-46     	; 0x2bb6 <APP_ControlMenu+0x52>
    2be4:	14 c0       	rjmp	.+40     	; 0x2c0e <APP_ControlMenu+0xaa>
			case '1':
				Next =RSt12;
    2be6:	81 e2       	ldi	r24, 0x21	; 33
    2be8:	80 93 06 08 	sts	0x0806, r24
    2bec:	9a c0       	rjmp	.+308    	; 0x2d22 <APP_ControlMenu+0x1be>
				Count = 0;
				break;
			case '2':
				Next =RSt13;
    2bee:	82 e2       	ldi	r24, 0x22	; 34
    2bf0:	80 93 06 08 	sts	0x0806, r24
    2bf4:	96 c0       	rjmp	.+300    	; 0x2d22 <APP_ControlMenu+0x1be>
				Count = 0;
				break;
			case '3':
				Next =RSt14;
    2bf6:	83 e2       	ldi	r24, 0x23	; 35
    2bf8:	80 93 06 08 	sts	0x0806, r24
    2bfc:	92 c0       	rjmp	.+292    	; 0x2d22 <APP_ControlMenu+0x1be>
				Count = 0;
				break;
			case '4':
				Next =RSt15;
    2bfe:	84 e2       	ldi	r24, 0x24	; 36
    2c00:	80 93 06 08 	sts	0x0806, r24
    2c04:	8e c0       	rjmp	.+284    	; 0x2d22 <APP_ControlMenu+0x1be>
				Count = 0;
				break;
			case '0':
				Next =RSt3;
    2c06:	88 e1       	ldi	r24, 0x18	; 24
    2c08:	80 93 06 08 	sts	0x0806, r24
    2c0c:	8a c0       	rjmp	.+276    	; 0x2d22 <APP_ControlMenu+0x1be>
				Count = 0;
				break;
			case 'C':
				Next =RSt3;
    2c0e:	88 e1       	ldi	r24, 0x18	; 24
    2c10:	80 93 06 08 	sts	0x0806, r24
    2c14:	86 c0       	rjmp	.+268    	; 0x2d22 <APP_ControlMenu+0x1be>
			}
		}
		break;

	case User_Remote :
		transmitDataBlockOverBluetooth("[1] ROOMS\n",11);
    2c16:	89 ef       	ldi	r24, 0xF9	; 249
    2c18:	90 e0       	ldi	r25, 0x00	; 0
    2c1a:	6b e0       	ldi	r22, 0x0B	; 11
    2c1c:	70 e0       	ldi	r23, 0x00	; 0
    2c1e:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] DIMMIR\n",12);
    2c22:	84 e0       	ldi	r24, 0x04	; 4
    2c24:	91 e0       	ldi	r25, 0x01	; 1
    2c26:	6c e0       	ldi	r22, 0x0C	; 12
    2c28:	70 e0       	ldi	r23, 0x00	; 0
    2c2a:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[3] AC\n",8);
    2c2e:	80 e1       	ldi	r24, 0x10	; 16
    2c30:	91 e0       	ldi	r25, 0x01	; 1
    2c32:	68 e0       	ldi	r22, 0x08	; 8
    2c34:	70 e0       	ldi	r23, 0x00	; 0
    2c36:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    2c3a:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    2c3e:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    2c42:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    2c46:	89 83       	std	Y+1, r24	; 0x01
			switch (Read) {
    2c48:	89 81       	ldd	r24, Y+1	; 0x01
    2c4a:	82 33       	cpi	r24, 0x32	; 50
    2c4c:	81 f0       	breq	.+32     	; 0x2c6e <APP_ControlMenu+0x10a>
    2c4e:	83 33       	cpi	r24, 0x33	; 51
    2c50:	28 f4       	brcc	.+10     	; 0x2c5c <APP_ControlMenu+0xf8>
    2c52:	80 33       	cpi	r24, 0x30	; 48
    2c54:	a1 f0       	breq	.+40     	; 0x2c7e <APP_ControlMenu+0x11a>
    2c56:	81 33       	cpi	r24, 0x31	; 49
    2c58:	81 f7       	brne	.-32     	; 0x2c3a <APP_ControlMenu+0xd6>
    2c5a:	05 c0       	rjmp	.+10     	; 0x2c66 <APP_ControlMenu+0x102>
    2c5c:	83 33       	cpi	r24, 0x33	; 51
    2c5e:	59 f0       	breq	.+22     	; 0x2c76 <APP_ControlMenu+0x112>
    2c60:	83 34       	cpi	r24, 0x43	; 67
    2c62:	59 f7       	brne	.-42     	; 0x2c3a <APP_ControlMenu+0xd6>
    2c64:	10 c0       	rjmp	.+32     	; 0x2c86 <APP_ControlMenu+0x122>
			case '1':
				Next =RSt20;
    2c66:	89 e2       	ldi	r24, 0x29	; 41
    2c68:	80 93 06 08 	sts	0x0806, r24
    2c6c:	5a c0       	rjmp	.+180    	; 0x2d22 <APP_ControlMenu+0x1be>
				Count = 0;
				break;
			case '2':
				Next =RSt21;
    2c6e:	8a e2       	ldi	r24, 0x2A	; 42
    2c70:	80 93 06 08 	sts	0x0806, r24
    2c74:	56 c0       	rjmp	.+172    	; 0x2d22 <APP_ControlMenu+0x1be>
				Count = 0;
				break;
			case '3':
				Next =RSt22;
    2c76:	8b e2       	ldi	r24, 0x2B	; 43
    2c78:	80 93 06 08 	sts	0x0806, r24
    2c7c:	52 c0       	rjmp	.+164    	; 0x2d22 <APP_ControlMenu+0x1be>
				Count = 0;
				break;
			case '0':
				Next =RSt4;
    2c7e:	89 e1       	ldi	r24, 0x19	; 25
    2c80:	80 93 06 08 	sts	0x0806, r24
    2c84:	4e c0       	rjmp	.+156    	; 0x2d22 <APP_ControlMenu+0x1be>
				Count = 0;
				break;
			case 'C':
				Next =RSt4;
    2c86:	89 e1       	ldi	r24, 0x19	; 25
    2c88:	80 93 06 08 	sts	0x0806, r24
    2c8c:	4a c0       	rjmp	.+148    	; 0x2d22 <APP_ControlMenu+0x1be>

		}
		break;

	case User_Keypad :
		CLCD_voidGoto(1,1);
    2c8e:	81 e0       	ldi	r24, 0x01	; 1
    2c90:	61 e0       	ldi	r22, 0x01	; 1
    2c92:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[1]ROOMS");
    2c96:	82 e2       	ldi	r24, 0x22	; 34
    2c98:	91 e0       	ldi	r25, 0x01	; 1
    2c9a:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    2c9e:	82 e0       	ldi	r24, 0x02	; 2
    2ca0:	61 e0       	ldi	r22, 0x01	; 1
    2ca2:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[2]DIMMER");
    2ca6:	8b e2       	ldi	r24, 0x2B	; 43
    2ca8:	91 e0       	ldi	r25, 0x01	; 1
    2caa:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(3,1);
    2cae:	83 e0       	ldi	r24, 0x03	; 3
    2cb0:	61 e0       	ldi	r22, 0x01	; 1
    2cb2:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[3]AC");
    2cb6:	85 e3       	ldi	r24, 0x35	; 53
    2cb8:	91 e0       	ldi	r25, 0x01	; 1
    2cba:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		switch(Local_u8Key)
    2cbe:	80 91 fb 07 	lds	r24, 0x07FB
    2cc2:	83 33       	cpi	r24, 0x33	; 51
    2cc4:	d1 f0       	breq	.+52     	; 0x2cfa <APP_ControlMenu+0x196>
    2cc6:	84 33       	cpi	r24, 0x34	; 52
    2cc8:	28 f4       	brcc	.+10     	; 0x2cd4 <APP_ControlMenu+0x170>
    2cca:	81 33       	cpi	r24, 0x31	; 49
    2ccc:	41 f0       	breq	.+16     	; 0x2cde <APP_ControlMenu+0x17a>
    2cce:	82 33       	cpi	r24, 0x32	; 50
    2cd0:	41 f5       	brne	.+80     	; 0x2d22 <APP_ControlMenu+0x1be>
    2cd2:	0c c0       	rjmp	.+24     	; 0x2cec <APP_ControlMenu+0x188>
    2cd4:	83 34       	cpi	r24, 0x43	; 67
    2cd6:	f9 f0       	breq	.+62     	; 0x2d16 <APP_ControlMenu+0x1b2>
    2cd8:	82 35       	cpi	r24, 0x52	; 82
    2cda:	19 f5       	brne	.+70     	; 0x2d22 <APP_ControlMenu+0x1be>
    2cdc:	15 c0       	rjmp	.+42     	; 0x2d08 <APP_ControlMenu+0x1a4>
		{
		case '1' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2cde:	81 e0       	ldi	r24, 0x01	; 1
    2ce0:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt8;
    2ce4:	88 e0       	ldi	r24, 0x08	; 8
    2ce6:	80 93 06 08 	sts	0x0806, r24
    2cea:	1b c0       	rjmp	.+54     	; 0x2d22 <APP_ControlMenu+0x1be>
			break;

		case '2' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2cec:	81 e0       	ldi	r24, 0x01	; 1
    2cee:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt9;
    2cf2:	89 e0       	ldi	r24, 0x09	; 9
    2cf4:	80 93 06 08 	sts	0x0806, r24
    2cf8:	14 c0       	rjmp	.+40     	; 0x2d22 <APP_ControlMenu+0x1be>
			break;

		case '3' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2cfa:	81 e0       	ldi	r24, 0x01	; 1
    2cfc:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt10;
    2d00:	8a e0       	ldi	r24, 0x0A	; 10
    2d02:	80 93 06 08 	sts	0x0806, r24
    2d06:	0d c0       	rjmp	.+26     	; 0x2d22 <APP_ControlMenu+0x1be>
			break;

		case 'R' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2d08:	81 e0       	ldi	r24, 0x01	; 1
    2d0a:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    2d0e:	81 e0       	ldi	r24, 0x01	; 1
    2d10:	80 93 06 08 	sts	0x0806, r24
    2d14:	06 c0       	rjmp	.+12     	; 0x2d22 <APP_ControlMenu+0x1be>
			break;

		case 'C' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2d16:	81 e0       	ldi	r24, 0x01	; 1
    2d18:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    2d1c:	81 e0       	ldi	r24, 0x01	; 1
    2d1e:	80 93 06 08 	sts	0x0806, r24
		}
		break;
	}

	return Next;
}
    2d22:	80 91 06 08 	lds	r24, 0x0806
    2d26:	0f 90       	pop	r0
    2d28:	cf 91       	pop	r28
    2d2a:	df 91       	pop	r29
    2d2c:	08 95       	ret

00002d2e <APP_StatusMenu>:

static state APP_StatusMenu(Login_t Copy_LoginType){
    2d2e:	df 93       	push	r29
    2d30:	cf 93       	push	r28
    2d32:	0f 92       	push	r0
    2d34:	cd b7       	in	r28, 0x3d	; 61
    2d36:	de b7       	in	r29, 0x3e	; 62
	volatile uint_8 Read = 0;
    2d38:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	switch(Copy_LoginType)
    2d3a:	81 30       	cpi	r24, 0x01	; 1
    2d3c:	09 f4       	brne	.+2      	; 0x2d40 <APP_StatusMenu+0x12>
    2d3e:	4e c0       	rjmp	.+156    	; 0x2ddc <APP_StatusMenu+0xae>
    2d40:	81 30       	cpi	r24, 0x01	; 1
    2d42:	08 f4       	brcc	.+2      	; 0x2d46 <APP_StatusMenu+0x18>
    2d44:	93 c0       	rjmp	.+294    	; 0x2e6c <APP_StatusMenu+0x13e>
    2d46:	82 30       	cpi	r24, 0x02	; 2
    2d48:	09 f0       	breq	.+2      	; 0x2d4c <APP_StatusMenu+0x1e>
    2d4a:	eb c0       	rjmp	.+470    	; 0x2f22 <APP_StatusMenu+0x1f4>
	{
	case Admin :
		transmitDataBlockOverBluetooth("[1] ROOMS\n",11);
    2d4c:	89 ef       	ldi	r24, 0xF9	; 249
    2d4e:	90 e0       	ldi	r25, 0x00	; 0
    2d50:	6b e0       	ldi	r22, 0x0B	; 11
    2d52:	70 e0       	ldi	r23, 0x00	; 0
    2d54:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] DIMMIR\n",12);
    2d58:	84 e0       	ldi	r24, 0x04	; 4
    2d5a:	91 e0       	ldi	r25, 0x01	; 1
    2d5c:	6c e0       	ldi	r22, 0x0C	; 12
    2d5e:	70 e0       	ldi	r23, 0x00	; 0
    2d60:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[3] AC\n",8);
    2d64:	80 e1       	ldi	r24, 0x10	; 16
    2d66:	91 e0       	ldi	r25, 0x01	; 1
    2d68:	68 e0       	ldi	r22, 0x08	; 8
    2d6a:	70 e0       	ldi	r23, 0x00	; 0
    2d6c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[4] DOOR\n",10);
    2d70:	88 e1       	ldi	r24, 0x18	; 24
    2d72:	91 e0       	ldi	r25, 0x01	; 1
    2d74:	6a e0       	ldi	r22, 0x0A	; 10
    2d76:	70 e0       	ldi	r23, 0x00	; 0
    2d78:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    2d7c:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    2d80:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    2d84:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    2d88:	89 83       	std	Y+1, r24	; 0x01
			switch (Read) {
    2d8a:	89 81       	ldd	r24, Y+1	; 0x01
    2d8c:	82 33       	cpi	r24, 0x32	; 50
    2d8e:	91 f0       	breq	.+36     	; 0x2db4 <APP_StatusMenu+0x86>
    2d90:	83 33       	cpi	r24, 0x33	; 51
    2d92:	28 f4       	brcc	.+10     	; 0x2d9e <APP_StatusMenu+0x70>
    2d94:	80 33       	cpi	r24, 0x30	; 48
    2d96:	d1 f0       	breq	.+52     	; 0x2dcc <APP_StatusMenu+0x9e>
    2d98:	81 33       	cpi	r24, 0x31	; 49
    2d9a:	81 f7       	brne	.-32     	; 0x2d7c <APP_StatusMenu+0x4e>
    2d9c:	07 c0       	rjmp	.+14     	; 0x2dac <APP_StatusMenu+0x7e>
    2d9e:	84 33       	cpi	r24, 0x34	; 52
    2da0:	89 f0       	breq	.+34     	; 0x2dc4 <APP_StatusMenu+0x96>
    2da2:	84 33       	cpi	r24, 0x34	; 52
    2da4:	58 f0       	brcs	.+22     	; 0x2dbc <APP_StatusMenu+0x8e>
    2da6:	83 34       	cpi	r24, 0x43	; 67
    2da8:	49 f7       	brne	.-46     	; 0x2d7c <APP_StatusMenu+0x4e>
    2daa:	14 c0       	rjmp	.+40     	; 0x2dd4 <APP_StatusMenu+0xa6>
			case '1':
				Next =RSt16;
    2dac:	85 e2       	ldi	r24, 0x25	; 37
    2dae:	80 93 06 08 	sts	0x0806, r24
    2db2:	b7 c0       	rjmp	.+366    	; 0x2f22 <APP_StatusMenu+0x1f4>
				Count = 0;
				break;
			case '2':
				Next =RSt17;
    2db4:	86 e2       	ldi	r24, 0x26	; 38
    2db6:	80 93 06 08 	sts	0x0806, r24
    2dba:	b3 c0       	rjmp	.+358    	; 0x2f22 <APP_StatusMenu+0x1f4>
				Count = 0;
				break;
			case '3':
				Next =RSt18;
    2dbc:	87 e2       	ldi	r24, 0x27	; 39
    2dbe:	80 93 06 08 	sts	0x0806, r24
    2dc2:	af c0       	rjmp	.+350    	; 0x2f22 <APP_StatusMenu+0x1f4>
				Count = 0;
				break;
			case '4':
				Next =RSt19;
    2dc4:	88 e2       	ldi	r24, 0x28	; 40
    2dc6:	80 93 06 08 	sts	0x0806, r24
    2dca:	ab c0       	rjmp	.+342    	; 0x2f22 <APP_StatusMenu+0x1f4>
				Count = 0;
				break;
			case '0':
				Next =RSt3;
    2dcc:	88 e1       	ldi	r24, 0x18	; 24
    2dce:	80 93 06 08 	sts	0x0806, r24
    2dd2:	a7 c0       	rjmp	.+334    	; 0x2f22 <APP_StatusMenu+0x1f4>
				Count = 0;
				break;
			case 'C':
				Next =RSt3;
    2dd4:	88 e1       	ldi	r24, 0x18	; 24
    2dd6:	80 93 06 08 	sts	0x0806, r24
    2dda:	a3 c0       	rjmp	.+326    	; 0x2f22 <APP_StatusMenu+0x1f4>
			}
		}
		break;

	case User_Remote :
		transmitDataBlockOverBluetooth("[1] ROOMS\n",11);
    2ddc:	89 ef       	ldi	r24, 0xF9	; 249
    2dde:	90 e0       	ldi	r25, 0x00	; 0
    2de0:	6b e0       	ldi	r22, 0x0B	; 11
    2de2:	70 e0       	ldi	r23, 0x00	; 0
    2de4:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] DIMMIR\n",12);
    2de8:	84 e0       	ldi	r24, 0x04	; 4
    2dea:	91 e0       	ldi	r25, 0x01	; 1
    2dec:	6c e0       	ldi	r22, 0x0C	; 12
    2dee:	70 e0       	ldi	r23, 0x00	; 0
    2df0:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[3] AC\n",8);
    2df4:	80 e1       	ldi	r24, 0x10	; 16
    2df6:	91 e0       	ldi	r25, 0x01	; 1
    2df8:	68 e0       	ldi	r22, 0x08	; 8
    2dfa:	70 e0       	ldi	r23, 0x00	; 0
    2dfc:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[4] DOOR\n",10);
    2e00:	88 e1       	ldi	r24, 0x18	; 24
    2e02:	91 e0       	ldi	r25, 0x01	; 1
    2e04:	6a e0       	ldi	r22, 0x0A	; 10
    2e06:	70 e0       	ldi	r23, 0x00	; 0
    2e08:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    2e0c:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    2e10:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    2e14:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    2e18:	89 83       	std	Y+1, r24	; 0x01
			switch (Read) {
    2e1a:	89 81       	ldd	r24, Y+1	; 0x01
    2e1c:	82 33       	cpi	r24, 0x32	; 50
    2e1e:	91 f0       	breq	.+36     	; 0x2e44 <APP_StatusMenu+0x116>
    2e20:	83 33       	cpi	r24, 0x33	; 51
    2e22:	28 f4       	brcc	.+10     	; 0x2e2e <APP_StatusMenu+0x100>
    2e24:	80 33       	cpi	r24, 0x30	; 48
    2e26:	d1 f0       	breq	.+52     	; 0x2e5c <APP_StatusMenu+0x12e>
    2e28:	81 33       	cpi	r24, 0x31	; 49
    2e2a:	81 f7       	brne	.-32     	; 0x2e0c <APP_StatusMenu+0xde>
    2e2c:	07 c0       	rjmp	.+14     	; 0x2e3c <APP_StatusMenu+0x10e>
    2e2e:	84 33       	cpi	r24, 0x34	; 52
    2e30:	89 f0       	breq	.+34     	; 0x2e54 <APP_StatusMenu+0x126>
    2e32:	84 33       	cpi	r24, 0x34	; 52
    2e34:	58 f0       	brcs	.+22     	; 0x2e4c <APP_StatusMenu+0x11e>
    2e36:	83 34       	cpi	r24, 0x43	; 67
    2e38:	49 f7       	brne	.-46     	; 0x2e0c <APP_StatusMenu+0xde>
    2e3a:	14 c0       	rjmp	.+40     	; 0x2e64 <APP_StatusMenu+0x136>
			case '1':
				Next =RSt23;
    2e3c:	8c e2       	ldi	r24, 0x2C	; 44
    2e3e:	80 93 06 08 	sts	0x0806, r24
    2e42:	6f c0       	rjmp	.+222    	; 0x2f22 <APP_StatusMenu+0x1f4>
				Count = 0;
				break;
			case '2':
				Next =RSt24;
    2e44:	8d e2       	ldi	r24, 0x2D	; 45
    2e46:	80 93 06 08 	sts	0x0806, r24
    2e4a:	6b c0       	rjmp	.+214    	; 0x2f22 <APP_StatusMenu+0x1f4>
				Count = 0;
				break;
			case '3':
				Next =RSt25;
    2e4c:	8e e2       	ldi	r24, 0x2E	; 46
    2e4e:	80 93 06 08 	sts	0x0806, r24
    2e52:	67 c0       	rjmp	.+206    	; 0x2f22 <APP_StatusMenu+0x1f4>
				Count = 0;
				break;
			case '4':
				Next =RSt26;
    2e54:	8f e2       	ldi	r24, 0x2F	; 47
    2e56:	80 93 06 08 	sts	0x0806, r24
    2e5a:	63 c0       	rjmp	.+198    	; 0x2f22 <APP_StatusMenu+0x1f4>
				Count = 0;
				break;
			case '0':
				Next =RSt4;
    2e5c:	89 e1       	ldi	r24, 0x19	; 25
    2e5e:	80 93 06 08 	sts	0x0806, r24
    2e62:	5f c0       	rjmp	.+190    	; 0x2f22 <APP_StatusMenu+0x1f4>
				Count = 0;
				break;
			case 'C':
				Next =RSt4;
    2e64:	89 e1       	ldi	r24, 0x19	; 25
    2e66:	80 93 06 08 	sts	0x0806, r24
    2e6a:	5b c0       	rjmp	.+182    	; 0x2f22 <APP_StatusMenu+0x1f4>

		}
		break;

	case User_Keypad :
		CLCD_voidGoto(1,1);
    2e6c:	81 e0       	ldi	r24, 0x01	; 1
    2e6e:	61 e0       	ldi	r22, 0x01	; 1
    2e70:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[1]ROOMS");
    2e74:	82 e2       	ldi	r24, 0x22	; 34
    2e76:	91 e0       	ldi	r25, 0x01	; 1
    2e78:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    2e7c:	82 e0       	ldi	r24, 0x02	; 2
    2e7e:	61 e0       	ldi	r22, 0x01	; 1
    2e80:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[2]DOOR");
    2e84:	8b e3       	ldi	r24, 0x3B	; 59
    2e86:	91 e0       	ldi	r25, 0x01	; 1
    2e88:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(3,1);
    2e8c:	83 e0       	ldi	r24, 0x03	; 3
    2e8e:	61 e0       	ldi	r22, 0x01	; 1
    2e90:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[3]AC");
    2e94:	85 e3       	ldi	r24, 0x35	; 53
    2e96:	91 e0       	ldi	r25, 0x01	; 1
    2e98:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(4,1);
    2e9c:	84 e0       	ldi	r24, 0x04	; 4
    2e9e:	61 e0       	ldi	r22, 0x01	; 1
    2ea0:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[4]DIMMER");
    2ea4:	83 e4       	ldi	r24, 0x43	; 67
    2ea6:	91 e0       	ldi	r25, 0x01	; 1
    2ea8:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		switch(Local_u8Key)
    2eac:	80 91 fb 07 	lds	r24, 0x07FB
    2eb0:	83 33       	cpi	r24, 0x33	; 51
    2eb2:	e1 f0       	breq	.+56     	; 0x2eec <APP_StatusMenu+0x1be>
    2eb4:	84 33       	cpi	r24, 0x34	; 52
    2eb6:	28 f4       	brcc	.+10     	; 0x2ec2 <APP_StatusMenu+0x194>
    2eb8:	81 33       	cpi	r24, 0x31	; 49
    2eba:	51 f0       	breq	.+20     	; 0x2ed0 <APP_StatusMenu+0x1a2>
    2ebc:	82 33       	cpi	r24, 0x32	; 50
    2ebe:	89 f5       	brne	.+98     	; 0x2f22 <APP_StatusMenu+0x1f4>
    2ec0:	0e c0       	rjmp	.+28     	; 0x2ede <APP_StatusMenu+0x1b0>
    2ec2:	83 34       	cpi	r24, 0x43	; 67
    2ec4:	41 f1       	breq	.+80     	; 0x2f16 <APP_StatusMenu+0x1e8>
    2ec6:	82 35       	cpi	r24, 0x52	; 82
    2ec8:	f9 f0       	breq	.+62     	; 0x2f08 <APP_StatusMenu+0x1da>
    2eca:	84 33       	cpi	r24, 0x34	; 52
    2ecc:	51 f5       	brne	.+84     	; 0x2f22 <APP_StatusMenu+0x1f4>
    2ece:	15 c0       	rjmp	.+42     	; 0x2efa <APP_StatusMenu+0x1cc>
		{
		case '1' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2ed0:	81 e0       	ldi	r24, 0x01	; 1
    2ed2:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt4;
    2ed6:	84 e0       	ldi	r24, 0x04	; 4
    2ed8:	80 93 06 08 	sts	0x0806, r24
    2edc:	22 c0       	rjmp	.+68     	; 0x2f22 <APP_StatusMenu+0x1f4>
			break;
		case '2' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2ede:	81 e0       	ldi	r24, 0x01	; 1
    2ee0:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt5;
    2ee4:	85 e0       	ldi	r24, 0x05	; 5
    2ee6:	80 93 06 08 	sts	0x0806, r24
    2eea:	1b c0       	rjmp	.+54     	; 0x2f22 <APP_StatusMenu+0x1f4>
			break;
		case '3' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2eec:	81 e0       	ldi	r24, 0x01	; 1
    2eee:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt6;
    2ef2:	86 e0       	ldi	r24, 0x06	; 6
    2ef4:	80 93 06 08 	sts	0x0806, r24
    2ef8:	14 c0       	rjmp	.+40     	; 0x2f22 <APP_StatusMenu+0x1f4>
			break;
		case '4' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2efa:	81 e0       	ldi	r24, 0x01	; 1
    2efc:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt7;
    2f00:	87 e0       	ldi	r24, 0x07	; 7
    2f02:	80 93 06 08 	sts	0x0806, r24
    2f06:	0d c0       	rjmp	.+26     	; 0x2f22 <APP_StatusMenu+0x1f4>
			break;
		case 'R' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2f08:	81 e0       	ldi	r24, 0x01	; 1
    2f0a:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    2f0e:	81 e0       	ldi	r24, 0x01	; 1
    2f10:	80 93 06 08 	sts	0x0806, r24
    2f14:	06 c0       	rjmp	.+12     	; 0x2f22 <APP_StatusMenu+0x1f4>
			break;
		case 'C' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    2f16:	81 e0       	ldi	r24, 0x01	; 1
    2f18:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    2f1c:	81 e0       	ldi	r24, 0x01	; 1
    2f1e:	80 93 06 08 	sts	0x0806, r24
		break;
	}

	return Next;

}
    2f22:	80 91 06 08 	lds	r24, 0x0806
    2f26:	0f 90       	pop	r0
    2f28:	cf 91       	pop	r28
    2f2a:	df 91       	pop	r29
    2f2c:	08 95       	ret

00002f2e <APP_RoomsControlMenu>:

static state APP_RoomsControlMenu(Login_t Copy_LoginType){
    2f2e:	df 93       	push	r29
    2f30:	cf 93       	push	r28
    2f32:	0f 92       	push	r0
    2f34:	cd b7       	in	r28, 0x3d	; 61
    2f36:	de b7       	in	r29, 0x3e	; 62
	volatile uint_8 Read = 0;
    2f38:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	switch(Copy_LoginType)
    2f3a:	81 30       	cpi	r24, 0x01	; 1
    2f3c:	09 f4       	brne	.+2      	; 0x2f40 <APP_RoomsControlMenu+0x12>
    2f3e:	5a c0       	rjmp	.+180    	; 0x2ff4 <APP_RoomsControlMenu+0xc6>
    2f40:	81 30       	cpi	r24, 0x01	; 1
    2f42:	08 f4       	brcc	.+2      	; 0x2f46 <APP_RoomsControlMenu+0x18>
    2f44:	b0 c0       	rjmp	.+352    	; 0x30a6 <APP_RoomsControlMenu+0x178>
    2f46:	82 30       	cpi	r24, 0x02	; 2
    2f48:	09 f0       	breq	.+2      	; 0x2f4c <APP_RoomsControlMenu+0x1e>
    2f4a:	19 c1       	rjmp	.+562    	; 0x317e <APP_RoomsControlMenu+0x250>
	{
	case Admin :
		transmitDataBlockOverBluetooth("[1]R1\n",7);
    2f4c:	8d e4       	ldi	r24, 0x4D	; 77
    2f4e:	91 e0       	ldi	r25, 0x01	; 1
    2f50:	67 e0       	ldi	r22, 0x07	; 7
    2f52:	70 e0       	ldi	r23, 0x00	; 0
    2f54:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2]R2\n",7);
    2f58:	84 e5       	ldi	r24, 0x54	; 84
    2f5a:	91 e0       	ldi	r25, 0x01	; 1
    2f5c:	67 e0       	ldi	r22, 0x07	; 7
    2f5e:	70 e0       	ldi	r23, 0x00	; 0
    2f60:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[3]R3\n",7);
    2f64:	8b e5       	ldi	r24, 0x5B	; 91
    2f66:	91 e0       	ldi	r25, 0x01	; 1
    2f68:	67 e0       	ldi	r22, 0x07	; 7
    2f6a:	70 e0       	ldi	r23, 0x00	; 0
    2f6c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[4]R4\n",7);
    2f70:	82 e6       	ldi	r24, 0x62	; 98
    2f72:	91 e0       	ldi	r25, 0x01	; 1
    2f74:	67 e0       	ldi	r22, 0x07	; 7
    2f76:	70 e0       	ldi	r23, 0x00	; 0
    2f78:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[5]R5\n",7);
    2f7c:	89 e6       	ldi	r24, 0x69	; 105
    2f7e:	91 e0       	ldi	r25, 0x01	; 1
    2f80:	67 e0       	ldi	r22, 0x07	; 7
    2f82:	70 e0       	ldi	r23, 0x00	; 0
    2f84:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    2f88:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    2f8c:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    2f90:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    2f94:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    2f96:	89 81       	ldd	r24, Y+1	; 0x01
    2f98:	83 33       	cpi	r24, 0x33	; 51
    2f9a:	c1 f0       	breq	.+48     	; 0x2fcc <APP_RoomsControlMenu+0x9e>
    2f9c:	84 33       	cpi	r24, 0x34	; 52
    2f9e:	38 f4       	brcc	.+14     	; 0x2fae <APP_RoomsControlMenu+0x80>
    2fa0:	81 33       	cpi	r24, 0x31	; 49
    2fa2:	61 f0       	breq	.+24     	; 0x2fbc <APP_RoomsControlMenu+0x8e>
    2fa4:	82 33       	cpi	r24, 0x32	; 50
    2fa6:	70 f4       	brcc	.+28     	; 0x2fc4 <APP_RoomsControlMenu+0x96>
    2fa8:	80 33       	cpi	r24, 0x30	; 48
    2faa:	71 f7       	brne	.-36     	; 0x2f88 <APP_RoomsControlMenu+0x5a>
    2fac:	1b c0       	rjmp	.+54     	; 0x2fe4 <APP_RoomsControlMenu+0xb6>
    2fae:	85 33       	cpi	r24, 0x35	; 53
    2fb0:	a9 f0       	breq	.+42     	; 0x2fdc <APP_RoomsControlMenu+0xae>
    2fb2:	85 33       	cpi	r24, 0x35	; 53
    2fb4:	78 f0       	brcs	.+30     	; 0x2fd4 <APP_RoomsControlMenu+0xa6>
    2fb6:	83 34       	cpi	r24, 0x43	; 67
    2fb8:	39 f7       	brne	.-50     	; 0x2f88 <APP_RoomsControlMenu+0x5a>
    2fba:	18 c0       	rjmp	.+48     	; 0x2fec <APP_RoomsControlMenu+0xbe>
			{
			case '1' :
				Count = 0;
				Next = RSt27;
    2fbc:	80 e3       	ldi	r24, 0x30	; 48
    2fbe:	80 93 06 08 	sts	0x0806, r24
    2fc2:	dd c0       	rjmp	.+442    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;

			case '2' :
				Count = 0;
				Next = RSt28;
    2fc4:	81 e3       	ldi	r24, 0x31	; 49
    2fc6:	80 93 06 08 	sts	0x0806, r24
    2fca:	d9 c0       	rjmp	.+434    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;
			case '3' :
				Count = 0;
				Next = RSt29;
    2fcc:	82 e3       	ldi	r24, 0x32	; 50
    2fce:	80 93 06 08 	sts	0x0806, r24
    2fd2:	d5 c0       	rjmp	.+426    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;
			case '4' :
				Count = 0;
				Next = RSt30;
    2fd4:	83 e3       	ldi	r24, 0x33	; 51
    2fd6:	80 93 06 08 	sts	0x0806, r24
    2fda:	d1 c0       	rjmp	.+418    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;
			case '5' :
				Count = 0;
				Next = RSt31;
    2fdc:	84 e3       	ldi	r24, 0x34	; 52
    2fde:	80 93 06 08 	sts	0x0806, r24
    2fe2:	cd c0       	rjmp	.+410    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;
			case '0' :
				Count = 0;
				Next = RSt5;
    2fe4:	8a e1       	ldi	r24, 0x1A	; 26
    2fe6:	80 93 06 08 	sts	0x0806, r24
    2fea:	c9 c0       	rjmp	.+402    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    2fec:	88 e1       	ldi	r24, 0x18	; 24
    2fee:	80 93 06 08 	sts	0x0806, r24
    2ff2:	c5 c0       	rjmp	.+394    	; 0x317e <APP_RoomsControlMenu+0x250>
			}
		}
		break;

	case User_Remote :
		transmitDataBlockOverBluetooth("[1]R1\n",7);
    2ff4:	8d e4       	ldi	r24, 0x4D	; 77
    2ff6:	91 e0       	ldi	r25, 0x01	; 1
    2ff8:	67 e0       	ldi	r22, 0x07	; 7
    2ffa:	70 e0       	ldi	r23, 0x00	; 0
    2ffc:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2]R2\n",7);
    3000:	84 e5       	ldi	r24, 0x54	; 84
    3002:	91 e0       	ldi	r25, 0x01	; 1
    3004:	67 e0       	ldi	r22, 0x07	; 7
    3006:	70 e0       	ldi	r23, 0x00	; 0
    3008:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[3]R3\n",7);
    300c:	8b e5       	ldi	r24, 0x5B	; 91
    300e:	91 e0       	ldi	r25, 0x01	; 1
    3010:	67 e0       	ldi	r22, 0x07	; 7
    3012:	70 e0       	ldi	r23, 0x00	; 0
    3014:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[4]R4\n",7);
    3018:	82 e6       	ldi	r24, 0x62	; 98
    301a:	91 e0       	ldi	r25, 0x01	; 1
    301c:	67 e0       	ldi	r22, 0x07	; 7
    301e:	70 e0       	ldi	r23, 0x00	; 0
    3020:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[5]R5\n",7);
    3024:	89 e6       	ldi	r24, 0x69	; 105
    3026:	91 e0       	ldi	r25, 0x01	; 1
    3028:	67 e0       	ldi	r22, 0x07	; 7
    302a:	70 e0       	ldi	r23, 0x00	; 0
    302c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		Read = UART_ReceiveChar();
    3030:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
    3034:	89 83       	std	Y+1, r24	; 0x01
    3036:	33 c0       	rjmp	.+102    	; 0x309e <APP_RoomsControlMenu+0x170>
		while(Count && Read){

			APP_SystemState();
    3038:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
			APP_TEMP_MOTOR();
    303c:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
			switch(Read)
    3040:	89 81       	ldd	r24, Y+1	; 0x01
    3042:	83 33       	cpi	r24, 0x33	; 51
    3044:	c1 f0       	breq	.+48     	; 0x3076 <APP_RoomsControlMenu+0x148>
    3046:	84 33       	cpi	r24, 0x34	; 52
    3048:	38 f4       	brcc	.+14     	; 0x3058 <APP_RoomsControlMenu+0x12a>
    304a:	81 33       	cpi	r24, 0x31	; 49
    304c:	61 f0       	breq	.+24     	; 0x3066 <APP_RoomsControlMenu+0x138>
    304e:	82 33       	cpi	r24, 0x32	; 50
    3050:	70 f4       	brcc	.+28     	; 0x306e <APP_RoomsControlMenu+0x140>
    3052:	80 33       	cpi	r24, 0x30	; 48
    3054:	21 f5       	brne	.+72     	; 0x309e <APP_RoomsControlMenu+0x170>
    3056:	1b c0       	rjmp	.+54     	; 0x308e <APP_RoomsControlMenu+0x160>
    3058:	85 33       	cpi	r24, 0x35	; 53
    305a:	a9 f0       	breq	.+42     	; 0x3086 <APP_RoomsControlMenu+0x158>
    305c:	85 33       	cpi	r24, 0x35	; 53
    305e:	78 f0       	brcs	.+30     	; 0x307e <APP_RoomsControlMenu+0x150>
    3060:	83 34       	cpi	r24, 0x43	; 67
    3062:	e9 f4       	brne	.+58     	; 0x309e <APP_RoomsControlMenu+0x170>
    3064:	18 c0       	rjmp	.+48     	; 0x3096 <APP_RoomsControlMenu+0x168>
			{
			case '1' :
				Count = 0;
				Next = RSt37;
    3066:	8a e3       	ldi	r24, 0x3A	; 58
    3068:	80 93 06 08 	sts	0x0806, r24
    306c:	88 c0       	rjmp	.+272    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;
			case '2' :
				Count = 0;
				Next = RSt38;
    306e:	8b e3       	ldi	r24, 0x3B	; 59
    3070:	80 93 06 08 	sts	0x0806, r24
    3074:	84 c0       	rjmp	.+264    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;
			case '3' :
				Count = 0;
				Next = RSt39;
    3076:	8c e3       	ldi	r24, 0x3C	; 60
    3078:	80 93 06 08 	sts	0x0806, r24
    307c:	80 c0       	rjmp	.+256    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;
			case '4' :
				Count = 0;
				Next = RSt40;
    307e:	8d e3       	ldi	r24, 0x3D	; 61
    3080:	80 93 06 08 	sts	0x0806, r24
    3084:	7c c0       	rjmp	.+248    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;
			case '5' :
				Count = 0;
				Next = RSt41;
    3086:	8e e3       	ldi	r24, 0x3E	; 62
    3088:	80 93 06 08 	sts	0x0806, r24
    308c:	78 c0       	rjmp	.+240    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;
			case '0' :
				Count = 0;
				Next = RSt10;
    308e:	8f e1       	ldi	r24, 0x1F	; 31
    3090:	80 93 06 08 	sts	0x0806, r24
    3094:	74 c0       	rjmp	.+232    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;
			case 'C' :
				Count = 0;
				Next = RSt4;
    3096:	89 e1       	ldi	r24, 0x19	; 25
    3098:	80 93 06 08 	sts	0x0806, r24
    309c:	70 c0       	rjmp	.+224    	; 0x317e <APP_RoomsControlMenu+0x250>
		transmitDataBlockOverBluetooth("[3]R3\n",7);
		transmitDataBlockOverBluetooth("[4]R4\n",7);
		transmitDataBlockOverBluetooth("[5]R5\n",7);

		Read = UART_ReceiveChar();
		while(Count && Read){
    309e:	89 81       	ldd	r24, Y+1	; 0x01
    30a0:	88 23       	and	r24, r24
    30a2:	51 f6       	brne	.-108    	; 0x3038 <APP_RoomsControlMenu+0x10a>
    30a4:	6c c0       	rjmp	.+216    	; 0x317e <APP_RoomsControlMenu+0x250>
				break;
			}
		}
		break;
	case User_Keypad :
		CLCD_voidGoto(1,1);
    30a6:	81 e0       	ldi	r24, 0x01	; 1
    30a8:	61 e0       	ldi	r22, 0x01	; 1
    30aa:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[1]R1");
    30ae:	80 e7       	ldi	r24, 0x70	; 112
    30b0:	91 e0       	ldi	r25, 0x01	; 1
    30b2:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    30b6:	82 e0       	ldi	r24, 0x02	; 2
    30b8:	61 e0       	ldi	r22, 0x01	; 1
    30ba:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[2]R2");
    30be:	86 e7       	ldi	r24, 0x76	; 118
    30c0:	91 e0       	ldi	r25, 0x01	; 1
    30c2:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(3,1);
    30c6:	83 e0       	ldi	r24, 0x03	; 3
    30c8:	61 e0       	ldi	r22, 0x01	; 1
    30ca:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[3]R3");
    30ce:	8c e7       	ldi	r24, 0x7C	; 124
    30d0:	91 e0       	ldi	r25, 0x01	; 1
    30d2:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(4,1);
    30d6:	84 e0       	ldi	r24, 0x04	; 4
    30d8:	61 e0       	ldi	r22, 0x01	; 1
    30da:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[4]R4");
    30de:	82 e8       	ldi	r24, 0x82	; 130
    30e0:	91 e0       	ldi	r25, 0x01	; 1
    30e2:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(1,8);
    30e6:	81 e0       	ldi	r24, 0x01	; 1
    30e8:	68 e0       	ldi	r22, 0x08	; 8
    30ea:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[5]R5");
    30ee:	88 e8       	ldi	r24, 0x88	; 136
    30f0:	91 e0       	ldi	r25, 0x01	; 1
    30f2:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		switch(Local_u8Key)
    30f6:	80 91 fb 07 	lds	r24, 0x07FB
    30fa:	84 33       	cpi	r24, 0x34	; 52
    30fc:	29 f1       	breq	.+74     	; 0x3148 <APP_RoomsControlMenu+0x21a>
    30fe:	85 33       	cpi	r24, 0x35	; 53
    3100:	38 f4       	brcc	.+14     	; 0x3110 <APP_RoomsControlMenu+0x1e2>
    3102:	82 33       	cpi	r24, 0x32	; 50
    3104:	99 f0       	breq	.+38     	; 0x312c <APP_RoomsControlMenu+0x1fe>
    3106:	83 33       	cpi	r24, 0x33	; 51
    3108:	c0 f4       	brcc	.+48     	; 0x313a <APP_RoomsControlMenu+0x20c>
    310a:	81 33       	cpi	r24, 0x31	; 49
    310c:	c1 f5       	brne	.+112    	; 0x317e <APP_RoomsControlMenu+0x250>
    310e:	07 c0       	rjmp	.+14     	; 0x311e <APP_RoomsControlMenu+0x1f0>
    3110:	83 34       	cpi	r24, 0x43	; 67
    3112:	79 f1       	breq	.+94     	; 0x3172 <APP_RoomsControlMenu+0x244>
    3114:	82 35       	cpi	r24, 0x52	; 82
    3116:	31 f1       	breq	.+76     	; 0x3164 <APP_RoomsControlMenu+0x236>
    3118:	85 33       	cpi	r24, 0x35	; 53
    311a:	89 f5       	brne	.+98     	; 0x317e <APP_RoomsControlMenu+0x250>
    311c:	1c c0       	rjmp	.+56     	; 0x3156 <APP_RoomsControlMenu+0x228>
		{
		case '1' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    311e:	81 e0       	ldi	r24, 0x01	; 1
    3120:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt11;
    3124:	8b e0       	ldi	r24, 0x0B	; 11
    3126:	80 93 06 08 	sts	0x0806, r24
    312a:	29 c0       	rjmp	.+82     	; 0x317e <APP_RoomsControlMenu+0x250>
			break;

		case '2' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    312c:	81 e0       	ldi	r24, 0x01	; 1
    312e:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt12;
    3132:	8c e0       	ldi	r24, 0x0C	; 12
    3134:	80 93 06 08 	sts	0x0806, r24
    3138:	22 c0       	rjmp	.+68     	; 0x317e <APP_RoomsControlMenu+0x250>
			break;
		case '3' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    313a:	81 e0       	ldi	r24, 0x01	; 1
    313c:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt13;
    3140:	8d e0       	ldi	r24, 0x0D	; 13
    3142:	80 93 06 08 	sts	0x0806, r24
    3146:	1b c0       	rjmp	.+54     	; 0x317e <APP_RoomsControlMenu+0x250>
			break;
		case '4' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3148:	81 e0       	ldi	r24, 0x01	; 1
    314a:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt14;
    314e:	8e e0       	ldi	r24, 0x0E	; 14
    3150:	80 93 06 08 	sts	0x0806, r24
    3154:	14 c0       	rjmp	.+40     	; 0x317e <APP_RoomsControlMenu+0x250>
			break;
		case '5' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3156:	81 e0       	ldi	r24, 0x01	; 1
    3158:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt15;
    315c:	8f e0       	ldi	r24, 0x0F	; 15
    315e:	80 93 06 08 	sts	0x0806, r24
    3162:	0d c0       	rjmp	.+26     	; 0x317e <APP_RoomsControlMenu+0x250>
			break;
		case 'R' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3164:	81 e0       	ldi	r24, 0x01	; 1
    3166:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt3;
    316a:	83 e0       	ldi	r24, 0x03	; 3
    316c:	80 93 06 08 	sts	0x0806, r24
    3170:	06 c0       	rjmp	.+12     	; 0x317e <APP_RoomsControlMenu+0x250>
			break;
		case 'C' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3172:	81 e0       	ldi	r24, 0x01	; 1
    3174:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    3178:	81 e0       	ldi	r24, 0x01	; 1
    317a:	80 93 06 08 	sts	0x0806, r24
			break;
		}
		break;
	}
	return Next;
}
    317e:	80 91 06 08 	lds	r24, 0x0806
    3182:	0f 90       	pop	r0
    3184:	cf 91       	pop	r28
    3186:	df 91       	pop	r29
    3188:	08 95       	ret

0000318a <APP_AC_Control>:
		}
	}
	return Next;
}

static state APP_AC_Control(Login_t Copy_LoginType){
    318a:	df 93       	push	r29
    318c:	cf 93       	push	r28
    318e:	0f 92       	push	r0
    3190:	cd b7       	in	r28, 0x3d	; 61
    3192:	de b7       	in	r29, 0x3e	; 62
	volatile uint_8 Read = 0;
    3194:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	switch(Copy_LoginType)
    3196:	81 30       	cpi	r24, 0x01	; 1
    3198:	09 f4       	brne	.+2      	; 0x319c <APP_AC_Control+0x12>
    319a:	4c c0       	rjmp	.+152    	; 0x3234 <APP_AC_Control+0xaa>
    319c:	81 30       	cpi	r24, 0x01	; 1
    319e:	08 f4       	brcc	.+2      	; 0x31a2 <APP_AC_Control+0x18>
    31a0:	8f c0       	rjmp	.+286    	; 0x32c0 <APP_AC_Control+0x136>
    31a2:	82 30       	cpi	r24, 0x02	; 2
    31a4:	09 f0       	breq	.+2      	; 0x31a8 <APP_AC_Control+0x1e>
    31a6:	d5 c0       	rjmp	.+426    	; 0x3352 <APP_AC_Control+0x1c8>
	{
	case Admin :
		transmitDataBlockOverBluetooth("[1] AC Active\n",15);
    31a8:	8e e8       	ldi	r24, 0x8E	; 142
    31aa:	91 e0       	ldi	r25, 0x01	; 1
    31ac:	6f e0       	ldi	r22, 0x0F	; 15
    31ae:	70 e0       	ldi	r23, 0x00	; 0
    31b0:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] AC OFF\n",12);
    31b4:	8d e9       	ldi	r24, 0x9D	; 157
    31b6:	91 e0       	ldi	r25, 0x01	; 1
    31b8:	6c e0       	ldi	r22, 0x0C	; 12
    31ba:	70 e0       	ldi	r23, 0x00	; 0
    31bc:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    31c0:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    31c4:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    31c8:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    31cc:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    31ce:	89 81       	ldd	r24, Y+1	; 0x01
    31d0:	81 33       	cpi	r24, 0x31	; 49
    31d2:	51 f0       	breq	.+20     	; 0x31e8 <APP_AC_Control+0x5e>
    31d4:	82 33       	cpi	r24, 0x32	; 50
    31d6:	18 f4       	brcc	.+6      	; 0x31de <APP_AC_Control+0x54>
    31d8:	80 33       	cpi	r24, 0x30	; 48
    31da:	91 f7       	brne	.-28     	; 0x31c0 <APP_AC_Control+0x36>
    31dc:	23 c0       	rjmp	.+70     	; 0x3224 <APP_AC_Control+0x9a>
    31de:	82 33       	cpi	r24, 0x32	; 50
    31e0:	91 f0       	breq	.+36     	; 0x3206 <APP_AC_Control+0x7c>
    31e2:	83 34       	cpi	r24, 0x43	; 67
    31e4:	69 f7       	brne	.-38     	; 0x31c0 <APP_AC_Control+0x36>
    31e6:	22 c0       	rjmp	.+68     	; 0x322c <APP_AC_Control+0xa2>
			{
			case '1' :

				DIO_voidSetPinDirection(DIO_u8PORTA, DIO_PIN0, Input);
    31e8:	80 e0       	ldi	r24, 0x00	; 0
    31ea:	60 e0       	ldi	r22, 0x00	; 0
    31ec:	40 e0       	ldi	r20, 0x00	; 0
    31ee:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
				Ecual_DC_Motor_Intialize(MOTOR_PORT, Motor1, Output);
    31f2:	80 e0       	ldi	r24, 0x00	; 0
    31f4:	62 eb       	ldi	r22, 0xB2	; 178
    31f6:	77 e0       	ldi	r23, 0x07	; 7
    31f8:	41 e0       	ldi	r20, 0x01	; 1
    31fa:	0e 94 3f 10 	call	0x207e	; 0x207e <Ecual_DC_Motor_Intialize>
				Count = 0;
				Next = RSt14;
    31fe:	83 e2       	ldi	r24, 0x23	; 35
    3200:	80 93 06 08 	sts	0x0806, r24
    3204:	a6 c0       	rjmp	.+332    	; 0x3352 <APP_AC_Control+0x1c8>
				break;
			case '2' :

				/* Set PIN DC MOTOR INPUT*/
				Ecual_DC_Motor_Intialize(MOTOR_PORT, Motor1, Input);
    3206:	80 e0       	ldi	r24, 0x00	; 0
    3208:	62 eb       	ldi	r22, 0xB2	; 178
    320a:	77 e0       	ldi	r23, 0x07	; 7
    320c:	40 e0       	ldi	r20, 0x00	; 0
    320e:	0e 94 3f 10 	call	0x207e	; 0x207e <Ecual_DC_Motor_Intialize>
				DIO_voidSetPinDirection(DIO_u8PORTA, DIO_PIN0, Output);
    3212:	80 e0       	ldi	r24, 0x00	; 0
    3214:	60 e0       	ldi	r22, 0x00	; 0
    3216:	41 e0       	ldi	r20, 0x01	; 1
    3218:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
				Count = 0;
				Next = RSt14;
    321c:	83 e2       	ldi	r24, 0x23	; 35
    321e:	80 93 06 08 	sts	0x0806, r24
    3222:	97 c0       	rjmp	.+302    	; 0x3352 <APP_AC_Control+0x1c8>
				break;
			case '0' :
				Count = 0;
				Next = RSt5;
    3224:	8a e1       	ldi	r24, 0x1A	; 26
    3226:	80 93 06 08 	sts	0x0806, r24
    322a:	93 c0       	rjmp	.+294    	; 0x3352 <APP_AC_Control+0x1c8>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    322c:	88 e1       	ldi	r24, 0x18	; 24
    322e:	80 93 06 08 	sts	0x0806, r24
    3232:	8f c0       	rjmp	.+286    	; 0x3352 <APP_AC_Control+0x1c8>
			}
		}
		break;

	case User_Remote :
		transmitDataBlockOverBluetooth("[1] AC Active\n",15);
    3234:	8e e8       	ldi	r24, 0x8E	; 142
    3236:	91 e0       	ldi	r25, 0x01	; 1
    3238:	6f e0       	ldi	r22, 0x0F	; 15
    323a:	70 e0       	ldi	r23, 0x00	; 0
    323c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] AC OFF\n",12);
    3240:	8d e9       	ldi	r24, 0x9D	; 157
    3242:	91 e0       	ldi	r25, 0x01	; 1
    3244:	6c e0       	ldi	r22, 0x0C	; 12
    3246:	70 e0       	ldi	r23, 0x00	; 0
    3248:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    324c:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    3250:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    3254:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    3258:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    325a:	89 81       	ldd	r24, Y+1	; 0x01
    325c:	81 33       	cpi	r24, 0x31	; 49
    325e:	51 f0       	breq	.+20     	; 0x3274 <APP_AC_Control+0xea>
    3260:	82 33       	cpi	r24, 0x32	; 50
    3262:	18 f4       	brcc	.+6      	; 0x326a <APP_AC_Control+0xe0>
    3264:	80 33       	cpi	r24, 0x30	; 48
    3266:	91 f7       	brne	.-28     	; 0x324c <APP_AC_Control+0xc2>
    3268:	23 c0       	rjmp	.+70     	; 0x32b0 <APP_AC_Control+0x126>
    326a:	82 33       	cpi	r24, 0x32	; 50
    326c:	91 f0       	breq	.+36     	; 0x3292 <APP_AC_Control+0x108>
    326e:	83 34       	cpi	r24, 0x43	; 67
    3270:	69 f7       	brne	.-38     	; 0x324c <APP_AC_Control+0xc2>
    3272:	22 c0       	rjmp	.+68     	; 0x32b8 <APP_AC_Control+0x12e>
			{
			case '1' :

				DIO_voidSetPinDirection(DIO_u8PORTA, DIO_PIN0, Input);
    3274:	80 e0       	ldi	r24, 0x00	; 0
    3276:	60 e0       	ldi	r22, 0x00	; 0
    3278:	40 e0       	ldi	r20, 0x00	; 0
    327a:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
				Ecual_DC_Motor_Intialize(MOTOR_PORT, Motor1, Output);
    327e:	80 e0       	ldi	r24, 0x00	; 0
    3280:	62 eb       	ldi	r22, 0xB2	; 178
    3282:	77 e0       	ldi	r23, 0x07	; 7
    3284:	41 e0       	ldi	r20, 0x01	; 1
    3286:	0e 94 3f 10 	call	0x207e	; 0x207e <Ecual_DC_Motor_Intialize>
				Count = 0;
				Next = RSt22;
    328a:	8b e2       	ldi	r24, 0x2B	; 43
    328c:	80 93 06 08 	sts	0x0806, r24
    3290:	60 c0       	rjmp	.+192    	; 0x3352 <APP_AC_Control+0x1c8>
				break;
			case '2' :

				/* Set PIN Dimmer LOW*/
				Ecual_DC_Motor_Intialize(MOTOR_PORT, Motor1, Input);
    3292:	80 e0       	ldi	r24, 0x00	; 0
    3294:	62 eb       	ldi	r22, 0xB2	; 178
    3296:	77 e0       	ldi	r23, 0x07	; 7
    3298:	40 e0       	ldi	r20, 0x00	; 0
    329a:	0e 94 3f 10 	call	0x207e	; 0x207e <Ecual_DC_Motor_Intialize>
				DIO_voidSetPinDirection(DIO_u8PORTA, DIO_PIN0, Output);
    329e:	80 e0       	ldi	r24, 0x00	; 0
    32a0:	60 e0       	ldi	r22, 0x00	; 0
    32a2:	41 e0       	ldi	r20, 0x01	; 1
    32a4:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
				Count = 0;
				Next = RSt22;
    32a8:	8b e2       	ldi	r24, 0x2B	; 43
    32aa:	80 93 06 08 	sts	0x0806, r24
    32ae:	51 c0       	rjmp	.+162    	; 0x3352 <APP_AC_Control+0x1c8>
				break;
			case '0' :
				Count = 0;
				Next = RSt10;
    32b0:	8f e1       	ldi	r24, 0x1F	; 31
    32b2:	80 93 06 08 	sts	0x0806, r24
    32b6:	4d c0       	rjmp	.+154    	; 0x3352 <APP_AC_Control+0x1c8>
				break;
			case 'C' :
				Count = 0;
				Next = RSt4;
    32b8:	89 e1       	ldi	r24, 0x19	; 25
    32ba:	80 93 06 08 	sts	0x0806, r24
    32be:	49 c0       	rjmp	.+146    	; 0x3352 <APP_AC_Control+0x1c8>
				break;
			}
		}
		break;
	case User_Keypad :
		CLCD_voidGoto(1,1);
    32c0:	81 e0       	ldi	r24, 0x01	; 1
    32c2:	61 e0       	ldi	r22, 0x01	; 1
    32c4:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[1] AC Active");
    32c8:	89 ea       	ldi	r24, 0xA9	; 169
    32ca:	91 e0       	ldi	r25, 0x01	; 1
    32cc:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    32d0:	82 e0       	ldi	r24, 0x02	; 2
    32d2:	61 e0       	ldi	r22, 0x01	; 1
    32d4:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[2] AC OFF");
    32d8:	87 eb       	ldi	r24, 0xB7	; 183
    32da:	91 e0       	ldi	r25, 0x01	; 1
    32dc:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		switch(Local_u8Key)
    32e0:	80 91 fb 07 	lds	r24, 0x07FB
    32e4:	82 33       	cpi	r24, 0x32	; 50
    32e6:	c9 f0       	breq	.+50     	; 0x331a <APP_AC_Control+0x190>
    32e8:	83 33       	cpi	r24, 0x33	; 51
    32ea:	18 f4       	brcc	.+6      	; 0x32f2 <APP_AC_Control+0x168>
    32ec:	81 33       	cpi	r24, 0x31	; 49
    32ee:	89 f5       	brne	.+98     	; 0x3352 <APP_AC_Control+0x1c8>
    32f0:	05 c0       	rjmp	.+10     	; 0x32fc <APP_AC_Control+0x172>
    32f2:	83 34       	cpi	r24, 0x43	; 67
    32f4:	41 f1       	breq	.+80     	; 0x3346 <APP_AC_Control+0x1bc>
    32f6:	82 35       	cpi	r24, 0x52	; 82
    32f8:	61 f5       	brne	.+88     	; 0x3352 <APP_AC_Control+0x1c8>
    32fa:	1e c0       	rjmp	.+60     	; 0x3338 <APP_AC_Control+0x1ae>
		{
		case '1' :
			DIO_voidSetPinDirection(DIO_u8PORTA, DIO_PIN0, Input);
    32fc:	80 e0       	ldi	r24, 0x00	; 0
    32fe:	60 e0       	ldi	r22, 0x00	; 0
    3300:	40 e0       	ldi	r20, 0x00	; 0
    3302:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
			Ecual_DC_Motor_Intialize(MOTOR_PORT, Motor1, Output);
    3306:	80 e0       	ldi	r24, 0x00	; 0
    3308:	62 eb       	ldi	r22, 0xB2	; 178
    330a:	77 e0       	ldi	r23, 0x07	; 7
    330c:	41 e0       	ldi	r20, 0x01	; 1
    330e:	0e 94 3f 10 	call	0x207e	; 0x207e <Ecual_DC_Motor_Intialize>
			Next = ESt10;
    3312:	8a e0       	ldi	r24, 0x0A	; 10
    3314:	80 93 06 08 	sts	0x0806, r24
    3318:	1c c0       	rjmp	.+56     	; 0x3352 <APP_AC_Control+0x1c8>
			break;
		case '2' :
			Ecual_DC_Motor_Intialize(MOTOR_PORT, Motor1, Input);
    331a:	80 e0       	ldi	r24, 0x00	; 0
    331c:	62 eb       	ldi	r22, 0xB2	; 178
    331e:	77 e0       	ldi	r23, 0x07	; 7
    3320:	40 e0       	ldi	r20, 0x00	; 0
    3322:	0e 94 3f 10 	call	0x207e	; 0x207e <Ecual_DC_Motor_Intialize>
			DIO_voidSetPinDirection(DIO_u8PORTA, DIO_PIN0, Output);
    3326:	80 e0       	ldi	r24, 0x00	; 0
    3328:	60 e0       	ldi	r22, 0x00	; 0
    332a:	41 e0       	ldi	r20, 0x01	; 1
    332c:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
			/* Set PIN Dimmer LOW*/
			Next = ESt10;
    3330:	8a e0       	ldi	r24, 0x0A	; 10
    3332:	80 93 06 08 	sts	0x0806, r24
    3336:	0d c0       	rjmp	.+26     	; 0x3352 <APP_AC_Control+0x1c8>
			break;
		case 'R' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3338:	81 e0       	ldi	r24, 0x01	; 1
    333a:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt3;
    333e:	83 e0       	ldi	r24, 0x03	; 3
    3340:	80 93 06 08 	sts	0x0806, r24
    3344:	06 c0       	rjmp	.+12     	; 0x3352 <APP_AC_Control+0x1c8>
			break;
		case 'C' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3346:	81 e0       	ldi	r24, 0x01	; 1
    3348:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    334c:	81 e0       	ldi	r24, 0x01	; 1
    334e:	80 93 06 08 	sts	0x0806, r24
			break;
		}
		break;
	}
	return Next;
}
    3352:	80 91 06 08 	lds	r24, 0x0806
    3356:	0f 90       	pop	r0
    3358:	cf 91       	pop	r28
    335a:	df 91       	pop	r29
    335c:	08 95       	ret

0000335e <APP_RoomsStatusMenu>:
	}
	return Next;
}


static state APP_RoomsStatusMenu(Login_t Copy_LoginType){
    335e:	df 93       	push	r29
    3360:	cf 93       	push	r28
    3362:	0f 92       	push	r0
    3364:	cd b7       	in	r28, 0x3d	; 61
    3366:	de b7       	in	r29, 0x3e	; 62
	volatile uint_8 Read = 0;
    3368:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	switch(Copy_LoginType)
    336a:	81 30       	cpi	r24, 0x01	; 1
    336c:	09 f4       	brne	.+2      	; 0x3370 <APP_RoomsStatusMenu+0x12>
    336e:	5a c0       	rjmp	.+180    	; 0x3424 <APP_RoomsStatusMenu+0xc6>
    3370:	81 30       	cpi	r24, 0x01	; 1
    3372:	08 f4       	brcc	.+2      	; 0x3376 <APP_RoomsStatusMenu+0x18>
    3374:	ab c0       	rjmp	.+342    	; 0x34cc <APP_RoomsStatusMenu+0x16e>
    3376:	82 30       	cpi	r24, 0x02	; 2
    3378:	09 f0       	breq	.+2      	; 0x337c <APP_RoomsStatusMenu+0x1e>
    337a:	14 c1       	rjmp	.+552    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
	{
	case Admin :
		transmitDataBlockOverBluetooth("[1]R1\n",7);
    337c:	8d e4       	ldi	r24, 0x4D	; 77
    337e:	91 e0       	ldi	r25, 0x01	; 1
    3380:	67 e0       	ldi	r22, 0x07	; 7
    3382:	70 e0       	ldi	r23, 0x00	; 0
    3384:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2]R2\n",7);
    3388:	84 e5       	ldi	r24, 0x54	; 84
    338a:	91 e0       	ldi	r25, 0x01	; 1
    338c:	67 e0       	ldi	r22, 0x07	; 7
    338e:	70 e0       	ldi	r23, 0x00	; 0
    3390:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[3]R3\n",7);
    3394:	8b e5       	ldi	r24, 0x5B	; 91
    3396:	91 e0       	ldi	r25, 0x01	; 1
    3398:	67 e0       	ldi	r22, 0x07	; 7
    339a:	70 e0       	ldi	r23, 0x00	; 0
    339c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[4]R4\n",7);
    33a0:	82 e6       	ldi	r24, 0x62	; 98
    33a2:	91 e0       	ldi	r25, 0x01	; 1
    33a4:	67 e0       	ldi	r22, 0x07	; 7
    33a6:	70 e0       	ldi	r23, 0x00	; 0
    33a8:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[5]R5\n",7);
    33ac:	89 e6       	ldi	r24, 0x69	; 105
    33ae:	91 e0       	ldi	r25, 0x01	; 1
    33b0:	67 e0       	ldi	r22, 0x07	; 7
    33b2:	70 e0       	ldi	r23, 0x00	; 0
    33b4:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    33b8:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    33bc:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    33c0:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    33c4:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    33c6:	89 81       	ldd	r24, Y+1	; 0x01
    33c8:	83 33       	cpi	r24, 0x33	; 51
    33ca:	c1 f0       	breq	.+48     	; 0x33fc <APP_RoomsStatusMenu+0x9e>
    33cc:	84 33       	cpi	r24, 0x34	; 52
    33ce:	38 f4       	brcc	.+14     	; 0x33de <APP_RoomsStatusMenu+0x80>
    33d0:	81 33       	cpi	r24, 0x31	; 49
    33d2:	61 f0       	breq	.+24     	; 0x33ec <APP_RoomsStatusMenu+0x8e>
    33d4:	82 33       	cpi	r24, 0x32	; 50
    33d6:	70 f4       	brcc	.+28     	; 0x33f4 <APP_RoomsStatusMenu+0x96>
    33d8:	80 33       	cpi	r24, 0x30	; 48
    33da:	71 f7       	brne	.-36     	; 0x33b8 <APP_RoomsStatusMenu+0x5a>
    33dc:	1b c0       	rjmp	.+54     	; 0x3414 <APP_RoomsStatusMenu+0xb6>
    33de:	85 33       	cpi	r24, 0x35	; 53
    33e0:	a9 f0       	breq	.+42     	; 0x340c <APP_RoomsStatusMenu+0xae>
    33e2:	85 33       	cpi	r24, 0x35	; 53
    33e4:	78 f0       	brcs	.+30     	; 0x3404 <APP_RoomsStatusMenu+0xa6>
    33e6:	83 34       	cpi	r24, 0x43	; 67
    33e8:	39 f7       	brne	.-50     	; 0x33b8 <APP_RoomsStatusMenu+0x5a>
    33ea:	18 c0       	rjmp	.+48     	; 0x341c <APP_RoomsStatusMenu+0xbe>
			{
			case '1' :
				Count = 0;
				Next = RSt32;
    33ec:	85 e3       	ldi	r24, 0x35	; 53
    33ee:	80 93 06 08 	sts	0x0806, r24
    33f2:	d8 c0       	rjmp	.+432    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;

			case '2' :
				Count = 0;
				Next = RSt33;
    33f4:	86 e3       	ldi	r24, 0x36	; 54
    33f6:	80 93 06 08 	sts	0x0806, r24
    33fa:	d4 c0       	rjmp	.+424    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;
			case '3' :
				Count = 0;
				Next = RSt34;
    33fc:	87 e3       	ldi	r24, 0x37	; 55
    33fe:	80 93 06 08 	sts	0x0806, r24
    3402:	d0 c0       	rjmp	.+416    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;
			case '4' :
				Count = 0;
				Next = RSt35;
    3404:	88 e3       	ldi	r24, 0x38	; 56
    3406:	80 93 06 08 	sts	0x0806, r24
    340a:	cc c0       	rjmp	.+408    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;
			case '5' :
				Count = 0;
				Next = RSt36;
    340c:	89 e3       	ldi	r24, 0x39	; 57
    340e:	80 93 06 08 	sts	0x0806, r24
    3412:	c8 c0       	rjmp	.+400    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;
			case '0' :
				Count = 0;
				Next = RSt6;
    3414:	8b e1       	ldi	r24, 0x1B	; 27
    3416:	80 93 06 08 	sts	0x0806, r24
    341a:	c4 c0       	rjmp	.+392    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    341c:	88 e1       	ldi	r24, 0x18	; 24
    341e:	80 93 06 08 	sts	0x0806, r24
    3422:	c0 c0       	rjmp	.+384    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
			}
		}
		break;

	case User_Remote :
		transmitDataBlockOverBluetooth("[1]R1\n",7);
    3424:	8d e4       	ldi	r24, 0x4D	; 77
    3426:	91 e0       	ldi	r25, 0x01	; 1
    3428:	67 e0       	ldi	r22, 0x07	; 7
    342a:	70 e0       	ldi	r23, 0x00	; 0
    342c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2]R2\n",7);
    3430:	84 e5       	ldi	r24, 0x54	; 84
    3432:	91 e0       	ldi	r25, 0x01	; 1
    3434:	67 e0       	ldi	r22, 0x07	; 7
    3436:	70 e0       	ldi	r23, 0x00	; 0
    3438:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[3]R3\n",7);
    343c:	8b e5       	ldi	r24, 0x5B	; 91
    343e:	91 e0       	ldi	r25, 0x01	; 1
    3440:	67 e0       	ldi	r22, 0x07	; 7
    3442:	70 e0       	ldi	r23, 0x00	; 0
    3444:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[4]R4\n",7);
    3448:	82 e6       	ldi	r24, 0x62	; 98
    344a:	91 e0       	ldi	r25, 0x01	; 1
    344c:	67 e0       	ldi	r22, 0x07	; 7
    344e:	70 e0       	ldi	r23, 0x00	; 0
    3450:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[5]R5\n",7);
    3454:	89 e6       	ldi	r24, 0x69	; 105
    3456:	91 e0       	ldi	r25, 0x01	; 1
    3458:	67 e0       	ldi	r22, 0x07	; 7
    345a:	70 e0       	ldi	r23, 0x00	; 0
    345c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    3460:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    3464:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    3468:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    346c:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    346e:	89 81       	ldd	r24, Y+1	; 0x01
    3470:	83 33       	cpi	r24, 0x33	; 51
    3472:	c1 f0       	breq	.+48     	; 0x34a4 <APP_RoomsStatusMenu+0x146>
    3474:	84 33       	cpi	r24, 0x34	; 52
    3476:	38 f4       	brcc	.+14     	; 0x3486 <APP_RoomsStatusMenu+0x128>
    3478:	81 33       	cpi	r24, 0x31	; 49
    347a:	61 f0       	breq	.+24     	; 0x3494 <APP_RoomsStatusMenu+0x136>
    347c:	82 33       	cpi	r24, 0x32	; 50
    347e:	70 f4       	brcc	.+28     	; 0x349c <APP_RoomsStatusMenu+0x13e>
    3480:	80 33       	cpi	r24, 0x30	; 48
    3482:	71 f7       	brne	.-36     	; 0x3460 <APP_RoomsStatusMenu+0x102>
    3484:	1b c0       	rjmp	.+54     	; 0x34bc <APP_RoomsStatusMenu+0x15e>
    3486:	85 33       	cpi	r24, 0x35	; 53
    3488:	a9 f0       	breq	.+42     	; 0x34b4 <APP_RoomsStatusMenu+0x156>
    348a:	85 33       	cpi	r24, 0x35	; 53
    348c:	78 f0       	brcs	.+30     	; 0x34ac <APP_RoomsStatusMenu+0x14e>
    348e:	83 34       	cpi	r24, 0x43	; 67
    3490:	39 f7       	brne	.-50     	; 0x3460 <APP_RoomsStatusMenu+0x102>
    3492:	18 c0       	rjmp	.+48     	; 0x34c4 <APP_RoomsStatusMenu+0x166>
			{
			case '1' :
				Count = 0;
				Next = RSt42;
    3494:	8f e3       	ldi	r24, 0x3F	; 63
    3496:	80 93 06 08 	sts	0x0806, r24
    349a:	84 c0       	rjmp	.+264    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;
			case '2' :
				Count = 0;
				Next = RSt43;
    349c:	80 e4       	ldi	r24, 0x40	; 64
    349e:	80 93 06 08 	sts	0x0806, r24
    34a2:	80 c0       	rjmp	.+256    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;
			case '3' :
				Count = 0;
				Next = RSt44;
    34a4:	81 e4       	ldi	r24, 0x41	; 65
    34a6:	80 93 06 08 	sts	0x0806, r24
    34aa:	7c c0       	rjmp	.+248    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;
			case '4' :
				Count = 0;
				Next = RSt45;
    34ac:	82 e4       	ldi	r24, 0x42	; 66
    34ae:	80 93 06 08 	sts	0x0806, r24
    34b2:	78 c0       	rjmp	.+240    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;
			case '5' :
				Count = 0;
				Next = RSt46;
    34b4:	83 e4       	ldi	r24, 0x43	; 67
    34b6:	80 93 06 08 	sts	0x0806, r24
    34ba:	74 c0       	rjmp	.+232    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;
			case '0' :
				Count = 0;
				Next = RSt11;
    34bc:	80 e2       	ldi	r24, 0x20	; 32
    34be:	80 93 06 08 	sts	0x0806, r24
    34c2:	70 c0       	rjmp	.+224    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;
			case 'C' :
				Count = 0;
				Next = RSt4;
    34c4:	89 e1       	ldi	r24, 0x19	; 25
    34c6:	80 93 06 08 	sts	0x0806, r24
    34ca:	6c c0       	rjmp	.+216    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
				break;
			}
		}
		break;
	case User_Keypad :
		CLCD_voidGoto(1,1);
    34cc:	81 e0       	ldi	r24, 0x01	; 1
    34ce:	61 e0       	ldi	r22, 0x01	; 1
    34d0:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[1]R1");
    34d4:	80 e7       	ldi	r24, 0x70	; 112
    34d6:	91 e0       	ldi	r25, 0x01	; 1
    34d8:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    34dc:	82 e0       	ldi	r24, 0x02	; 2
    34de:	61 e0       	ldi	r22, 0x01	; 1
    34e0:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[2]R2");
    34e4:	86 e7       	ldi	r24, 0x76	; 118
    34e6:	91 e0       	ldi	r25, 0x01	; 1
    34e8:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(3,1);
    34ec:	83 e0       	ldi	r24, 0x03	; 3
    34ee:	61 e0       	ldi	r22, 0x01	; 1
    34f0:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[3]R3");
    34f4:	8c e7       	ldi	r24, 0x7C	; 124
    34f6:	91 e0       	ldi	r25, 0x01	; 1
    34f8:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(4,1);
    34fc:	84 e0       	ldi	r24, 0x04	; 4
    34fe:	61 e0       	ldi	r22, 0x01	; 1
    3500:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[4]R4");
    3504:	82 e8       	ldi	r24, 0x82	; 130
    3506:	91 e0       	ldi	r25, 0x01	; 1
    3508:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(1,8);
    350c:	81 e0       	ldi	r24, 0x01	; 1
    350e:	68 e0       	ldi	r22, 0x08	; 8
    3510:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[5]R5");
    3514:	88 e8       	ldi	r24, 0x88	; 136
    3516:	91 e0       	ldi	r25, 0x01	; 1
    3518:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		switch(Local_u8Key)
    351c:	80 91 fb 07 	lds	r24, 0x07FB
    3520:	84 33       	cpi	r24, 0x34	; 52
    3522:	29 f1       	breq	.+74     	; 0x356e <APP_RoomsStatusMenu+0x210>
    3524:	85 33       	cpi	r24, 0x35	; 53
    3526:	38 f4       	brcc	.+14     	; 0x3536 <APP_RoomsStatusMenu+0x1d8>
    3528:	82 33       	cpi	r24, 0x32	; 50
    352a:	99 f0       	breq	.+38     	; 0x3552 <APP_RoomsStatusMenu+0x1f4>
    352c:	83 33       	cpi	r24, 0x33	; 51
    352e:	c0 f4       	brcc	.+48     	; 0x3560 <APP_RoomsStatusMenu+0x202>
    3530:	81 33       	cpi	r24, 0x31	; 49
    3532:	c1 f5       	brne	.+112    	; 0x35a4 <APP_RoomsStatusMenu+0x246>
    3534:	07 c0       	rjmp	.+14     	; 0x3544 <APP_RoomsStatusMenu+0x1e6>
    3536:	83 34       	cpi	r24, 0x43	; 67
    3538:	79 f1       	breq	.+94     	; 0x3598 <APP_RoomsStatusMenu+0x23a>
    353a:	82 35       	cpi	r24, 0x52	; 82
    353c:	31 f1       	breq	.+76     	; 0x358a <APP_RoomsStatusMenu+0x22c>
    353e:	85 33       	cpi	r24, 0x35	; 53
    3540:	89 f5       	brne	.+98     	; 0x35a4 <APP_RoomsStatusMenu+0x246>
    3542:	1c c0       	rjmp	.+56     	; 0x357c <APP_RoomsStatusMenu+0x21e>
		{
		case '1' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3544:	81 e0       	ldi	r24, 0x01	; 1
    3546:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt17;
    354a:	80 e1       	ldi	r24, 0x10	; 16
    354c:	80 93 06 08 	sts	0x0806, r24
    3550:	29 c0       	rjmp	.+82     	; 0x35a4 <APP_RoomsStatusMenu+0x246>
			break;

		case '2' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3552:	81 e0       	ldi	r24, 0x01	; 1
    3554:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt18;
    3558:	81 e1       	ldi	r24, 0x11	; 17
    355a:	80 93 06 08 	sts	0x0806, r24
    355e:	22 c0       	rjmp	.+68     	; 0x35a4 <APP_RoomsStatusMenu+0x246>
			break;
		case '3' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3560:	81 e0       	ldi	r24, 0x01	; 1
    3562:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt19;
    3566:	82 e1       	ldi	r24, 0x12	; 18
    3568:	80 93 06 08 	sts	0x0806, r24
    356c:	1b c0       	rjmp	.+54     	; 0x35a4 <APP_RoomsStatusMenu+0x246>
			break;
		case '4' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    356e:	81 e0       	ldi	r24, 0x01	; 1
    3570:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt20;
    3574:	83 e1       	ldi	r24, 0x13	; 19
    3576:	80 93 06 08 	sts	0x0806, r24
    357a:	14 c0       	rjmp	.+40     	; 0x35a4 <APP_RoomsStatusMenu+0x246>
			break;
		case '5' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    357c:	81 e0       	ldi	r24, 0x01	; 1
    357e:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt21;
    3582:	84 e1       	ldi	r24, 0x14	; 20
    3584:	80 93 06 08 	sts	0x0806, r24
    3588:	0d c0       	rjmp	.+26     	; 0x35a4 <APP_RoomsStatusMenu+0x246>
			break;
		case 'R' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    358a:	81 e0       	ldi	r24, 0x01	; 1
    358c:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt2;
    3590:	82 e0       	ldi	r24, 0x02	; 2
    3592:	80 93 06 08 	sts	0x0806, r24
    3596:	06 c0       	rjmp	.+12     	; 0x35a4 <APP_RoomsStatusMenu+0x246>
			break;
		case 'C' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3598:	81 e0       	ldi	r24, 0x01	; 1
    359a:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    359e:	81 e0       	ldi	r24, 0x01	; 1
    35a0:	80 93 06 08 	sts	0x0806, r24
			break;
		}
		break;
	}
	return Next;
}
    35a4:	80 91 06 08 	lds	r24, 0x0806
    35a8:	0f 90       	pop	r0
    35aa:	cf 91       	pop	r28
    35ac:	df 91       	pop	r29
    35ae:	08 95       	ret

000035b0 <APP_DimmerStatus>:

static state APP_DimmerStatus(Login_t Copy_LoginType){
    35b0:	df 93       	push	r29
    35b2:	cf 93       	push	r28
    35b4:	0f 92       	push	r0
    35b6:	cd b7       	in	r28, 0x3d	; 61
    35b8:	de b7       	in	r29, 0x3e	; 62
	Led_State Local_ReadDimmerState = 0;
	volatile uint_8 Read = 0;
    35ba:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;
	switch(Copy_LoginType)
    35bc:	81 30       	cpi	r24, 0x01	; 1
    35be:	81 f1       	breq	.+96     	; 0x3620 <APP_DimmerStatus+0x70>
    35c0:	81 30       	cpi	r24, 0x01	; 1
    35c2:	08 f4       	brcc	.+2      	; 0x35c6 <APP_DimmerStatus+0x16>
    35c4:	5c c0       	rjmp	.+184    	; 0x367e <APP_DimmerStatus+0xce>
    35c6:	82 30       	cpi	r24, 0x02	; 2
    35c8:	09 f0       	breq	.+2      	; 0x35cc <APP_DimmerStatus+0x1c>
    35ca:	85 c0       	rjmp	.+266    	; 0x36d6 <APP_DimmerStatus+0x126>
	{
	case Admin :
		/* Function to Read Dimmer State*/
		//Local_ReadDimmerState = GET_BIT(DDRD, DIO_PIN4);
		Local_ReadDimmerState = DIO_u8GetPinValue(DIO_u8PORTD, DIO_PIN4);
    35cc:	83 e0       	ldi	r24, 0x03	; 3
    35ce:	64 e0       	ldi	r22, 0x04	; 4
    35d0:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <DIO_u8GetPinValue>
		//Ecual_DC_Motor_Status(MOTOR_PORT, Motor1);
		switch(Local_ReadDimmerState)
    35d4:	88 23       	and	r24, r24
    35d6:	49 f0       	breq	.+18     	; 0x35ea <APP_DimmerStatus+0x3a>
    35d8:	81 30       	cpi	r24, 0x01	; 1
    35da:	69 f4       	brne	.+26     	; 0x35f6 <APP_DimmerStatus+0x46>
		{
		case High :
			transmitDataBlockOverBluetooth("DIMMIR IS ON\n",14);
    35dc:	82 ec       	ldi	r24, 0xC2	; 194
    35de:	91 e0       	ldi	r25, 0x01	; 1
    35e0:	6e e0       	ldi	r22, 0x0E	; 14
    35e2:	70 e0       	ldi	r23, 0x00	; 0
    35e4:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    35e8:	06 c0       	rjmp	.+12     	; 0x35f6 <APP_DimmerStatus+0x46>
			break;
		case Low :
			transmitDataBlockOverBluetooth("DIMMIR IS OFF\n",15);
    35ea:	80 ed       	ldi	r24, 0xD0	; 208
    35ec:	91 e0       	ldi	r25, 0x01	; 1
    35ee:	6f e0       	ldi	r22, 0x0F	; 15
    35f0:	70 e0       	ldi	r23, 0x00	; 0
    35f2:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
			break;
		}
		while(Count){
				APP_SystemState();
    35f6:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    35fa:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    35fe:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    3602:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    3604:	89 81       	ldd	r24, Y+1	; 0x01
    3606:	80 33       	cpi	r24, 0x30	; 48
    3608:	19 f0       	breq	.+6      	; 0x3610 <APP_DimmerStatus+0x60>
    360a:	83 34       	cpi	r24, 0x43	; 67
    360c:	a1 f7       	brne	.-24     	; 0x35f6 <APP_DimmerStatus+0x46>
    360e:	04 c0       	rjmp	.+8      	; 0x3618 <APP_DimmerStatus+0x68>
			{
			case '0' :
				Count = 0;
				Next = RSt6;
    3610:	8b e1       	ldi	r24, 0x1B	; 27
    3612:	80 93 06 08 	sts	0x0806, r24
    3616:	5f c0       	rjmp	.+190    	; 0x36d6 <APP_DimmerStatus+0x126>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    3618:	88 e1       	ldi	r24, 0x18	; 24
    361a:	80 93 06 08 	sts	0x0806, r24
    361e:	5b c0       	rjmp	.+182    	; 0x36d6 <APP_DimmerStatus+0x126>
		break;

		case User_Remote :
			/* Function to Read Dimmer State*/
			//Local_ReadDimmerState = GET_BIT(DDRD, DIO_PIN4);
			Local_ReadDimmerState = DIO_u8GetPinValue(DIO_u8PORTD, DIO_PIN4);
    3620:	83 e0       	ldi	r24, 0x03	; 3
    3622:	64 e0       	ldi	r22, 0x04	; 4
    3624:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <DIO_u8GetPinValue>
			//Ecual_DC_Motor_Status(MOTOR_PORT, Motor1);
			switch(Local_ReadDimmerState)
    3628:	88 23       	and	r24, r24
    362a:	49 f0       	breq	.+18     	; 0x363e <APP_DimmerStatus+0x8e>
    362c:	81 30       	cpi	r24, 0x01	; 1
    362e:	69 f4       	brne	.+26     	; 0x364a <APP_DimmerStatus+0x9a>
			{
			case High :
				transmitDataBlockOverBluetooth("DIMMIR IS ON\n",14);
    3630:	82 ec       	ldi	r24, 0xC2	; 194
    3632:	91 e0       	ldi	r25, 0x01	; 1
    3634:	6e e0       	ldi	r22, 0x0E	; 14
    3636:	70 e0       	ldi	r23, 0x00	; 0
    3638:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    363c:	06 c0       	rjmp	.+12     	; 0x364a <APP_DimmerStatus+0x9a>
				break;
			case Low :
				transmitDataBlockOverBluetooth("DIMMIR IS OFF\n",15);
    363e:	80 ed       	ldi	r24, 0xD0	; 208
    3640:	91 e0       	ldi	r25, 0x01	; 1
    3642:	6f e0       	ldi	r22, 0x0F	; 15
    3644:	70 e0       	ldi	r23, 0x00	; 0
    3646:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				break;
			}
			Read = UART_ReceiveChar();
    364a:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
    364e:	89 83       	std	Y+1, r24	; 0x01
    3650:	12 c0       	rjmp	.+36     	; 0x3676 <APP_DimmerStatus+0xc6>
			while(Count && Read){

				APP_SystemState();
    3652:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    3656:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				switch(Read)
    365a:	89 81       	ldd	r24, Y+1	; 0x01
    365c:	80 33       	cpi	r24, 0x30	; 48
    365e:	19 f0       	breq	.+6      	; 0x3666 <APP_DimmerStatus+0xb6>
    3660:	83 34       	cpi	r24, 0x43	; 67
    3662:	49 f4       	brne	.+18     	; 0x3676 <APP_DimmerStatus+0xc6>
    3664:	04 c0       	rjmp	.+8      	; 0x366e <APP_DimmerStatus+0xbe>
				{
				case '0' :
					Count = 0;
					Next = RSt11;
    3666:	80 e2       	ldi	r24, 0x20	; 32
    3668:	80 93 06 08 	sts	0x0806, r24
    366c:	34 c0       	rjmp	.+104    	; 0x36d6 <APP_DimmerStatus+0x126>
					break;
				case 'C' :
					Count = 0;
					Next = RSt4;
    366e:	89 e1       	ldi	r24, 0x19	; 25
    3670:	80 93 06 08 	sts	0x0806, r24
    3674:	30 c0       	rjmp	.+96     	; 0x36d6 <APP_DimmerStatus+0x126>
			case Low :
				transmitDataBlockOverBluetooth("DIMMIR IS OFF\n",15);
				break;
			}
			Read = UART_ReceiveChar();
			while(Count && Read){
    3676:	89 81       	ldd	r24, Y+1	; 0x01
    3678:	88 23       	and	r24, r24
    367a:	59 f7       	brne	.-42     	; 0x3652 <APP_DimmerStatus+0xa2>
    367c:	2c c0       	rjmp	.+88     	; 0x36d6 <APP_DimmerStatus+0x126>
			}
			break;
			case User_Keypad :
				/* Function to Read Dimmer State*/
				//Local_ReadDimmerState = GET_BIT(DDRD, DIO_PIN4);
				Local_ReadDimmerState = DIO_u8GetPinValue(DIO_u8PORTD, DIO_PIN4);
    367e:	83 e0       	ldi	r24, 0x03	; 3
    3680:	64 e0       	ldi	r22, 0x04	; 4
    3682:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <DIO_u8GetPinValue>
				//Ecual_DC_Motor_Status(MOTOR_PORT, Motor1);
				switch(Local_ReadDimmerState)
    3686:	88 23       	and	r24, r24
    3688:	59 f0       	breq	.+22     	; 0x36a0 <APP_DimmerStatus+0xf0>
    368a:	81 30       	cpi	r24, 0x01	; 1
    368c:	89 f4       	brne	.+34     	; 0x36b0 <APP_DimmerStatus+0x100>
				{
				case High :
					CLCD_voidGoto(1,1);
    368e:	81 e0       	ldi	r24, 0x01	; 1
    3690:	61 e0       	ldi	r22, 0x01	; 1
    3692:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("DIMMIR IS ON");
    3696:	8f ed       	ldi	r24, 0xDF	; 223
    3698:	91 e0       	ldi	r25, 0x01	; 1
    369a:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    369e:	08 c0       	rjmp	.+16     	; 0x36b0 <APP_DimmerStatus+0x100>
					break;
				case Low :
					CLCD_voidGoto(1,1);
    36a0:	81 e0       	ldi	r24, 0x01	; 1
    36a2:	61 e0       	ldi	r22, 0x01	; 1
    36a4:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("DIMMIR IS OFF");
    36a8:	8c ee       	ldi	r24, 0xEC	; 236
    36aa:	91 e0       	ldi	r25, 0x01	; 1
    36ac:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
					break;
				}
				switch(Local_u8Key)
    36b0:	80 91 fb 07 	lds	r24, 0x07FB
    36b4:	83 34       	cpi	r24, 0x43	; 67
    36b6:	49 f0       	breq	.+18     	; 0x36ca <APP_DimmerStatus+0x11a>
    36b8:	82 35       	cpi	r24, 0x52	; 82
    36ba:	69 f4       	brne	.+26     	; 0x36d6 <APP_DimmerStatus+0x126>
				{
				case 'R' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    36bc:	81 e0       	ldi	r24, 0x01	; 1
    36be:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt2;
    36c2:	82 e0       	ldi	r24, 0x02	; 2
    36c4:	80 93 06 08 	sts	0x0806, r24
    36c8:	06 c0       	rjmp	.+12     	; 0x36d6 <APP_DimmerStatus+0x126>
					break;

				case 'C' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    36ca:	81 e0       	ldi	r24, 0x01	; 1
    36cc:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt1;
    36d0:	81 e0       	ldi	r24, 0x01	; 1
    36d2:	80 93 06 08 	sts	0x0806, r24
					break;
				}
	}
	return Next;
}
    36d6:	80 91 06 08 	lds	r24, 0x0806
    36da:	0f 90       	pop	r0
    36dc:	cf 91       	pop	r28
    36de:	df 91       	pop	r29
    36e0:	08 95       	ret

000036e2 <APP_AC_Status>:
static state APP_AC_Status(Login_t Copy_LoginType){
    36e2:	df 93       	push	r29
    36e4:	cf 93       	push	r28
    36e6:	0f 92       	push	r0
    36e8:	cd b7       	in	r28, 0x3d	; 61
    36ea:	de b7       	in	r29, 0x3e	; 62
	volatile uint_8 Read = 0;
    36ec:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;
	Motor_State  Local_u8DCMotorState = MotorStop;
	switch(Copy_LoginType)
    36ee:	81 30       	cpi	r24, 0x01	; 1
    36f0:	b9 f1       	breq	.+110    	; 0x3760 <APP_AC_Status+0x7e>
    36f2:	81 30       	cpi	r24, 0x01	; 1
    36f4:	08 f4       	brcc	.+2      	; 0x36f8 <APP_AC_Status+0x16>
    36f6:	6a c0       	rjmp	.+212    	; 0x37cc <APP_AC_Status+0xea>
    36f8:	82 30       	cpi	r24, 0x02	; 2
    36fa:	09 f0       	breq	.+2      	; 0x36fe <APP_AC_Status+0x1c>
    36fc:	9c c0       	rjmp	.+312    	; 0x3836 <APP_AC_Status+0x154>
	{
	case Admin :
		Local_u8DCMotorState = DIO_u8GetPinDirection(DIO_u8PORTD, DIO_PIN1);
    36fe:	83 e0       	ldi	r24, 0x03	; 3
    3700:	61 e0       	ldi	r22, 0x01	; 1
    3702:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <DIO_u8GetPinDirection>
		//Ecual_DC_Motor_Status(MOTOR_PORT, Motor1);
		switch(Local_u8DCMotorState)
    3706:	88 23       	and	r24, r24
    3708:	49 f0       	breq	.+18     	; 0x371c <APP_AC_Status+0x3a>
    370a:	81 30       	cpi	r24, 0x01	; 1
    370c:	71 f4       	brne	.+28     	; 0x372a <APP_AC_Status+0x48>
		{
		case Output :
			transmitDataBlockOverBluetooth("AC IS ACTIVE\n",11);
    370e:	8a ef       	ldi	r24, 0xFA	; 250
    3710:	91 e0       	ldi	r25, 0x01	; 1
    3712:	6b e0       	ldi	r22, 0x0B	; 11
    3714:	70 e0       	ldi	r23, 0x00	; 0
    3716:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    371a:	0d c0       	rjmp	.+26     	; 0x3736 <APP_AC_Status+0x54>

			break;
		case Input :
			transmitDataBlockOverBluetooth("AC IS OFF\n",10);
    371c:	88 e0       	ldi	r24, 0x08	; 8
    371e:	92 e0       	ldi	r25, 0x02	; 2
    3720:	6a e0       	ldi	r22, 0x0A	; 10
    3722:	70 e0       	ldi	r23, 0x00	; 0
    3724:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    3728:	06 c0       	rjmp	.+12     	; 0x3736 <APP_AC_Status+0x54>
			break;
		default :
			transmitDataBlockOverBluetooth("AC IS OFF\n",10);
    372a:	88 e0       	ldi	r24, 0x08	; 8
    372c:	92 e0       	ldi	r25, 0x02	; 2
    372e:	6a e0       	ldi	r22, 0x0A	; 10
    3730:	70 e0       	ldi	r23, 0x00	; 0
    3732:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
			break;
		}
		while(Count){
				APP_SystemState();
    3736:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    373a:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    373e:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    3742:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    3744:	89 81       	ldd	r24, Y+1	; 0x01
    3746:	80 33       	cpi	r24, 0x30	; 48
    3748:	19 f0       	breq	.+6      	; 0x3750 <APP_AC_Status+0x6e>
    374a:	83 34       	cpi	r24, 0x43	; 67
    374c:	a1 f7       	brne	.-24     	; 0x3736 <APP_AC_Status+0x54>
    374e:	04 c0       	rjmp	.+8      	; 0x3758 <APP_AC_Status+0x76>
			{
			case '0' :
				Count = 0;
				Next = RSt6;
    3750:	8b e1       	ldi	r24, 0x1B	; 27
    3752:	80 93 06 08 	sts	0x0806, r24
    3756:	6f c0       	rjmp	.+222    	; 0x3836 <APP_AC_Status+0x154>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    3758:	88 e1       	ldi	r24, 0x18	; 24
    375a:	80 93 06 08 	sts	0x0806, r24
    375e:	6b c0       	rjmp	.+214    	; 0x3836 <APP_AC_Status+0x154>
			}
		}
		break;

		case User_Remote :
			Local_u8DCMotorState = DIO_u8GetPinDirection(DIO_u8PORTD, DIO_PIN1);
    3760:	83 e0       	ldi	r24, 0x03	; 3
    3762:	61 e0       	ldi	r22, 0x01	; 1
    3764:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <DIO_u8GetPinDirection>
			//Ecual_DC_Motor_Status(MOTOR_PORT, Motor1);
			switch(Local_u8DCMotorState)
    3768:	88 23       	and	r24, r24
    376a:	49 f0       	breq	.+18     	; 0x377e <APP_AC_Status+0x9c>
    376c:	81 30       	cpi	r24, 0x01	; 1
    376e:	71 f4       	brne	.+28     	; 0x378c <APP_AC_Status+0xaa>
			{
			case Output :
				transmitDataBlockOverBluetooth("AC IS ACTIVE\n",11);
    3770:	8a ef       	ldi	r24, 0xFA	; 250
    3772:	91 e0       	ldi	r25, 0x01	; 1
    3774:	6b e0       	ldi	r22, 0x0B	; 11
    3776:	70 e0       	ldi	r23, 0x00	; 0
    3778:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    377c:	0d c0       	rjmp	.+26     	; 0x3798 <APP_AC_Status+0xb6>
				break;
			case Input :
				transmitDataBlockOverBluetooth("AC IS OFF\n",10);
    377e:	88 e0       	ldi	r24, 0x08	; 8
    3780:	92 e0       	ldi	r25, 0x02	; 2
    3782:	6a e0       	ldi	r22, 0x0A	; 10
    3784:	70 e0       	ldi	r23, 0x00	; 0
    3786:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    378a:	06 c0       	rjmp	.+12     	; 0x3798 <APP_AC_Status+0xb6>
				break;
			default :
				transmitDataBlockOverBluetooth("AC IS OFF\n",10);
    378c:	88 e0       	ldi	r24, 0x08	; 8
    378e:	92 e0       	ldi	r25, 0x02	; 2
    3790:	6a e0       	ldi	r22, 0x0A	; 10
    3792:	70 e0       	ldi	r23, 0x00	; 0
    3794:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				break;
			}
			Read = UART_ReceiveChar();
    3798:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
    379c:	89 83       	std	Y+1, r24	; 0x01
    379e:	12 c0       	rjmp	.+36     	; 0x37c4 <APP_AC_Status+0xe2>
			while(Count && Read){

				APP_SystemState();
    37a0:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    37a4:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				switch(Read)
    37a8:	89 81       	ldd	r24, Y+1	; 0x01
    37aa:	80 33       	cpi	r24, 0x30	; 48
    37ac:	19 f0       	breq	.+6      	; 0x37b4 <APP_AC_Status+0xd2>
    37ae:	83 34       	cpi	r24, 0x43	; 67
    37b0:	49 f4       	brne	.+18     	; 0x37c4 <APP_AC_Status+0xe2>
    37b2:	04 c0       	rjmp	.+8      	; 0x37bc <APP_AC_Status+0xda>
				{
				case '0' :
					Count = 0;
					Next = RSt11;
    37b4:	80 e2       	ldi	r24, 0x20	; 32
    37b6:	80 93 06 08 	sts	0x0806, r24
    37ba:	3d c0       	rjmp	.+122    	; 0x3836 <APP_AC_Status+0x154>
					break;
				case 'C' :
					Count = 0;
					Next = RSt4;
    37bc:	89 e1       	ldi	r24, 0x19	; 25
    37be:	80 93 06 08 	sts	0x0806, r24
    37c2:	39 c0       	rjmp	.+114    	; 0x3836 <APP_AC_Status+0x154>
			default :
				transmitDataBlockOverBluetooth("AC IS OFF\n",10);
				break;
			}
			Read = UART_ReceiveChar();
			while(Count && Read){
    37c4:	89 81       	ldd	r24, Y+1	; 0x01
    37c6:	88 23       	and	r24, r24
    37c8:	59 f7       	brne	.-42     	; 0x37a0 <APP_AC_Status+0xbe>
    37ca:	35 c0       	rjmp	.+106    	; 0x3836 <APP_AC_Status+0x154>
					break;
				}
			}
			break;
			case User_Keypad :
				Local_u8DCMotorState = DIO_u8GetPinDirection(DIO_u8PORTD, DIO_PIN1);
    37cc:	83 e0       	ldi	r24, 0x03	; 3
    37ce:	61 e0       	ldi	r22, 0x01	; 1
    37d0:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <DIO_u8GetPinDirection>
				//Ecual_DC_Motor_Status(MOTOR_PORT, Motor1);
				switch(Local_u8DCMotorState)
    37d4:	88 23       	and	r24, r24
    37d6:	59 f0       	breq	.+22     	; 0x37ee <APP_AC_Status+0x10c>
    37d8:	81 30       	cpi	r24, 0x01	; 1
    37da:	91 f4       	brne	.+36     	; 0x3800 <APP_AC_Status+0x11e>
				{
				case Output :
					CLCD_voidGoto(1,1);
    37dc:	81 e0       	ldi	r24, 0x01	; 1
    37de:	61 e0       	ldi	r22, 0x01	; 1
    37e0:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("AC IS ACTIVE");
    37e4:	83 e1       	ldi	r24, 0x13	; 19
    37e6:	92 e0       	ldi	r25, 0x02	; 2
    37e8:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    37ec:	11 c0       	rjmp	.+34     	; 0x3810 <APP_AC_Status+0x12e>
					break;
				case Input :
					CLCD_voidGoto(1,1);
    37ee:	81 e0       	ldi	r24, 0x01	; 1
    37f0:	61 e0       	ldi	r22, 0x01	; 1
    37f2:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("AC IS OFF");
    37f6:	80 e2       	ldi	r24, 0x20	; 32
    37f8:	92 e0       	ldi	r25, 0x02	; 2
    37fa:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    37fe:	08 c0       	rjmp	.+16     	; 0x3810 <APP_AC_Status+0x12e>
					break;
				default :
					CLCD_voidGoto(1,1);
    3800:	81 e0       	ldi	r24, 0x01	; 1
    3802:	61 e0       	ldi	r22, 0x01	; 1
    3804:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("AC IS OFF");
    3808:	80 e2       	ldi	r24, 0x20	; 32
    380a:	92 e0       	ldi	r25, 0x02	; 2
    380c:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
					break;
				}
				switch(Local_u8Key)
    3810:	80 91 fb 07 	lds	r24, 0x07FB
    3814:	83 34       	cpi	r24, 0x43	; 67
    3816:	49 f0       	breq	.+18     	; 0x382a <APP_AC_Status+0x148>
    3818:	82 35       	cpi	r24, 0x52	; 82
    381a:	69 f4       	brne	.+26     	; 0x3836 <APP_AC_Status+0x154>
				{
				case 'R' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    381c:	81 e0       	ldi	r24, 0x01	; 1
    381e:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt2;
    3822:	82 e0       	ldi	r24, 0x02	; 2
    3824:	80 93 06 08 	sts	0x0806, r24
    3828:	06 c0       	rjmp	.+12     	; 0x3836 <APP_AC_Status+0x154>
					break;

				case 'C' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    382a:	81 e0       	ldi	r24, 0x01	; 1
    382c:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt1;
    3830:	81 e0       	ldi	r24, 0x01	; 1
    3832:	80 93 06 08 	sts	0x0806, r24
					break;
				}
	}
	return Next;
}
    3836:	80 91 06 08 	lds	r24, 0x0806
    383a:	0f 90       	pop	r0
    383c:	cf 91       	pop	r28
    383e:	df 91       	pop	r29
    3840:	08 95       	ret

00003842 <APP_DoorStatus>:
static state APP_DoorStatus(Login_t Copy_LoginType){
    3842:	df 93       	push	r29
    3844:	cf 93       	push	r28
    3846:	0f 92       	push	r0
    3848:	cd b7       	in	r28, 0x3d	; 61
    384a:	de b7       	in	r29, 0x3e	; 62
	volatile uint_8 Read = 0;
    384c:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	switch(Copy_LoginType)
    384e:	81 30       	cpi	r24, 0x01	; 1
    3850:	91 f1       	breq	.+100    	; 0x38b6 <APP_DoorStatus+0x74>
    3852:	81 30       	cpi	r24, 0x01	; 1
    3854:	08 f4       	brcc	.+2      	; 0x3858 <APP_DoorStatus+0x16>
    3856:	60 c0       	rjmp	.+192    	; 0x3918 <APP_DoorStatus+0xd6>
    3858:	82 30       	cpi	r24, 0x02	; 2
    385a:	09 f0       	breq	.+2      	; 0x385e <APP_DoorStatus+0x1c>
    385c:	8b c0       	rjmp	.+278    	; 0x3974 <APP_DoorStatus+0x132>
	{
	case Admin :

		/* Function to Read SERVO State*/
		Read = DIO_u8GetPinValue(DIO_u8PORTD, DIO_PIN5);
    385e:	83 e0       	ldi	r24, 0x03	; 3
    3860:	65 e0       	ldi	r22, 0x05	; 5
    3862:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <DIO_u8GetPinValue>
    3866:	89 83       	std	Y+1, r24	; 0x01
		//Local_ReadDimmerState = GET_BIT(PORTD, DIO_PIN4);
		//Ecual_DC_Motor_Status(MOTOR_PORT, Motor1);
		switch(Read)
    3868:	89 81       	ldd	r24, Y+1	; 0x01
    386a:	88 23       	and	r24, r24
    386c:	49 f0       	breq	.+18     	; 0x3880 <APP_DoorStatus+0x3e>
    386e:	81 30       	cpi	r24, 0x01	; 1
    3870:	69 f4       	brne	.+26     	; 0x388c <APP_DoorStatus+0x4a>
		{
		case High :
			transmitDataBlockOverBluetooth("DOOR IS OPEN\n",14);
    3872:	8a e2       	ldi	r24, 0x2A	; 42
    3874:	92 e0       	ldi	r25, 0x02	; 2
    3876:	6e e0       	ldi	r22, 0x0E	; 14
    3878:	70 e0       	ldi	r23, 0x00	; 0
    387a:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    387e:	06 c0       	rjmp	.+12     	; 0x388c <APP_DoorStatus+0x4a>
			break;
		case Low :
			transmitDataBlockOverBluetooth("DOOR IS CLOSED\n",16);
    3880:	88 e3       	ldi	r24, 0x38	; 56
    3882:	92 e0       	ldi	r25, 0x02	; 2
    3884:	60 e1       	ldi	r22, 0x10	; 16
    3886:	70 e0       	ldi	r23, 0x00	; 0
    3888:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
			break;
		}
		while(Count){
				APP_SystemState();
    388c:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    3890:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    3894:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    3898:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    389a:	89 81       	ldd	r24, Y+1	; 0x01
    389c:	80 33       	cpi	r24, 0x30	; 48
    389e:	19 f0       	breq	.+6      	; 0x38a6 <APP_DoorStatus+0x64>
    38a0:	83 34       	cpi	r24, 0x43	; 67
    38a2:	a1 f7       	brne	.-24     	; 0x388c <APP_DoorStatus+0x4a>
    38a4:	04 c0       	rjmp	.+8      	; 0x38ae <APP_DoorStatus+0x6c>
			{
			case '0' :
				Count = 0;
				Next = RSt6;
    38a6:	8b e1       	ldi	r24, 0x1B	; 27
    38a8:	80 93 06 08 	sts	0x0806, r24
    38ac:	63 c0       	rjmp	.+198    	; 0x3974 <APP_DoorStatus+0x132>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    38ae:	88 e1       	ldi	r24, 0x18	; 24
    38b0:	80 93 06 08 	sts	0x0806, r24
    38b4:	5f c0       	rjmp	.+190    	; 0x3974 <APP_DoorStatus+0x132>
		}
		break;

		case User_Remote :
			/* Function to Read SERVO State*/
			Read = DIO_u8GetPinDirection(DIO_u8PORTD, DIO_PIN5);
    38b6:	83 e0       	ldi	r24, 0x03	; 3
    38b8:	65 e0       	ldi	r22, 0x05	; 5
    38ba:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <DIO_u8GetPinDirection>
    38be:	89 83       	std	Y+1, r24	; 0x01
			//Local_ReadDimmerState = GET_BIT(PORTD, DIO_PIN4);
			//Ecual_DC_Motor_Status(MOTOR_PORT, Motor1);
			switch(Read)
    38c0:	89 81       	ldd	r24, Y+1	; 0x01
    38c2:	88 23       	and	r24, r24
    38c4:	49 f0       	breq	.+18     	; 0x38d8 <APP_DoorStatus+0x96>
    38c6:	81 30       	cpi	r24, 0x01	; 1
    38c8:	69 f4       	brne	.+26     	; 0x38e4 <APP_DoorStatus+0xa2>
			{
			case High :
				transmitDataBlockOverBluetooth("DOOR IS OPEN\n",14);
    38ca:	8a e2       	ldi	r24, 0x2A	; 42
    38cc:	92 e0       	ldi	r25, 0x02	; 2
    38ce:	6e e0       	ldi	r22, 0x0E	; 14
    38d0:	70 e0       	ldi	r23, 0x00	; 0
    38d2:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    38d6:	06 c0       	rjmp	.+12     	; 0x38e4 <APP_DoorStatus+0xa2>
				break;
			case Low :
				transmitDataBlockOverBluetooth("DOOR IS CLOSED\n",10);
    38d8:	88 e3       	ldi	r24, 0x38	; 56
    38da:	92 e0       	ldi	r25, 0x02	; 2
    38dc:	6a e0       	ldi	r22, 0x0A	; 10
    38de:	70 e0       	ldi	r23, 0x00	; 0
    38e0:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				break;
			}
			Read = UART_ReceiveChar();
    38e4:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
    38e8:	89 83       	std	Y+1, r24	; 0x01
    38ea:	12 c0       	rjmp	.+36     	; 0x3910 <APP_DoorStatus+0xce>
			while(Count && Read){

				APP_SystemState();
    38ec:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    38f0:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				switch(Read)
    38f4:	89 81       	ldd	r24, Y+1	; 0x01
    38f6:	80 33       	cpi	r24, 0x30	; 48
    38f8:	19 f0       	breq	.+6      	; 0x3900 <APP_DoorStatus+0xbe>
    38fa:	83 34       	cpi	r24, 0x43	; 67
    38fc:	49 f4       	brne	.+18     	; 0x3910 <APP_DoorStatus+0xce>
    38fe:	04 c0       	rjmp	.+8      	; 0x3908 <APP_DoorStatus+0xc6>
				{
				case '0' :
					Count = 0;
					Next = RSt11;
    3900:	80 e2       	ldi	r24, 0x20	; 32
    3902:	80 93 06 08 	sts	0x0806, r24
    3906:	36 c0       	rjmp	.+108    	; 0x3974 <APP_DoorStatus+0x132>
					break;
				case 'C' :
					Count = 0;
					Next = RSt4;
    3908:	89 e1       	ldi	r24, 0x19	; 25
    390a:	80 93 06 08 	sts	0x0806, r24
    390e:	32 c0       	rjmp	.+100    	; 0x3974 <APP_DoorStatus+0x132>
			case Low :
				transmitDataBlockOverBluetooth("DOOR IS CLOSED\n",10);
				break;
			}
			Read = UART_ReceiveChar();
			while(Count && Read){
    3910:	89 81       	ldd	r24, Y+1	; 0x01
    3912:	88 23       	and	r24, r24
    3914:	59 f7       	brne	.-42     	; 0x38ec <APP_DoorStatus+0xaa>
    3916:	2e c0       	rjmp	.+92     	; 0x3974 <APP_DoorStatus+0x132>
				}
			}
			break;
			case User_Keypad :
				/* Function to Read SERVO State*/
				Read = DIO_u8GetPinDirection(DIO_u8PORTD, DIO_PIN5);
    3918:	83 e0       	ldi	r24, 0x03	; 3
    391a:	65 e0       	ldi	r22, 0x05	; 5
    391c:	0e 94 1c 0f 	call	0x1e38	; 0x1e38 <DIO_u8GetPinDirection>
    3920:	89 83       	std	Y+1, r24	; 0x01
				//Local_ReadDimmerState = GET_BIT(PORTD, DIO_PIN4);
				//Ecual_DC_Motor_Status(MOTOR_PORT, Motor1);
				switch(Read)
    3922:	89 81       	ldd	r24, Y+1	; 0x01
    3924:	88 23       	and	r24, r24
    3926:	59 f0       	breq	.+22     	; 0x393e <APP_DoorStatus+0xfc>
    3928:	81 30       	cpi	r24, 0x01	; 1
    392a:	89 f4       	brne	.+34     	; 0x394e <APP_DoorStatus+0x10c>
				{
				case High :
					CLCD_voidGoto(1,1);
    392c:	81 e0       	ldi	r24, 0x01	; 1
    392e:	61 e0       	ldi	r22, 0x01	; 1
    3930:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("DOOR IS OPEN");
    3934:	88 e4       	ldi	r24, 0x48	; 72
    3936:	92 e0       	ldi	r25, 0x02	; 2
    3938:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    393c:	08 c0       	rjmp	.+16     	; 0x394e <APP_DoorStatus+0x10c>
					break;
				case Low :
					CLCD_voidGoto(1,1);
    393e:	81 e0       	ldi	r24, 0x01	; 1
    3940:	61 e0       	ldi	r22, 0x01	; 1
    3942:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("DOOR IS CLOSED");
    3946:	85 e5       	ldi	r24, 0x55	; 85
    3948:	92 e0       	ldi	r25, 0x02	; 2
    394a:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
					break;
				}			switch(Local_u8Key)
    394e:	80 91 fb 07 	lds	r24, 0x07FB
    3952:	83 34       	cpi	r24, 0x43	; 67
    3954:	49 f0       	breq	.+18     	; 0x3968 <APP_DoorStatus+0x126>
    3956:	82 35       	cpi	r24, 0x52	; 82
    3958:	69 f4       	brne	.+26     	; 0x3974 <APP_DoorStatus+0x132>
				{
				case 'R' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    395a:	81 e0       	ldi	r24, 0x01	; 1
    395c:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt2;
    3960:	82 e0       	ldi	r24, 0x02	; 2
    3962:	80 93 06 08 	sts	0x0806, r24
    3966:	06 c0       	rjmp	.+12     	; 0x3974 <APP_DoorStatus+0x132>
					break;

				case 'C' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3968:	81 e0       	ldi	r24, 0x01	; 1
    396a:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt1;
    396e:	81 e0       	ldi	r24, 0x01	; 1
    3970:	80 93 06 08 	sts	0x0806, r24
					break;
				}
	}
	return Next;
}
    3974:	80 91 06 08 	lds	r24, 0x0806
    3978:	0f 90       	pop	r0
    397a:	cf 91       	pop	r28
    397c:	df 91       	pop	r29
    397e:	08 95       	ret

00003980 <APP_ROOM1_Control>:

static state APP_ROOM1_Control(Login_t Copy_LoginType){
    3980:	df 93       	push	r29
    3982:	cf 93       	push	r28
    3984:	0f 92       	push	r0
    3986:	cd b7       	in	r28, 0x3d	; 61
    3988:	de b7       	in	r29, 0x3e	; 62
	volatile uint_8 Read = 0;
    398a:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	switch(Copy_LoginType)
    398c:	81 30       	cpi	r24, 0x01	; 1
    398e:	f1 f1       	breq	.+124    	; 0x3a0c <APP_ROOM1_Control+0x8c>
    3990:	81 30       	cpi	r24, 0x01	; 1
    3992:	08 f4       	brcc	.+2      	; 0x3996 <APP_ROOM1_Control+0x16>
    3994:	78 c0       	rjmp	.+240    	; 0x3a86 <APP_ROOM1_Control+0x106>
    3996:	82 30       	cpi	r24, 0x02	; 2
    3998:	09 f0       	breq	.+2      	; 0x399c <APP_ROOM1_Control+0x1c>
    399a:	b0 c0       	rjmp	.+352    	; 0x3afc <APP_ROOM1_Control+0x17c>
	{
	case Admin :
		transmitDataBlockOverBluetooth("[1] ROOM1 ON\n",14);
    399c:	84 e6       	ldi	r24, 0x64	; 100
    399e:	92 e0       	ldi	r25, 0x02	; 2
    39a0:	6e e0       	ldi	r22, 0x0E	; 14
    39a2:	70 e0       	ldi	r23, 0x00	; 0
    39a4:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] ROOM1 OFF\n",15);
    39a8:	82 e7       	ldi	r24, 0x72	; 114
    39aa:	92 e0       	ldi	r25, 0x02	; 2
    39ac:	6f e0       	ldi	r22, 0x0F	; 15
    39ae:	70 e0       	ldi	r23, 0x00	; 0
    39b0:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    39b4:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    39b8:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    39bc:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    39c0:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    39c2:	89 81       	ldd	r24, Y+1	; 0x01
    39c4:	81 33       	cpi	r24, 0x31	; 49
    39c6:	51 f0       	breq	.+20     	; 0x39dc <APP_ROOM1_Control+0x5c>
    39c8:	82 33       	cpi	r24, 0x32	; 50
    39ca:	18 f4       	brcc	.+6      	; 0x39d2 <APP_ROOM1_Control+0x52>
    39cc:	80 33       	cpi	r24, 0x30	; 48
    39ce:	91 f7       	brne	.-28     	; 0x39b4 <APP_ROOM1_Control+0x34>
    39d0:	15 c0       	rjmp	.+42     	; 0x39fc <APP_ROOM1_Control+0x7c>
    39d2:	82 33       	cpi	r24, 0x32	; 50
    39d4:	59 f0       	breq	.+22     	; 0x39ec <APP_ROOM1_Control+0x6c>
    39d6:	83 34       	cpi	r24, 0x43	; 67
    39d8:	69 f7       	brne	.-38     	; 0x39b4 <APP_ROOM1_Control+0x34>
    39da:	14 c0       	rjmp	.+40     	; 0x3a04 <APP_ROOM1_Control+0x84>
			{
			case '1' :
				Ecual_Led_TurnOn(&LED1[0]);
    39dc:	84 eb       	ldi	r24, 0xB4	; 180
    39de:	97 e0       	ldi	r25, 0x07	; 7
    39e0:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
				Count = 0;
				Next = RSt27;
    39e4:	80 e3       	ldi	r24, 0x30	; 48
    39e6:	80 93 06 08 	sts	0x0806, r24
    39ea:	88 c0       	rjmp	.+272    	; 0x3afc <APP_ROOM1_Control+0x17c>
				break;
			case '2' :
				Ecual_Led_TurnOff(&LED1[0]);
    39ec:	84 eb       	ldi	r24, 0xB4	; 180
    39ee:	97 e0       	ldi	r25, 0x07	; 7
    39f0:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
				Count = 0;
				Next = RSt27;
    39f4:	80 e3       	ldi	r24, 0x30	; 48
    39f6:	80 93 06 08 	sts	0x0806, r24
    39fa:	80 c0       	rjmp	.+256    	; 0x3afc <APP_ROOM1_Control+0x17c>
				break;
			case '0' :
				Count = 0;
				Next = RSt12;
    39fc:	81 e2       	ldi	r24, 0x21	; 33
    39fe:	80 93 06 08 	sts	0x0806, r24
    3a02:	7c c0       	rjmp	.+248    	; 0x3afc <APP_ROOM1_Control+0x17c>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    3a04:	88 e1       	ldi	r24, 0x18	; 24
    3a06:	80 93 06 08 	sts	0x0806, r24
    3a0a:	78 c0       	rjmp	.+240    	; 0x3afc <APP_ROOM1_Control+0x17c>
			}
		}
		break;

	case User_Remote :
		transmitDataBlockOverBluetooth("[1] ROOM1 ON\n",14);
    3a0c:	84 e6       	ldi	r24, 0x64	; 100
    3a0e:	92 e0       	ldi	r25, 0x02	; 2
    3a10:	6e e0       	ldi	r22, 0x0E	; 14
    3a12:	70 e0       	ldi	r23, 0x00	; 0
    3a14:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] ROOM1 OFF\n",15);
    3a18:	82 e7       	ldi	r24, 0x72	; 114
    3a1a:	92 e0       	ldi	r25, 0x02	; 2
    3a1c:	6f e0       	ldi	r22, 0x0F	; 15
    3a1e:	70 e0       	ldi	r23, 0x00	; 0
    3a20:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		Read = UART_ReceiveChar();
    3a24:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
    3a28:	89 83       	std	Y+1, r24	; 0x01
    3a2a:	29 c0       	rjmp	.+82     	; 0x3a7e <APP_ROOM1_Control+0xfe>
		while(Count && Read){

			APP_SystemState();
    3a2c:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
			APP_TEMP_MOTOR();
    3a30:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
			switch(Read)
    3a34:	89 81       	ldd	r24, Y+1	; 0x01
    3a36:	81 33       	cpi	r24, 0x31	; 49
    3a38:	51 f0       	breq	.+20     	; 0x3a4e <APP_ROOM1_Control+0xce>
    3a3a:	82 33       	cpi	r24, 0x32	; 50
    3a3c:	18 f4       	brcc	.+6      	; 0x3a44 <APP_ROOM1_Control+0xc4>
    3a3e:	80 33       	cpi	r24, 0x30	; 48
    3a40:	f1 f4       	brne	.+60     	; 0x3a7e <APP_ROOM1_Control+0xfe>
    3a42:	15 c0       	rjmp	.+42     	; 0x3a6e <APP_ROOM1_Control+0xee>
    3a44:	82 33       	cpi	r24, 0x32	; 50
    3a46:	59 f0       	breq	.+22     	; 0x3a5e <APP_ROOM1_Control+0xde>
    3a48:	83 34       	cpi	r24, 0x43	; 67
    3a4a:	c9 f4       	brne	.+50     	; 0x3a7e <APP_ROOM1_Control+0xfe>
    3a4c:	14 c0       	rjmp	.+40     	; 0x3a76 <APP_ROOM1_Control+0xf6>
			{
			case '1' :
				Ecual_Led_TurnOn(&LED1[0]);
    3a4e:	84 eb       	ldi	r24, 0xB4	; 180
    3a50:	97 e0       	ldi	r25, 0x07	; 7
    3a52:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
				Count = 0;
				Next = RSt37;
    3a56:	8a e3       	ldi	r24, 0x3A	; 58
    3a58:	80 93 06 08 	sts	0x0806, r24
    3a5c:	4f c0       	rjmp	.+158    	; 0x3afc <APP_ROOM1_Control+0x17c>
				break;
			case '2' :
				Ecual_Led_TurnOff(&LED1[0]);
    3a5e:	84 eb       	ldi	r24, 0xB4	; 180
    3a60:	97 e0       	ldi	r25, 0x07	; 7
    3a62:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
				Count = 0;
				Next = RSt37;
    3a66:	8a e3       	ldi	r24, 0x3A	; 58
    3a68:	80 93 06 08 	sts	0x0806, r24
    3a6c:	47 c0       	rjmp	.+142    	; 0x3afc <APP_ROOM1_Control+0x17c>
				break;
			case '0' :
				Count = 0;
				Next = RSt20;
    3a6e:	89 e2       	ldi	r24, 0x29	; 41
    3a70:	80 93 06 08 	sts	0x0806, r24
    3a74:	43 c0       	rjmp	.+134    	; 0x3afc <APP_ROOM1_Control+0x17c>
				break;
			case 'C' :
				Count = 0;
				Next = RSt4;
    3a76:	89 e1       	ldi	r24, 0x19	; 25
    3a78:	80 93 06 08 	sts	0x0806, r24
    3a7c:	3f c0       	rjmp	.+126    	; 0x3afc <APP_ROOM1_Control+0x17c>
	case User_Remote :
		transmitDataBlockOverBluetooth("[1] ROOM1 ON\n",14);
		transmitDataBlockOverBluetooth("[2] ROOM1 OFF\n",15);

		Read = UART_ReceiveChar();
		while(Count && Read){
    3a7e:	89 81       	ldd	r24, Y+1	; 0x01
    3a80:	88 23       	and	r24, r24
    3a82:	a1 f6       	brne	.-88     	; 0x3a2c <APP_ROOM1_Control+0xac>
    3a84:	3b c0       	rjmp	.+118    	; 0x3afc <APP_ROOM1_Control+0x17c>
				break;
			}
		}
		break;
	case User_Keypad :
		CLCD_voidGoto(1,1);
    3a86:	81 e0       	ldi	r24, 0x01	; 1
    3a88:	61 e0       	ldi	r22, 0x01	; 1
    3a8a:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[1]ROOM1 ON");
    3a8e:	81 e8       	ldi	r24, 0x81	; 129
    3a90:	92 e0       	ldi	r25, 0x02	; 2
    3a92:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    3a96:	82 e0       	ldi	r24, 0x02	; 2
    3a98:	61 e0       	ldi	r22, 0x01	; 1
    3a9a:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[2]ROOM1 OFF");
    3a9e:	8d e8       	ldi	r24, 0x8D	; 141
    3aa0:	92 e0       	ldi	r25, 0x02	; 2
    3aa2:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		switch(Local_u8Key)
    3aa6:	80 91 fb 07 	lds	r24, 0x07FB
    3aaa:	82 33       	cpi	r24, 0x32	; 50
    3aac:	91 f0       	breq	.+36     	; 0x3ad2 <APP_ROOM1_Control+0x152>
    3aae:	83 33       	cpi	r24, 0x33	; 51
    3ab0:	18 f4       	brcc	.+6      	; 0x3ab8 <APP_ROOM1_Control+0x138>
    3ab2:	81 33       	cpi	r24, 0x31	; 49
    3ab4:	19 f5       	brne	.+70     	; 0x3afc <APP_ROOM1_Control+0x17c>
    3ab6:	05 c0       	rjmp	.+10     	; 0x3ac2 <APP_ROOM1_Control+0x142>
    3ab8:	83 34       	cpi	r24, 0x43	; 67
    3aba:	d1 f0       	breq	.+52     	; 0x3af0 <APP_ROOM1_Control+0x170>
    3abc:	82 35       	cpi	r24, 0x52	; 82
    3abe:	f1 f4       	brne	.+60     	; 0x3afc <APP_ROOM1_Control+0x17c>
    3ac0:	10 c0       	rjmp	.+32     	; 0x3ae2 <APP_ROOM1_Control+0x162>
		{
		case '1' :
			Ecual_Led_TurnOn(&LED1[0]);
    3ac2:	84 eb       	ldi	r24, 0xB4	; 180
    3ac4:	97 e0       	ldi	r25, 0x07	; 7
    3ac6:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
			Next = ESt11;
    3aca:	8b e0       	ldi	r24, 0x0B	; 11
    3acc:	80 93 06 08 	sts	0x0806, r24
    3ad0:	15 c0       	rjmp	.+42     	; 0x3afc <APP_ROOM1_Control+0x17c>
			break;
		case '2' :
			Ecual_Led_TurnOff(&LED1[0]);
    3ad2:	84 eb       	ldi	r24, 0xB4	; 180
    3ad4:	97 e0       	ldi	r25, 0x07	; 7
    3ad6:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
			Next = ESt11;
    3ada:	8b e0       	ldi	r24, 0x0B	; 11
    3adc:	80 93 06 08 	sts	0x0806, r24
    3ae0:	0d c0       	rjmp	.+26     	; 0x3afc <APP_ROOM1_Control+0x17c>
			break;
		case 'R' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3ae2:	81 e0       	ldi	r24, 0x01	; 1
    3ae4:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt8;
    3ae8:	88 e0       	ldi	r24, 0x08	; 8
    3aea:	80 93 06 08 	sts	0x0806, r24
    3aee:	06 c0       	rjmp	.+12     	; 0x3afc <APP_ROOM1_Control+0x17c>
			break;

		case 'C' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3af0:	81 e0       	ldi	r24, 0x01	; 1
    3af2:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    3af6:	81 e0       	ldi	r24, 0x01	; 1
    3af8:	80 93 06 08 	sts	0x0806, r24
			break;
		}
	}
	return Next;
}
    3afc:	80 91 06 08 	lds	r24, 0x0806
    3b00:	0f 90       	pop	r0
    3b02:	cf 91       	pop	r28
    3b04:	df 91       	pop	r29
    3b06:	08 95       	ret

00003b08 <APP_ROOM2_Control>:
static state APP_ROOM2_Control(Login_t Copy_LoginType){
    3b08:	df 93       	push	r29
    3b0a:	cf 93       	push	r28
    3b0c:	0f 92       	push	r0
    3b0e:	cd b7       	in	r28, 0x3d	; 61
    3b10:	de b7       	in	r29, 0x3e	; 62
	volatile uint_8 Read = 0;
    3b12:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	switch(Copy_LoginType)
    3b14:	81 30       	cpi	r24, 0x01	; 1
    3b16:	f1 f1       	breq	.+124    	; 0x3b94 <APP_ROOM2_Control+0x8c>
    3b18:	81 30       	cpi	r24, 0x01	; 1
    3b1a:	08 f4       	brcc	.+2      	; 0x3b1e <APP_ROOM2_Control+0x16>
    3b1c:	73 c0       	rjmp	.+230    	; 0x3c04 <APP_ROOM2_Control+0xfc>
    3b1e:	82 30       	cpi	r24, 0x02	; 2
    3b20:	09 f0       	breq	.+2      	; 0x3b24 <APP_ROOM2_Control+0x1c>
    3b22:	ab c0       	rjmp	.+342    	; 0x3c7a <APP_ROOM2_Control+0x172>
	{
	case Admin :
		transmitDataBlockOverBluetooth("[1] ROOM2 ON\n",14);
    3b24:	8a e9       	ldi	r24, 0x9A	; 154
    3b26:	92 e0       	ldi	r25, 0x02	; 2
    3b28:	6e e0       	ldi	r22, 0x0E	; 14
    3b2a:	70 e0       	ldi	r23, 0x00	; 0
    3b2c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] ROOM2 OFF\n",15);
    3b30:	88 ea       	ldi	r24, 0xA8	; 168
    3b32:	92 e0       	ldi	r25, 0x02	; 2
    3b34:	6f e0       	ldi	r22, 0x0F	; 15
    3b36:	70 e0       	ldi	r23, 0x00	; 0
    3b38:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    3b3c:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    3b40:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    3b44:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    3b48:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    3b4a:	89 81       	ldd	r24, Y+1	; 0x01
    3b4c:	81 33       	cpi	r24, 0x31	; 49
    3b4e:	51 f0       	breq	.+20     	; 0x3b64 <APP_ROOM2_Control+0x5c>
    3b50:	82 33       	cpi	r24, 0x32	; 50
    3b52:	18 f4       	brcc	.+6      	; 0x3b5a <APP_ROOM2_Control+0x52>
    3b54:	80 33       	cpi	r24, 0x30	; 48
    3b56:	91 f7       	brne	.-28     	; 0x3b3c <APP_ROOM2_Control+0x34>
    3b58:	15 c0       	rjmp	.+42     	; 0x3b84 <APP_ROOM2_Control+0x7c>
    3b5a:	82 33       	cpi	r24, 0x32	; 50
    3b5c:	59 f0       	breq	.+22     	; 0x3b74 <APP_ROOM2_Control+0x6c>
    3b5e:	83 34       	cpi	r24, 0x43	; 67
    3b60:	69 f7       	brne	.-38     	; 0x3b3c <APP_ROOM2_Control+0x34>
    3b62:	14 c0       	rjmp	.+40     	; 0x3b8c <APP_ROOM2_Control+0x84>
			{
			case '1' :
				Ecual_Led_TurnOn(&LED1[1]);
    3b64:	85 eb       	ldi	r24, 0xB5	; 181
    3b66:	97 e0       	ldi	r25, 0x07	; 7
    3b68:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
				Count = 0;
				Next = RSt28;
    3b6c:	81 e3       	ldi	r24, 0x31	; 49
    3b6e:	80 93 06 08 	sts	0x0806, r24
    3b72:	83 c0       	rjmp	.+262    	; 0x3c7a <APP_ROOM2_Control+0x172>
				break;
			case '2' :
				Ecual_Led_TurnOff(&LED1[1]);
    3b74:	85 eb       	ldi	r24, 0xB5	; 181
    3b76:	97 e0       	ldi	r25, 0x07	; 7
    3b78:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
				Count = 0;
				Next = RSt28;
    3b7c:	81 e3       	ldi	r24, 0x31	; 49
    3b7e:	80 93 06 08 	sts	0x0806, r24
    3b82:	7b c0       	rjmp	.+246    	; 0x3c7a <APP_ROOM2_Control+0x172>
				break;
			case '0' :
				Count = 0;
				Next = RSt12;
    3b84:	81 e2       	ldi	r24, 0x21	; 33
    3b86:	80 93 06 08 	sts	0x0806, r24
    3b8a:	77 c0       	rjmp	.+238    	; 0x3c7a <APP_ROOM2_Control+0x172>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    3b8c:	88 e1       	ldi	r24, 0x18	; 24
    3b8e:	80 93 06 08 	sts	0x0806, r24
    3b92:	73 c0       	rjmp	.+230    	; 0x3c7a <APP_ROOM2_Control+0x172>
			}
		}
		break;

	case User_Remote :
		transmitDataBlockOverBluetooth("[1] ROOM2 ON\n",14);
    3b94:	8a e9       	ldi	r24, 0x9A	; 154
    3b96:	92 e0       	ldi	r25, 0x02	; 2
    3b98:	6e e0       	ldi	r22, 0x0E	; 14
    3b9a:	70 e0       	ldi	r23, 0x00	; 0
    3b9c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] ROOM2 OFF\n",15);
    3ba0:	88 ea       	ldi	r24, 0xA8	; 168
    3ba2:	92 e0       	ldi	r25, 0x02	; 2
    3ba4:	6f e0       	ldi	r22, 0x0F	; 15
    3ba6:	70 e0       	ldi	r23, 0x00	; 0
    3ba8:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    3bac:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    3bb0:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    3bb4:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    3bb8:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    3bba:	89 81       	ldd	r24, Y+1	; 0x01
    3bbc:	81 33       	cpi	r24, 0x31	; 49
    3bbe:	51 f0       	breq	.+20     	; 0x3bd4 <APP_ROOM2_Control+0xcc>
    3bc0:	82 33       	cpi	r24, 0x32	; 50
    3bc2:	18 f4       	brcc	.+6      	; 0x3bca <APP_ROOM2_Control+0xc2>
    3bc4:	80 33       	cpi	r24, 0x30	; 48
    3bc6:	91 f7       	brne	.-28     	; 0x3bac <APP_ROOM2_Control+0xa4>
    3bc8:	15 c0       	rjmp	.+42     	; 0x3bf4 <APP_ROOM2_Control+0xec>
    3bca:	82 33       	cpi	r24, 0x32	; 50
    3bcc:	59 f0       	breq	.+22     	; 0x3be4 <APP_ROOM2_Control+0xdc>
    3bce:	83 34       	cpi	r24, 0x43	; 67
    3bd0:	69 f7       	brne	.-38     	; 0x3bac <APP_ROOM2_Control+0xa4>
    3bd2:	14 c0       	rjmp	.+40     	; 0x3bfc <APP_ROOM2_Control+0xf4>
			{
			case '1' :
				Ecual_Led_TurnOn(&LED1[1]);
    3bd4:	85 eb       	ldi	r24, 0xB5	; 181
    3bd6:	97 e0       	ldi	r25, 0x07	; 7
    3bd8:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
				Count = 0;
				Next = RSt38;
    3bdc:	8b e3       	ldi	r24, 0x3B	; 59
    3bde:	80 93 06 08 	sts	0x0806, r24
    3be2:	4b c0       	rjmp	.+150    	; 0x3c7a <APP_ROOM2_Control+0x172>
				break;
			case '2' :
				Ecual_Led_TurnOff(&LED1[1]);
    3be4:	85 eb       	ldi	r24, 0xB5	; 181
    3be6:	97 e0       	ldi	r25, 0x07	; 7
    3be8:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
				Count = 0;
				Next = RSt38;
    3bec:	8b e3       	ldi	r24, 0x3B	; 59
    3bee:	80 93 06 08 	sts	0x0806, r24
    3bf2:	43 c0       	rjmp	.+134    	; 0x3c7a <APP_ROOM2_Control+0x172>
				break;
			case '0' :
				Count = 0;
				Next = RSt20;
    3bf4:	89 e2       	ldi	r24, 0x29	; 41
    3bf6:	80 93 06 08 	sts	0x0806, r24
    3bfa:	3f c0       	rjmp	.+126    	; 0x3c7a <APP_ROOM2_Control+0x172>
				break;
			case 'C' :
				Count = 0;
				Next = RSt4;
    3bfc:	89 e1       	ldi	r24, 0x19	; 25
    3bfe:	80 93 06 08 	sts	0x0806, r24
    3c02:	3b c0       	rjmp	.+118    	; 0x3c7a <APP_ROOM2_Control+0x172>
				break;
			}
		}
		break;
	case User_Keypad :
		CLCD_voidGoto(1,1);
    3c04:	81 e0       	ldi	r24, 0x01	; 1
    3c06:	61 e0       	ldi	r22, 0x01	; 1
    3c08:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[1]ROOM2 ON");
    3c0c:	87 eb       	ldi	r24, 0xB7	; 183
    3c0e:	92 e0       	ldi	r25, 0x02	; 2
    3c10:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    3c14:	82 e0       	ldi	r24, 0x02	; 2
    3c16:	61 e0       	ldi	r22, 0x01	; 1
    3c18:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[2]ROOM2 OFF");
    3c1c:	83 ec       	ldi	r24, 0xC3	; 195
    3c1e:	92 e0       	ldi	r25, 0x02	; 2
    3c20:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		switch(Local_u8Key)
    3c24:	80 91 fb 07 	lds	r24, 0x07FB
    3c28:	82 33       	cpi	r24, 0x32	; 50
    3c2a:	91 f0       	breq	.+36     	; 0x3c50 <APP_ROOM2_Control+0x148>
    3c2c:	83 33       	cpi	r24, 0x33	; 51
    3c2e:	18 f4       	brcc	.+6      	; 0x3c36 <APP_ROOM2_Control+0x12e>
    3c30:	81 33       	cpi	r24, 0x31	; 49
    3c32:	19 f5       	brne	.+70     	; 0x3c7a <APP_ROOM2_Control+0x172>
    3c34:	05 c0       	rjmp	.+10     	; 0x3c40 <APP_ROOM2_Control+0x138>
    3c36:	83 34       	cpi	r24, 0x43	; 67
    3c38:	d1 f0       	breq	.+52     	; 0x3c6e <APP_ROOM2_Control+0x166>
    3c3a:	82 35       	cpi	r24, 0x52	; 82
    3c3c:	f1 f4       	brne	.+60     	; 0x3c7a <APP_ROOM2_Control+0x172>
    3c3e:	10 c0       	rjmp	.+32     	; 0x3c60 <APP_ROOM2_Control+0x158>
		{
		case '1' :
			Ecual_Led_TurnOn(&LED1[1]);
    3c40:	85 eb       	ldi	r24, 0xB5	; 181
    3c42:	97 e0       	ldi	r25, 0x07	; 7
    3c44:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
			Next = ESt11;
    3c48:	8b e0       	ldi	r24, 0x0B	; 11
    3c4a:	80 93 06 08 	sts	0x0806, r24
    3c4e:	15 c0       	rjmp	.+42     	; 0x3c7a <APP_ROOM2_Control+0x172>
			break;
		case '2' :
			Ecual_Led_TurnOff(&LED1[1]);
    3c50:	85 eb       	ldi	r24, 0xB5	; 181
    3c52:	97 e0       	ldi	r25, 0x07	; 7
    3c54:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
			Next = ESt11;
    3c58:	8b e0       	ldi	r24, 0x0B	; 11
    3c5a:	80 93 06 08 	sts	0x0806, r24
    3c5e:	0d c0       	rjmp	.+26     	; 0x3c7a <APP_ROOM2_Control+0x172>
			break;
		case 'R' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3c60:	81 e0       	ldi	r24, 0x01	; 1
    3c62:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt8;
    3c66:	88 e0       	ldi	r24, 0x08	; 8
    3c68:	80 93 06 08 	sts	0x0806, r24
    3c6c:	06 c0       	rjmp	.+12     	; 0x3c7a <APP_ROOM2_Control+0x172>
			break;

		case 'C' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3c6e:	81 e0       	ldi	r24, 0x01	; 1
    3c70:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    3c74:	81 e0       	ldi	r24, 0x01	; 1
    3c76:	80 93 06 08 	sts	0x0806, r24
			break;
		}
	}
	return Next;
}
    3c7a:	80 91 06 08 	lds	r24, 0x0806
    3c7e:	0f 90       	pop	r0
    3c80:	cf 91       	pop	r28
    3c82:	df 91       	pop	r29
    3c84:	08 95       	ret

00003c86 <APP_ROOM3_Control>:
static state APP_ROOM3_Control(Login_t Copy_LoginType){
    3c86:	df 93       	push	r29
    3c88:	cf 93       	push	r28
    3c8a:	0f 92       	push	r0
    3c8c:	cd b7       	in	r28, 0x3d	; 61
    3c8e:	de b7       	in	r29, 0x3e	; 62
	volatile uint_8 Read = 0;
    3c90:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	switch(Copy_LoginType)
    3c92:	81 30       	cpi	r24, 0x01	; 1
    3c94:	f1 f1       	breq	.+124    	; 0x3d12 <APP_ROOM3_Control+0x8c>
    3c96:	81 30       	cpi	r24, 0x01	; 1
    3c98:	08 f4       	brcc	.+2      	; 0x3c9c <APP_ROOM3_Control+0x16>
    3c9a:	73 c0       	rjmp	.+230    	; 0x3d82 <APP_ROOM3_Control+0xfc>
    3c9c:	82 30       	cpi	r24, 0x02	; 2
    3c9e:	09 f0       	breq	.+2      	; 0x3ca2 <APP_ROOM3_Control+0x1c>
    3ca0:	ab c0       	rjmp	.+342    	; 0x3df8 <APP_ROOM3_Control+0x172>
	{
	case Admin :
		transmitDataBlockOverBluetooth("[1] ROOM3 ON\n",14);
    3ca2:	80 ed       	ldi	r24, 0xD0	; 208
    3ca4:	92 e0       	ldi	r25, 0x02	; 2
    3ca6:	6e e0       	ldi	r22, 0x0E	; 14
    3ca8:	70 e0       	ldi	r23, 0x00	; 0
    3caa:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] ROOM3 OFF\n",15);
    3cae:	8e ed       	ldi	r24, 0xDE	; 222
    3cb0:	92 e0       	ldi	r25, 0x02	; 2
    3cb2:	6f e0       	ldi	r22, 0x0F	; 15
    3cb4:	70 e0       	ldi	r23, 0x00	; 0
    3cb6:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    3cba:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    3cbe:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    3cc2:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    3cc6:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    3cc8:	89 81       	ldd	r24, Y+1	; 0x01
    3cca:	81 33       	cpi	r24, 0x31	; 49
    3ccc:	51 f0       	breq	.+20     	; 0x3ce2 <APP_ROOM3_Control+0x5c>
    3cce:	82 33       	cpi	r24, 0x32	; 50
    3cd0:	18 f4       	brcc	.+6      	; 0x3cd8 <APP_ROOM3_Control+0x52>
    3cd2:	80 33       	cpi	r24, 0x30	; 48
    3cd4:	91 f7       	brne	.-28     	; 0x3cba <APP_ROOM3_Control+0x34>
    3cd6:	15 c0       	rjmp	.+42     	; 0x3d02 <APP_ROOM3_Control+0x7c>
    3cd8:	82 33       	cpi	r24, 0x32	; 50
    3cda:	59 f0       	breq	.+22     	; 0x3cf2 <APP_ROOM3_Control+0x6c>
    3cdc:	83 34       	cpi	r24, 0x43	; 67
    3cde:	69 f7       	brne	.-38     	; 0x3cba <APP_ROOM3_Control+0x34>
    3ce0:	14 c0       	rjmp	.+40     	; 0x3d0a <APP_ROOM3_Control+0x84>
			{
			case '1' :
				Ecual_Led_TurnOn(&LED1[2]);
    3ce2:	86 eb       	ldi	r24, 0xB6	; 182
    3ce4:	97 e0       	ldi	r25, 0x07	; 7
    3ce6:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
				Count = 0;
				Next = RSt29;
    3cea:	82 e3       	ldi	r24, 0x32	; 50
    3cec:	80 93 06 08 	sts	0x0806, r24
    3cf0:	83 c0       	rjmp	.+262    	; 0x3df8 <APP_ROOM3_Control+0x172>
				break;
			case '2' :
				Ecual_Led_TurnOff(&LED1[2]);
    3cf2:	86 eb       	ldi	r24, 0xB6	; 182
    3cf4:	97 e0       	ldi	r25, 0x07	; 7
    3cf6:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
				Count = 0;
				Next = RSt29;
    3cfa:	82 e3       	ldi	r24, 0x32	; 50
    3cfc:	80 93 06 08 	sts	0x0806, r24
    3d00:	7b c0       	rjmp	.+246    	; 0x3df8 <APP_ROOM3_Control+0x172>
				break;
			case '0' :
				Count = 0;
				Next = RSt12;
    3d02:	81 e2       	ldi	r24, 0x21	; 33
    3d04:	80 93 06 08 	sts	0x0806, r24
    3d08:	77 c0       	rjmp	.+238    	; 0x3df8 <APP_ROOM3_Control+0x172>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    3d0a:	88 e1       	ldi	r24, 0x18	; 24
    3d0c:	80 93 06 08 	sts	0x0806, r24
    3d10:	73 c0       	rjmp	.+230    	; 0x3df8 <APP_ROOM3_Control+0x172>
			}
		}
		break;

	case User_Remote :
		transmitDataBlockOverBluetooth("[1] ROOM3 ON\n",14);
    3d12:	80 ed       	ldi	r24, 0xD0	; 208
    3d14:	92 e0       	ldi	r25, 0x02	; 2
    3d16:	6e e0       	ldi	r22, 0x0E	; 14
    3d18:	70 e0       	ldi	r23, 0x00	; 0
    3d1a:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] ROOM3 OFF\n",15);
    3d1e:	8e ed       	ldi	r24, 0xDE	; 222
    3d20:	92 e0       	ldi	r25, 0x02	; 2
    3d22:	6f e0       	ldi	r22, 0x0F	; 15
    3d24:	70 e0       	ldi	r23, 0x00	; 0
    3d26:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    3d2a:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    3d2e:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    3d32:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    3d36:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    3d38:	89 81       	ldd	r24, Y+1	; 0x01
    3d3a:	81 33       	cpi	r24, 0x31	; 49
    3d3c:	51 f0       	breq	.+20     	; 0x3d52 <APP_ROOM3_Control+0xcc>
    3d3e:	82 33       	cpi	r24, 0x32	; 50
    3d40:	18 f4       	brcc	.+6      	; 0x3d48 <APP_ROOM3_Control+0xc2>
    3d42:	80 33       	cpi	r24, 0x30	; 48
    3d44:	91 f7       	brne	.-28     	; 0x3d2a <APP_ROOM3_Control+0xa4>
    3d46:	15 c0       	rjmp	.+42     	; 0x3d72 <APP_ROOM3_Control+0xec>
    3d48:	82 33       	cpi	r24, 0x32	; 50
    3d4a:	59 f0       	breq	.+22     	; 0x3d62 <APP_ROOM3_Control+0xdc>
    3d4c:	83 34       	cpi	r24, 0x43	; 67
    3d4e:	69 f7       	brne	.-38     	; 0x3d2a <APP_ROOM3_Control+0xa4>
    3d50:	14 c0       	rjmp	.+40     	; 0x3d7a <APP_ROOM3_Control+0xf4>
			{
			case '1' :
				Ecual_Led_TurnOn(&LED1[2]);
    3d52:	86 eb       	ldi	r24, 0xB6	; 182
    3d54:	97 e0       	ldi	r25, 0x07	; 7
    3d56:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
				Count = 0;
				Next = RSt39;
    3d5a:	8c e3       	ldi	r24, 0x3C	; 60
    3d5c:	80 93 06 08 	sts	0x0806, r24
    3d60:	4b c0       	rjmp	.+150    	; 0x3df8 <APP_ROOM3_Control+0x172>
				break;
			case '2' :
				Ecual_Led_TurnOff(&LED1[2]);
    3d62:	86 eb       	ldi	r24, 0xB6	; 182
    3d64:	97 e0       	ldi	r25, 0x07	; 7
    3d66:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
				Count = 0;
				Next = RSt39;
    3d6a:	8c e3       	ldi	r24, 0x3C	; 60
    3d6c:	80 93 06 08 	sts	0x0806, r24
    3d70:	43 c0       	rjmp	.+134    	; 0x3df8 <APP_ROOM3_Control+0x172>
				break;
			case '0' :
				Count = 0;
				Next = RSt20;
    3d72:	89 e2       	ldi	r24, 0x29	; 41
    3d74:	80 93 06 08 	sts	0x0806, r24
    3d78:	3f c0       	rjmp	.+126    	; 0x3df8 <APP_ROOM3_Control+0x172>
				break;
			case 'C' :
				Count = 0;
				Next = RSt4;
    3d7a:	89 e1       	ldi	r24, 0x19	; 25
    3d7c:	80 93 06 08 	sts	0x0806, r24
    3d80:	3b c0       	rjmp	.+118    	; 0x3df8 <APP_ROOM3_Control+0x172>
				break;
			}
		}
		break;
	case User_Keypad :
		CLCD_voidGoto(1,1);
    3d82:	81 e0       	ldi	r24, 0x01	; 1
    3d84:	61 e0       	ldi	r22, 0x01	; 1
    3d86:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[1]ROOM3 ON");
    3d8a:	8d ee       	ldi	r24, 0xED	; 237
    3d8c:	92 e0       	ldi	r25, 0x02	; 2
    3d8e:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    3d92:	82 e0       	ldi	r24, 0x02	; 2
    3d94:	61 e0       	ldi	r22, 0x01	; 1
    3d96:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[2]ROOM3 OFF");
    3d9a:	89 ef       	ldi	r24, 0xF9	; 249
    3d9c:	92 e0       	ldi	r25, 0x02	; 2
    3d9e:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		switch(Local_u8Key)
    3da2:	80 91 fb 07 	lds	r24, 0x07FB
    3da6:	82 33       	cpi	r24, 0x32	; 50
    3da8:	91 f0       	breq	.+36     	; 0x3dce <APP_ROOM3_Control+0x148>
    3daa:	83 33       	cpi	r24, 0x33	; 51
    3dac:	18 f4       	brcc	.+6      	; 0x3db4 <APP_ROOM3_Control+0x12e>
    3dae:	81 33       	cpi	r24, 0x31	; 49
    3db0:	19 f5       	brne	.+70     	; 0x3df8 <APP_ROOM3_Control+0x172>
    3db2:	05 c0       	rjmp	.+10     	; 0x3dbe <APP_ROOM3_Control+0x138>
    3db4:	83 34       	cpi	r24, 0x43	; 67
    3db6:	d1 f0       	breq	.+52     	; 0x3dec <APP_ROOM3_Control+0x166>
    3db8:	82 35       	cpi	r24, 0x52	; 82
    3dba:	f1 f4       	brne	.+60     	; 0x3df8 <APP_ROOM3_Control+0x172>
    3dbc:	10 c0       	rjmp	.+32     	; 0x3dde <APP_ROOM3_Control+0x158>
		{
		case '1' :
			Ecual_Led_TurnOn(&LED1[2]);
    3dbe:	86 eb       	ldi	r24, 0xB6	; 182
    3dc0:	97 e0       	ldi	r25, 0x07	; 7
    3dc2:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
			Next = ESt11;
    3dc6:	8b e0       	ldi	r24, 0x0B	; 11
    3dc8:	80 93 06 08 	sts	0x0806, r24
    3dcc:	15 c0       	rjmp	.+42     	; 0x3df8 <APP_ROOM3_Control+0x172>
			break;
		case '2' :
			Ecual_Led_TurnOff(&LED1[2]);
    3dce:	86 eb       	ldi	r24, 0xB6	; 182
    3dd0:	97 e0       	ldi	r25, 0x07	; 7
    3dd2:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
			Next = ESt11;
    3dd6:	8b e0       	ldi	r24, 0x0B	; 11
    3dd8:	80 93 06 08 	sts	0x0806, r24
    3ddc:	0d c0       	rjmp	.+26     	; 0x3df8 <APP_ROOM3_Control+0x172>
			break;
		case 'R' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3dde:	81 e0       	ldi	r24, 0x01	; 1
    3de0:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt8;
    3de4:	88 e0       	ldi	r24, 0x08	; 8
    3de6:	80 93 06 08 	sts	0x0806, r24
    3dea:	06 c0       	rjmp	.+12     	; 0x3df8 <APP_ROOM3_Control+0x172>
			break;

		case 'C' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3dec:	81 e0       	ldi	r24, 0x01	; 1
    3dee:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    3df2:	81 e0       	ldi	r24, 0x01	; 1
    3df4:	80 93 06 08 	sts	0x0806, r24
			break;
		}
	}
	return Next;
}
    3df8:	80 91 06 08 	lds	r24, 0x0806
    3dfc:	0f 90       	pop	r0
    3dfe:	cf 91       	pop	r28
    3e00:	df 91       	pop	r29
    3e02:	08 95       	ret

00003e04 <APP_ROOM4_Control>:
static state APP_ROOM4_Control(Login_t Copy_LoginType){
    3e04:	df 93       	push	r29
    3e06:	cf 93       	push	r28
    3e08:	0f 92       	push	r0
    3e0a:	cd b7       	in	r28, 0x3d	; 61
    3e0c:	de b7       	in	r29, 0x3e	; 62
	volatile uint_8 Read = 0;
    3e0e:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	switch(Copy_LoginType)
    3e10:	81 30       	cpi	r24, 0x01	; 1
    3e12:	f1 f1       	breq	.+124    	; 0x3e90 <APP_ROOM4_Control+0x8c>
    3e14:	81 30       	cpi	r24, 0x01	; 1
    3e16:	08 f4       	brcc	.+2      	; 0x3e1a <APP_ROOM4_Control+0x16>
    3e18:	73 c0       	rjmp	.+230    	; 0x3f00 <APP_ROOM4_Control+0xfc>
    3e1a:	82 30       	cpi	r24, 0x02	; 2
    3e1c:	09 f0       	breq	.+2      	; 0x3e20 <APP_ROOM4_Control+0x1c>
    3e1e:	ab c0       	rjmp	.+342    	; 0x3f76 <APP_ROOM4_Control+0x172>
	{
	case Admin :
		transmitDataBlockOverBluetooth("[1] ROOM4 ON\n",14);
    3e20:	86 e0       	ldi	r24, 0x06	; 6
    3e22:	93 e0       	ldi	r25, 0x03	; 3
    3e24:	6e e0       	ldi	r22, 0x0E	; 14
    3e26:	70 e0       	ldi	r23, 0x00	; 0
    3e28:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] ROOM4 OFF\n",15);
    3e2c:	84 e1       	ldi	r24, 0x14	; 20
    3e2e:	93 e0       	ldi	r25, 0x03	; 3
    3e30:	6f e0       	ldi	r22, 0x0F	; 15
    3e32:	70 e0       	ldi	r23, 0x00	; 0
    3e34:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    3e38:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    3e3c:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    3e40:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    3e44:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    3e46:	89 81       	ldd	r24, Y+1	; 0x01
    3e48:	81 33       	cpi	r24, 0x31	; 49
    3e4a:	51 f0       	breq	.+20     	; 0x3e60 <APP_ROOM4_Control+0x5c>
    3e4c:	82 33       	cpi	r24, 0x32	; 50
    3e4e:	18 f4       	brcc	.+6      	; 0x3e56 <APP_ROOM4_Control+0x52>
    3e50:	80 33       	cpi	r24, 0x30	; 48
    3e52:	91 f7       	brne	.-28     	; 0x3e38 <APP_ROOM4_Control+0x34>
    3e54:	15 c0       	rjmp	.+42     	; 0x3e80 <APP_ROOM4_Control+0x7c>
    3e56:	82 33       	cpi	r24, 0x32	; 50
    3e58:	59 f0       	breq	.+22     	; 0x3e70 <APP_ROOM4_Control+0x6c>
    3e5a:	83 34       	cpi	r24, 0x43	; 67
    3e5c:	69 f7       	brne	.-38     	; 0x3e38 <APP_ROOM4_Control+0x34>
    3e5e:	14 c0       	rjmp	.+40     	; 0x3e88 <APP_ROOM4_Control+0x84>
			{
			case '1' :
				Ecual_Led_TurnOn(&LED1[3]);
    3e60:	87 eb       	ldi	r24, 0xB7	; 183
    3e62:	97 e0       	ldi	r25, 0x07	; 7
    3e64:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
				Count = 0;
				Next = RSt30;
    3e68:	83 e3       	ldi	r24, 0x33	; 51
    3e6a:	80 93 06 08 	sts	0x0806, r24
    3e6e:	83 c0       	rjmp	.+262    	; 0x3f76 <APP_ROOM4_Control+0x172>
				break;
			case '2' :
				Ecual_Led_TurnOff(&LED1[3]);
    3e70:	87 eb       	ldi	r24, 0xB7	; 183
    3e72:	97 e0       	ldi	r25, 0x07	; 7
    3e74:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
				Count = 0;
				Next = RSt30;
    3e78:	83 e3       	ldi	r24, 0x33	; 51
    3e7a:	80 93 06 08 	sts	0x0806, r24
    3e7e:	7b c0       	rjmp	.+246    	; 0x3f76 <APP_ROOM4_Control+0x172>
				break;
			case '0' :
				Count = 0;
				Next = RSt12;
    3e80:	81 e2       	ldi	r24, 0x21	; 33
    3e82:	80 93 06 08 	sts	0x0806, r24
    3e86:	77 c0       	rjmp	.+238    	; 0x3f76 <APP_ROOM4_Control+0x172>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    3e88:	88 e1       	ldi	r24, 0x18	; 24
    3e8a:	80 93 06 08 	sts	0x0806, r24
    3e8e:	73 c0       	rjmp	.+230    	; 0x3f76 <APP_ROOM4_Control+0x172>
			}
		}
		break;

	case User_Remote :
		transmitDataBlockOverBluetooth("[1] ROOM4 ON\n",14);
    3e90:	86 e0       	ldi	r24, 0x06	; 6
    3e92:	93 e0       	ldi	r25, 0x03	; 3
    3e94:	6e e0       	ldi	r22, 0x0E	; 14
    3e96:	70 e0       	ldi	r23, 0x00	; 0
    3e98:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] ROOM4 OFF\n",15);
    3e9c:	84 e1       	ldi	r24, 0x14	; 20
    3e9e:	93 e0       	ldi	r25, 0x03	; 3
    3ea0:	6f e0       	ldi	r22, 0x0F	; 15
    3ea2:	70 e0       	ldi	r23, 0x00	; 0
    3ea4:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    3ea8:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    3eac:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    3eb0:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    3eb4:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    3eb6:	89 81       	ldd	r24, Y+1	; 0x01
    3eb8:	81 33       	cpi	r24, 0x31	; 49
    3eba:	51 f0       	breq	.+20     	; 0x3ed0 <APP_ROOM4_Control+0xcc>
    3ebc:	82 33       	cpi	r24, 0x32	; 50
    3ebe:	18 f4       	brcc	.+6      	; 0x3ec6 <APP_ROOM4_Control+0xc2>
    3ec0:	80 33       	cpi	r24, 0x30	; 48
    3ec2:	91 f7       	brne	.-28     	; 0x3ea8 <APP_ROOM4_Control+0xa4>
    3ec4:	15 c0       	rjmp	.+42     	; 0x3ef0 <APP_ROOM4_Control+0xec>
    3ec6:	82 33       	cpi	r24, 0x32	; 50
    3ec8:	59 f0       	breq	.+22     	; 0x3ee0 <APP_ROOM4_Control+0xdc>
    3eca:	83 34       	cpi	r24, 0x43	; 67
    3ecc:	69 f7       	brne	.-38     	; 0x3ea8 <APP_ROOM4_Control+0xa4>
    3ece:	14 c0       	rjmp	.+40     	; 0x3ef8 <APP_ROOM4_Control+0xf4>
			{
			case '1' :
				Ecual_Led_TurnOn(&LED1[3]);
    3ed0:	87 eb       	ldi	r24, 0xB7	; 183
    3ed2:	97 e0       	ldi	r25, 0x07	; 7
    3ed4:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
				Count = 0;
				Next = RSt40;
    3ed8:	8d e3       	ldi	r24, 0x3D	; 61
    3eda:	80 93 06 08 	sts	0x0806, r24
    3ede:	4b c0       	rjmp	.+150    	; 0x3f76 <APP_ROOM4_Control+0x172>
				break;
			case '2' :
				Ecual_Led_TurnOff(&LED1[3]);
    3ee0:	87 eb       	ldi	r24, 0xB7	; 183
    3ee2:	97 e0       	ldi	r25, 0x07	; 7
    3ee4:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
				Count = 0;
				Next = RSt40;
    3ee8:	8d e3       	ldi	r24, 0x3D	; 61
    3eea:	80 93 06 08 	sts	0x0806, r24
    3eee:	43 c0       	rjmp	.+134    	; 0x3f76 <APP_ROOM4_Control+0x172>
				break;
			case '0' :
				Count = 0;
				Next = RSt20;
    3ef0:	89 e2       	ldi	r24, 0x29	; 41
    3ef2:	80 93 06 08 	sts	0x0806, r24
    3ef6:	3f c0       	rjmp	.+126    	; 0x3f76 <APP_ROOM4_Control+0x172>
				break;
			case 'C' :
				Count = 0;
				Next = RSt4;
    3ef8:	89 e1       	ldi	r24, 0x19	; 25
    3efa:	80 93 06 08 	sts	0x0806, r24
    3efe:	3b c0       	rjmp	.+118    	; 0x3f76 <APP_ROOM4_Control+0x172>
				break;
			}
		}
		break;
	case User_Keypad :
		CLCD_voidGoto(1,1);
    3f00:	81 e0       	ldi	r24, 0x01	; 1
    3f02:	61 e0       	ldi	r22, 0x01	; 1
    3f04:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[1]ROOM4 ON");
    3f08:	83 e2       	ldi	r24, 0x23	; 35
    3f0a:	93 e0       	ldi	r25, 0x03	; 3
    3f0c:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    3f10:	82 e0       	ldi	r24, 0x02	; 2
    3f12:	61 e0       	ldi	r22, 0x01	; 1
    3f14:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[2]ROOM4 OFF");
    3f18:	8f e2       	ldi	r24, 0x2F	; 47
    3f1a:	93 e0       	ldi	r25, 0x03	; 3
    3f1c:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		switch(Local_u8Key)
    3f20:	80 91 fb 07 	lds	r24, 0x07FB
    3f24:	82 33       	cpi	r24, 0x32	; 50
    3f26:	91 f0       	breq	.+36     	; 0x3f4c <APP_ROOM4_Control+0x148>
    3f28:	83 33       	cpi	r24, 0x33	; 51
    3f2a:	18 f4       	brcc	.+6      	; 0x3f32 <APP_ROOM4_Control+0x12e>
    3f2c:	81 33       	cpi	r24, 0x31	; 49
    3f2e:	19 f5       	brne	.+70     	; 0x3f76 <APP_ROOM4_Control+0x172>
    3f30:	05 c0       	rjmp	.+10     	; 0x3f3c <APP_ROOM4_Control+0x138>
    3f32:	83 34       	cpi	r24, 0x43	; 67
    3f34:	d1 f0       	breq	.+52     	; 0x3f6a <APP_ROOM4_Control+0x166>
    3f36:	82 35       	cpi	r24, 0x52	; 82
    3f38:	f1 f4       	brne	.+60     	; 0x3f76 <APP_ROOM4_Control+0x172>
    3f3a:	10 c0       	rjmp	.+32     	; 0x3f5c <APP_ROOM4_Control+0x158>
		{
		case '1' :
			Ecual_Led_TurnOn(&LED1[3]);
    3f3c:	87 eb       	ldi	r24, 0xB7	; 183
    3f3e:	97 e0       	ldi	r25, 0x07	; 7
    3f40:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
			Next = ESt11;
    3f44:	8b e0       	ldi	r24, 0x0B	; 11
    3f46:	80 93 06 08 	sts	0x0806, r24
    3f4a:	15 c0       	rjmp	.+42     	; 0x3f76 <APP_ROOM4_Control+0x172>
			break;
		case '2' :
			Ecual_Led_TurnOff(&LED1[3]);
    3f4c:	87 eb       	ldi	r24, 0xB7	; 183
    3f4e:	97 e0       	ldi	r25, 0x07	; 7
    3f50:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
			Next = ESt11;
    3f54:	8b e0       	ldi	r24, 0x0B	; 11
    3f56:	80 93 06 08 	sts	0x0806, r24
    3f5a:	0d c0       	rjmp	.+26     	; 0x3f76 <APP_ROOM4_Control+0x172>
			break;
		case 'R' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3f5c:	81 e0       	ldi	r24, 0x01	; 1
    3f5e:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt8;
    3f62:	88 e0       	ldi	r24, 0x08	; 8
    3f64:	80 93 06 08 	sts	0x0806, r24
    3f68:	06 c0       	rjmp	.+12     	; 0x3f76 <APP_ROOM4_Control+0x172>
			break;

		case 'C' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    3f6a:	81 e0       	ldi	r24, 0x01	; 1
    3f6c:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    3f70:	81 e0       	ldi	r24, 0x01	; 1
    3f72:	80 93 06 08 	sts	0x0806, r24
			break;
		}
	}
	return Next;
}
    3f76:	80 91 06 08 	lds	r24, 0x0806
    3f7a:	0f 90       	pop	r0
    3f7c:	cf 91       	pop	r28
    3f7e:	df 91       	pop	r29
    3f80:	08 95       	ret

00003f82 <APP_ROOM5_Control>:
static state APP_ROOM5_Control(Login_t Copy_LoginType){
    3f82:	df 93       	push	r29
    3f84:	cf 93       	push	r28
    3f86:	0f 92       	push	r0
    3f88:	cd b7       	in	r28, 0x3d	; 61
    3f8a:	de b7       	in	r29, 0x3e	; 62
	volatile uint_8 Read = 0;
    3f8c:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	switch(Copy_LoginType)
    3f8e:	81 30       	cpi	r24, 0x01	; 1
    3f90:	f1 f1       	breq	.+124    	; 0x400e <APP_ROOM5_Control+0x8c>
    3f92:	81 30       	cpi	r24, 0x01	; 1
    3f94:	08 f4       	brcc	.+2      	; 0x3f98 <APP_ROOM5_Control+0x16>
    3f96:	73 c0       	rjmp	.+230    	; 0x407e <APP_ROOM5_Control+0xfc>
    3f98:	82 30       	cpi	r24, 0x02	; 2
    3f9a:	09 f0       	breq	.+2      	; 0x3f9e <APP_ROOM5_Control+0x1c>
    3f9c:	ab c0       	rjmp	.+342    	; 0x40f4 <APP_ROOM5_Control+0x172>
	{
	case Admin :
		transmitDataBlockOverBluetooth("[1] ROOM5 ON\n",14);
    3f9e:	8c e3       	ldi	r24, 0x3C	; 60
    3fa0:	93 e0       	ldi	r25, 0x03	; 3
    3fa2:	6e e0       	ldi	r22, 0x0E	; 14
    3fa4:	70 e0       	ldi	r23, 0x00	; 0
    3fa6:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] ROOM5 OFF\n",15);
    3faa:	8a e4       	ldi	r24, 0x4A	; 74
    3fac:	93 e0       	ldi	r25, 0x03	; 3
    3fae:	6f e0       	ldi	r22, 0x0F	; 15
    3fb0:	70 e0       	ldi	r23, 0x00	; 0
    3fb2:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
			APP_SystemState();
    3fb6:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
			APP_TEMP_MOTOR();
    3fba:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
			Read = UART_ReceiveChar();
    3fbe:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
    3fc2:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    3fc4:	89 81       	ldd	r24, Y+1	; 0x01
    3fc6:	81 33       	cpi	r24, 0x31	; 49
    3fc8:	51 f0       	breq	.+20     	; 0x3fde <APP_ROOM5_Control+0x5c>
    3fca:	82 33       	cpi	r24, 0x32	; 50
    3fcc:	18 f4       	brcc	.+6      	; 0x3fd4 <APP_ROOM5_Control+0x52>
    3fce:	80 33       	cpi	r24, 0x30	; 48
    3fd0:	91 f7       	brne	.-28     	; 0x3fb6 <APP_ROOM5_Control+0x34>
    3fd2:	15 c0       	rjmp	.+42     	; 0x3ffe <APP_ROOM5_Control+0x7c>
    3fd4:	82 33       	cpi	r24, 0x32	; 50
    3fd6:	59 f0       	breq	.+22     	; 0x3fee <APP_ROOM5_Control+0x6c>
    3fd8:	83 34       	cpi	r24, 0x43	; 67
    3fda:	69 f7       	brne	.-38     	; 0x3fb6 <APP_ROOM5_Control+0x34>
    3fdc:	14 c0       	rjmp	.+40     	; 0x4006 <APP_ROOM5_Control+0x84>
			{
			case '1' :
				Ecual_Led_TurnOn(&LED1[4]);
    3fde:	88 eb       	ldi	r24, 0xB8	; 184
    3fe0:	97 e0       	ldi	r25, 0x07	; 7
    3fe2:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
				Count = 0;
				Next = RSt31;
    3fe6:	84 e3       	ldi	r24, 0x34	; 52
    3fe8:	80 93 06 08 	sts	0x0806, r24
    3fec:	83 c0       	rjmp	.+262    	; 0x40f4 <APP_ROOM5_Control+0x172>
				break;
			case '2' :
				Ecual_Led_TurnOff(&LED1[4]);
    3fee:	88 eb       	ldi	r24, 0xB8	; 184
    3ff0:	97 e0       	ldi	r25, 0x07	; 7
    3ff2:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
				Count = 0;
				Next = RSt31;
    3ff6:	84 e3       	ldi	r24, 0x34	; 52
    3ff8:	80 93 06 08 	sts	0x0806, r24
    3ffc:	7b c0       	rjmp	.+246    	; 0x40f4 <APP_ROOM5_Control+0x172>
				break;
			case '0' :
				Count = 0;
				Next = RSt12;
    3ffe:	81 e2       	ldi	r24, 0x21	; 33
    4000:	80 93 06 08 	sts	0x0806, r24
    4004:	77 c0       	rjmp	.+238    	; 0x40f4 <APP_ROOM5_Control+0x172>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    4006:	88 e1       	ldi	r24, 0x18	; 24
    4008:	80 93 06 08 	sts	0x0806, r24
    400c:	73 c0       	rjmp	.+230    	; 0x40f4 <APP_ROOM5_Control+0x172>
			}
		}
		break;

	case User_Remote :
		transmitDataBlockOverBluetooth("[1] ROOM5 ON\n",14);
    400e:	8c e3       	ldi	r24, 0x3C	; 60
    4010:	93 e0       	ldi	r25, 0x03	; 3
    4012:	6e e0       	ldi	r22, 0x0E	; 14
    4014:	70 e0       	ldi	r23, 0x00	; 0
    4016:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] ROOM5 OFF\n",15);
    401a:	8a e4       	ldi	r24, 0x4A	; 74
    401c:	93 e0       	ldi	r25, 0x03	; 3
    401e:	6f e0       	ldi	r22, 0x0F	; 15
    4020:	70 e0       	ldi	r23, 0x00	; 0
    4022:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    4026:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    402a:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    402e:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    4032:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    4034:	89 81       	ldd	r24, Y+1	; 0x01
    4036:	81 33       	cpi	r24, 0x31	; 49
    4038:	51 f0       	breq	.+20     	; 0x404e <APP_ROOM5_Control+0xcc>
    403a:	82 33       	cpi	r24, 0x32	; 50
    403c:	18 f4       	brcc	.+6      	; 0x4044 <APP_ROOM5_Control+0xc2>
    403e:	80 33       	cpi	r24, 0x30	; 48
    4040:	91 f7       	brne	.-28     	; 0x4026 <APP_ROOM5_Control+0xa4>
    4042:	15 c0       	rjmp	.+42     	; 0x406e <APP_ROOM5_Control+0xec>
    4044:	82 33       	cpi	r24, 0x32	; 50
    4046:	59 f0       	breq	.+22     	; 0x405e <APP_ROOM5_Control+0xdc>
    4048:	83 34       	cpi	r24, 0x43	; 67
    404a:	69 f7       	brne	.-38     	; 0x4026 <APP_ROOM5_Control+0xa4>
    404c:	14 c0       	rjmp	.+40     	; 0x4076 <APP_ROOM5_Control+0xf4>
			{
			case '1' :
				Ecual_Led_TurnOn(&LED1[4]);
    404e:	88 eb       	ldi	r24, 0xB8	; 184
    4050:	97 e0       	ldi	r25, 0x07	; 7
    4052:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
				Count = 0;
				Next = RSt41;
    4056:	8e e3       	ldi	r24, 0x3E	; 62
    4058:	80 93 06 08 	sts	0x0806, r24
    405c:	4b c0       	rjmp	.+150    	; 0x40f4 <APP_ROOM5_Control+0x172>
				break;
			case '2' :
				Ecual_Led_TurnOff(&LED1[4]);
    405e:	88 eb       	ldi	r24, 0xB8	; 184
    4060:	97 e0       	ldi	r25, 0x07	; 7
    4062:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
				Count = 0;
				Next = RSt41;
    4066:	8e e3       	ldi	r24, 0x3E	; 62
    4068:	80 93 06 08 	sts	0x0806, r24
    406c:	43 c0       	rjmp	.+134    	; 0x40f4 <APP_ROOM5_Control+0x172>
				break;
			case '0' :
				Count = 0;
				Next = RSt20;
    406e:	89 e2       	ldi	r24, 0x29	; 41
    4070:	80 93 06 08 	sts	0x0806, r24
    4074:	3f c0       	rjmp	.+126    	; 0x40f4 <APP_ROOM5_Control+0x172>
				break;
			case 'C' :
				Count = 0;
				Next = RSt4;
    4076:	89 e1       	ldi	r24, 0x19	; 25
    4078:	80 93 06 08 	sts	0x0806, r24
    407c:	3b c0       	rjmp	.+118    	; 0x40f4 <APP_ROOM5_Control+0x172>
				break;
			}
		}
		break;
	case User_Keypad :
		CLCD_voidGoto(1,1);
    407e:	81 e0       	ldi	r24, 0x01	; 1
    4080:	61 e0       	ldi	r22, 0x01	; 1
    4082:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[1]ROOM5 ON");
    4086:	89 e5       	ldi	r24, 0x59	; 89
    4088:	93 e0       	ldi	r25, 0x03	; 3
    408a:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    408e:	82 e0       	ldi	r24, 0x02	; 2
    4090:	61 e0       	ldi	r22, 0x01	; 1
    4092:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[2]ROOM5 OFF");
    4096:	85 e6       	ldi	r24, 0x65	; 101
    4098:	93 e0       	ldi	r25, 0x03	; 3
    409a:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		switch(Local_u8Key)
    409e:	80 91 fb 07 	lds	r24, 0x07FB
    40a2:	82 33       	cpi	r24, 0x32	; 50
    40a4:	91 f0       	breq	.+36     	; 0x40ca <APP_ROOM5_Control+0x148>
    40a6:	83 33       	cpi	r24, 0x33	; 51
    40a8:	18 f4       	brcc	.+6      	; 0x40b0 <APP_ROOM5_Control+0x12e>
    40aa:	81 33       	cpi	r24, 0x31	; 49
    40ac:	19 f5       	brne	.+70     	; 0x40f4 <APP_ROOM5_Control+0x172>
    40ae:	05 c0       	rjmp	.+10     	; 0x40ba <APP_ROOM5_Control+0x138>
    40b0:	83 34       	cpi	r24, 0x43	; 67
    40b2:	d1 f0       	breq	.+52     	; 0x40e8 <APP_ROOM5_Control+0x166>
    40b4:	82 35       	cpi	r24, 0x52	; 82
    40b6:	f1 f4       	brne	.+60     	; 0x40f4 <APP_ROOM5_Control+0x172>
    40b8:	10 c0       	rjmp	.+32     	; 0x40da <APP_ROOM5_Control+0x158>
		{
		case '1' :
			Ecual_Led_TurnOn(&LED1[4]);
    40ba:	88 eb       	ldi	r24, 0xB8	; 184
    40bc:	97 e0       	ldi	r25, 0x07	; 7
    40be:	0e 94 8c 10 	call	0x2118	; 0x2118 <Ecual_Led_TurnOn>
			Next = ESt11;
    40c2:	8b e0       	ldi	r24, 0x0B	; 11
    40c4:	80 93 06 08 	sts	0x0806, r24
    40c8:	15 c0       	rjmp	.+42     	; 0x40f4 <APP_ROOM5_Control+0x172>
			break;
		case '2' :
			Ecual_Led_TurnOff(&LED1[4]);
    40ca:	88 eb       	ldi	r24, 0xB8	; 184
    40cc:	97 e0       	ldi	r25, 0x07	; 7
    40ce:	0e 94 7b 10 	call	0x20f6	; 0x20f6 <Ecual_Led_TurnOff>
			Next = ESt11;
    40d2:	8b e0       	ldi	r24, 0x0B	; 11
    40d4:	80 93 06 08 	sts	0x0806, r24
    40d8:	0d c0       	rjmp	.+26     	; 0x40f4 <APP_ROOM5_Control+0x172>
			break;
		case 'R' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    40da:	81 e0       	ldi	r24, 0x01	; 1
    40dc:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt8;
    40e0:	88 e0       	ldi	r24, 0x08	; 8
    40e2:	80 93 06 08 	sts	0x0806, r24
    40e6:	06 c0       	rjmp	.+12     	; 0x40f4 <APP_ROOM5_Control+0x172>
			break;

		case 'C' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    40e8:	81 e0       	ldi	r24, 0x01	; 1
    40ea:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    40ee:	81 e0       	ldi	r24, 0x01	; 1
    40f0:	80 93 06 08 	sts	0x0806, r24
			break;
		}
	}
	return Next;
}
    40f4:	80 91 06 08 	lds	r24, 0x0806
    40f8:	0f 90       	pop	r0
    40fa:	cf 91       	pop	r28
    40fc:	df 91       	pop	r29
    40fe:	08 95       	ret

00004100 <APP_ROOM1_Status>:

static state APP_ROOM1_Status(Login_t Copy_LoginType){
    4100:	1f 93       	push	r17
    4102:	df 93       	push	r29
    4104:	cf 93       	push	r28
    4106:	00 d0       	rcall	.+0      	; 0x4108 <APP_ROOM1_Status+0x8>
    4108:	cd b7       	in	r28, 0x3d	; 61
    410a:	de b7       	in	r29, 0x3e	; 62
    410c:	18 2f       	mov	r17, r24
	volatile uint_8 Read = 0;
    410e:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	Led_State Local_u8LedState =LedOff;
    4110:	1a 82       	std	Y+2, r1	; 0x02
	Ecual_Led_GetStatus(&LED1[0], &Local_u8LedState);
    4112:	84 eb       	ldi	r24, 0xB4	; 180
    4114:	97 e0       	ldi	r25, 0x07	; 7
    4116:	be 01       	movw	r22, r28
    4118:	6e 5f       	subi	r22, 0xFE	; 254
    411a:	7f 4f       	sbci	r23, 0xFF	; 255
    411c:	0e 94 4a 10 	call	0x2094	; 0x2094 <Ecual_Led_GetStatus>

	switch(Copy_LoginType)
    4120:	11 30       	cpi	r17, 0x01	; 1
    4122:	71 f1       	breq	.+92     	; 0x4180 <APP_ROOM1_Status+0x80>
    4124:	11 30       	cpi	r17, 0x01	; 1
    4126:	08 f4       	brcc	.+2      	; 0x412a <APP_ROOM1_Status+0x2a>
    4128:	53 c0       	rjmp	.+166    	; 0x41d0 <APP_ROOM1_Status+0xd0>
    412a:	12 30       	cpi	r17, 0x02	; 2
    412c:	09 f0       	breq	.+2      	; 0x4130 <APP_ROOM1_Status+0x30>
    412e:	7a c0       	rjmp	.+244    	; 0x4224 <APP_ROOM1_Status+0x124>
	{
	case Admin :

		switch(Local_u8LedState)
    4130:	8a 81       	ldd	r24, Y+2	; 0x02
    4132:	88 23       	and	r24, r24
    4134:	19 f0       	breq	.+6      	; 0x413c <APP_ROOM1_Status+0x3c>
    4136:	81 30       	cpi	r24, 0x01	; 1
    4138:	71 f4       	brne	.+28     	; 0x4156 <APP_ROOM1_Status+0x56>
    413a:	07 c0       	rjmp	.+14     	; 0x414a <APP_ROOM1_Status+0x4a>
		{
		case LedOff :
			transmitDataBlockOverBluetooth("[1] ROOM1 OFF\n",14);
    413c:	82 e7       	ldi	r24, 0x72	; 114
    413e:	93 e0       	ldi	r25, 0x03	; 3
    4140:	6e e0       	ldi	r22, 0x0E	; 14
    4142:	70 e0       	ldi	r23, 0x00	; 0
    4144:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    4148:	06 c0       	rjmp	.+12     	; 0x4156 <APP_ROOM1_Status+0x56>
			break;
		case LedOn :
			transmitDataBlockOverBluetooth("[2] ROOM1 ON\n",15);
    414a:	81 e8       	ldi	r24, 0x81	; 129
    414c:	93 e0       	ldi	r25, 0x03	; 3
    414e:	6f e0       	ldi	r22, 0x0F	; 15
    4150:	70 e0       	ldi	r23, 0x00	; 0
    4152:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
			break;
		}

		while(Count){
				APP_SystemState();
    4156:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    415a:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    415e:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    4162:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    4164:	89 81       	ldd	r24, Y+1	; 0x01
    4166:	80 33       	cpi	r24, 0x30	; 48
    4168:	19 f0       	breq	.+6      	; 0x4170 <APP_ROOM1_Status+0x70>
    416a:	83 34       	cpi	r24, 0x43	; 67
    416c:	a1 f7       	brne	.-24     	; 0x4156 <APP_ROOM1_Status+0x56>
    416e:	04 c0       	rjmp	.+8      	; 0x4178 <APP_ROOM1_Status+0x78>
			{
			case '0' :
				Count = 0;
				Next = RSt16;
    4170:	85 e2       	ldi	r24, 0x25	; 37
    4172:	80 93 06 08 	sts	0x0806, r24
    4176:	56 c0       	rjmp	.+172    	; 0x4224 <APP_ROOM1_Status+0x124>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    4178:	88 e1       	ldi	r24, 0x18	; 24
    417a:	80 93 06 08 	sts	0x0806, r24
    417e:	52 c0       	rjmp	.+164    	; 0x4224 <APP_ROOM1_Status+0x124>
			}
		}
		break;

		case User_Remote :
			switch(Local_u8LedState)
    4180:	8a 81       	ldd	r24, Y+2	; 0x02
    4182:	88 23       	and	r24, r24
    4184:	19 f0       	breq	.+6      	; 0x418c <APP_ROOM1_Status+0x8c>
    4186:	81 30       	cpi	r24, 0x01	; 1
    4188:	71 f4       	brne	.+28     	; 0x41a6 <APP_ROOM1_Status+0xa6>
    418a:	07 c0       	rjmp	.+14     	; 0x419a <APP_ROOM1_Status+0x9a>
			{
			case LedOff :
				transmitDataBlockOverBluetooth("[1] ROOM1 OFF\n",14);
    418c:	82 e7       	ldi	r24, 0x72	; 114
    418e:	93 e0       	ldi	r25, 0x03	; 3
    4190:	6e e0       	ldi	r22, 0x0E	; 14
    4192:	70 e0       	ldi	r23, 0x00	; 0
    4194:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    4198:	06 c0       	rjmp	.+12     	; 0x41a6 <APP_ROOM1_Status+0xa6>
				break;
			case LedOn :
				transmitDataBlockOverBluetooth("[2] ROOM1 ON\n",15);
    419a:	81 e8       	ldi	r24, 0x81	; 129
    419c:	93 e0       	ldi	r25, 0x03	; 3
    419e:	6f e0       	ldi	r22, 0x0F	; 15
    41a0:	70 e0       	ldi	r23, 0x00	; 0
    41a2:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				break;
			}

			while(Count){
					APP_SystemState();
    41a6:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
					APP_TEMP_MOTOR();
    41aa:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
					Read = UART_ReceiveCharfrist();
    41ae:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    41b2:	89 83       	std	Y+1, r24	; 0x01
				switch(Read)
    41b4:	89 81       	ldd	r24, Y+1	; 0x01
    41b6:	80 33       	cpi	r24, 0x30	; 48
    41b8:	19 f0       	breq	.+6      	; 0x41c0 <APP_ROOM1_Status+0xc0>
    41ba:	83 34       	cpi	r24, 0x43	; 67
    41bc:	a1 f7       	brne	.-24     	; 0x41a6 <APP_ROOM1_Status+0xa6>
    41be:	04 c0       	rjmp	.+8      	; 0x41c8 <APP_ROOM1_Status+0xc8>
				{
				case '0' :
					Count = 0;
					Next = RSt23;
    41c0:	8c e2       	ldi	r24, 0x2C	; 44
    41c2:	80 93 06 08 	sts	0x0806, r24
    41c6:	2e c0       	rjmp	.+92     	; 0x4224 <APP_ROOM1_Status+0x124>
					break;
				case 'C' :
					Count = 0;
					Next = RSt4;
    41c8:	89 e1       	ldi	r24, 0x19	; 25
    41ca:	80 93 06 08 	sts	0x0806, r24
    41ce:	2a c0       	rjmp	.+84     	; 0x4224 <APP_ROOM1_Status+0x124>
				}
			}
			break;
			case User_Keypad :

				switch(Local_u8LedState)
    41d0:	8a 81       	ldd	r24, Y+2	; 0x02
    41d2:	88 23       	and	r24, r24
    41d4:	19 f0       	breq	.+6      	; 0x41dc <APP_ROOM1_Status+0xdc>
    41d6:	81 30       	cpi	r24, 0x01	; 1
    41d8:	91 f4       	brne	.+36     	; 0x41fe <APP_ROOM1_Status+0xfe>
    41da:	09 c0       	rjmp	.+18     	; 0x41ee <APP_ROOM1_Status+0xee>
				{
				case LedOff :
					CLCD_voidGoto(1,1);
    41dc:	81 e0       	ldi	r24, 0x01	; 1
    41de:	61 e0       	ldi	r22, 0x01	; 1
    41e0:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("ROOM1 IS OFF");
    41e4:	8f e8       	ldi	r24, 0x8F	; 143
    41e6:	93 e0       	ldi	r25, 0x03	; 3
    41e8:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    41ec:	08 c0       	rjmp	.+16     	; 0x41fe <APP_ROOM1_Status+0xfe>
					break;
				case LedOn :
					CLCD_voidGoto(1,1);
    41ee:	81 e0       	ldi	r24, 0x01	; 1
    41f0:	61 e0       	ldi	r22, 0x01	; 1
    41f2:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("ROOM1 IS ON");
    41f6:	8c e9       	ldi	r24, 0x9C	; 156
    41f8:	93 e0       	ldi	r25, 0x03	; 3
    41fa:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
					break;
				}

				switch(Local_u8Key)
    41fe:	80 91 fb 07 	lds	r24, 0x07FB
    4202:	83 34       	cpi	r24, 0x43	; 67
    4204:	49 f0       	breq	.+18     	; 0x4218 <APP_ROOM1_Status+0x118>
    4206:	82 35       	cpi	r24, 0x52	; 82
    4208:	69 f4       	brne	.+26     	; 0x4224 <APP_ROOM1_Status+0x124>
				{
				case 'R' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    420a:	81 e0       	ldi	r24, 0x01	; 1
    420c:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt4;
    4210:	84 e0       	ldi	r24, 0x04	; 4
    4212:	80 93 06 08 	sts	0x0806, r24
    4216:	06 c0       	rjmp	.+12     	; 0x4224 <APP_ROOM1_Status+0x124>
					break;

				case 'C' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    4218:	81 e0       	ldi	r24, 0x01	; 1
    421a:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt1;
    421e:	81 e0       	ldi	r24, 0x01	; 1
    4220:	80 93 06 08 	sts	0x0806, r24
					break;
				}
	}
	return Next;
}
    4224:	80 91 06 08 	lds	r24, 0x0806
    4228:	0f 90       	pop	r0
    422a:	0f 90       	pop	r0
    422c:	cf 91       	pop	r28
    422e:	df 91       	pop	r29
    4230:	1f 91       	pop	r17
    4232:	08 95       	ret

00004234 <APP_ROOM2_Status>:
static state APP_ROOM2_Status(Login_t Copy_LoginType){
    4234:	1f 93       	push	r17
    4236:	df 93       	push	r29
    4238:	cf 93       	push	r28
    423a:	00 d0       	rcall	.+0      	; 0x423c <APP_ROOM2_Status+0x8>
    423c:	cd b7       	in	r28, 0x3d	; 61
    423e:	de b7       	in	r29, 0x3e	; 62
    4240:	18 2f       	mov	r17, r24
	volatile uint_8 Read = 0;
    4242:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	Led_State Local_u8LedState = LedOff;
    4244:	1a 82       	std	Y+2, r1	; 0x02
	Ecual_Led_GetStatus(&LED1[1], &Local_u8LedState);
    4246:	85 eb       	ldi	r24, 0xB5	; 181
    4248:	97 e0       	ldi	r25, 0x07	; 7
    424a:	be 01       	movw	r22, r28
    424c:	6e 5f       	subi	r22, 0xFE	; 254
    424e:	7f 4f       	sbci	r23, 0xFF	; 255
    4250:	0e 94 4a 10 	call	0x2094	; 0x2094 <Ecual_Led_GetStatus>

	switch(Copy_LoginType)
    4254:	11 30       	cpi	r17, 0x01	; 1
    4256:	71 f1       	breq	.+92     	; 0x42b4 <APP_ROOM2_Status+0x80>
    4258:	11 30       	cpi	r17, 0x01	; 1
    425a:	08 f4       	brcc	.+2      	; 0x425e <APP_ROOM2_Status+0x2a>
    425c:	53 c0       	rjmp	.+166    	; 0x4304 <APP_ROOM2_Status+0xd0>
    425e:	12 30       	cpi	r17, 0x02	; 2
    4260:	09 f0       	breq	.+2      	; 0x4264 <APP_ROOM2_Status+0x30>
    4262:	7a c0       	rjmp	.+244    	; 0x4358 <APP_ROOM2_Status+0x124>
	{
	case Admin :

		switch(Local_u8LedState)
    4264:	8a 81       	ldd	r24, Y+2	; 0x02
    4266:	88 23       	and	r24, r24
    4268:	19 f0       	breq	.+6      	; 0x4270 <APP_ROOM2_Status+0x3c>
    426a:	81 30       	cpi	r24, 0x01	; 1
    426c:	71 f4       	brne	.+28     	; 0x428a <APP_ROOM2_Status+0x56>
    426e:	07 c0       	rjmp	.+14     	; 0x427e <APP_ROOM2_Status+0x4a>
		{
		case LedOff :
			transmitDataBlockOverBluetooth("[1] ROOM2 OFF\n",14);
    4270:	88 ea       	ldi	r24, 0xA8	; 168
    4272:	93 e0       	ldi	r25, 0x03	; 3
    4274:	6e e0       	ldi	r22, 0x0E	; 14
    4276:	70 e0       	ldi	r23, 0x00	; 0
    4278:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    427c:	06 c0       	rjmp	.+12     	; 0x428a <APP_ROOM2_Status+0x56>
			break;
		case LedOn :
			transmitDataBlockOverBluetooth("[2] ROOM2 ON\n",15);
    427e:	87 eb       	ldi	r24, 0xB7	; 183
    4280:	93 e0       	ldi	r25, 0x03	; 3
    4282:	6f e0       	ldi	r22, 0x0F	; 15
    4284:	70 e0       	ldi	r23, 0x00	; 0
    4286:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
			break;
		}

		while(Count){
				APP_SystemState();
    428a:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    428e:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    4292:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    4296:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    4298:	89 81       	ldd	r24, Y+1	; 0x01
    429a:	80 33       	cpi	r24, 0x30	; 48
    429c:	19 f0       	breq	.+6      	; 0x42a4 <APP_ROOM2_Status+0x70>
    429e:	83 34       	cpi	r24, 0x43	; 67
    42a0:	a1 f7       	brne	.-24     	; 0x428a <APP_ROOM2_Status+0x56>
    42a2:	04 c0       	rjmp	.+8      	; 0x42ac <APP_ROOM2_Status+0x78>
			{
			case '0' :
				Count = 0;
				Next = RSt16;
    42a4:	85 e2       	ldi	r24, 0x25	; 37
    42a6:	80 93 06 08 	sts	0x0806, r24
    42aa:	56 c0       	rjmp	.+172    	; 0x4358 <APP_ROOM2_Status+0x124>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    42ac:	88 e1       	ldi	r24, 0x18	; 24
    42ae:	80 93 06 08 	sts	0x0806, r24
    42b2:	52 c0       	rjmp	.+164    	; 0x4358 <APP_ROOM2_Status+0x124>
		}
		break;

		case User_Remote :

			switch(Local_u8LedState)
    42b4:	8a 81       	ldd	r24, Y+2	; 0x02
    42b6:	88 23       	and	r24, r24
    42b8:	19 f0       	breq	.+6      	; 0x42c0 <APP_ROOM2_Status+0x8c>
    42ba:	81 30       	cpi	r24, 0x01	; 1
    42bc:	71 f4       	brne	.+28     	; 0x42da <APP_ROOM2_Status+0xa6>
    42be:	07 c0       	rjmp	.+14     	; 0x42ce <APP_ROOM2_Status+0x9a>
			{
			case LedOff :
				transmitDataBlockOverBluetooth("[1] ROOM2 OFF\n",14);
    42c0:	88 ea       	ldi	r24, 0xA8	; 168
    42c2:	93 e0       	ldi	r25, 0x03	; 3
    42c4:	6e e0       	ldi	r22, 0x0E	; 14
    42c6:	70 e0       	ldi	r23, 0x00	; 0
    42c8:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    42cc:	06 c0       	rjmp	.+12     	; 0x42da <APP_ROOM2_Status+0xa6>
				break;
			case LedOn :
				transmitDataBlockOverBluetooth("[2] ROOM2 ON\n",15);
    42ce:	87 eb       	ldi	r24, 0xB7	; 183
    42d0:	93 e0       	ldi	r25, 0x03	; 3
    42d2:	6f e0       	ldi	r22, 0x0F	; 15
    42d4:	70 e0       	ldi	r23, 0x00	; 0
    42d6:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				break;
			}

			while(Count){
					APP_SystemState();
    42da:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
					APP_TEMP_MOTOR();
    42de:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
					Read = UART_ReceiveCharfrist();
    42e2:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    42e6:	89 83       	std	Y+1, r24	; 0x01
				switch(Read)
    42e8:	89 81       	ldd	r24, Y+1	; 0x01
    42ea:	80 33       	cpi	r24, 0x30	; 48
    42ec:	19 f0       	breq	.+6      	; 0x42f4 <APP_ROOM2_Status+0xc0>
    42ee:	83 34       	cpi	r24, 0x43	; 67
    42f0:	a1 f7       	brne	.-24     	; 0x42da <APP_ROOM2_Status+0xa6>
    42f2:	04 c0       	rjmp	.+8      	; 0x42fc <APP_ROOM2_Status+0xc8>
				{
				case '0' :
					Count = 0;
					Next = RSt23;
    42f4:	8c e2       	ldi	r24, 0x2C	; 44
    42f6:	80 93 06 08 	sts	0x0806, r24
    42fa:	2e c0       	rjmp	.+92     	; 0x4358 <APP_ROOM2_Status+0x124>
					break;
				case 'C' :
					Count = 0;
					Next = RSt4;
    42fc:	89 e1       	ldi	r24, 0x19	; 25
    42fe:	80 93 06 08 	sts	0x0806, r24
    4302:	2a c0       	rjmp	.+84     	; 0x4358 <APP_ROOM2_Status+0x124>
				}
			}
			break;
			case User_Keypad :

				switch(Local_u8LedState)
    4304:	8a 81       	ldd	r24, Y+2	; 0x02
    4306:	88 23       	and	r24, r24
    4308:	19 f0       	breq	.+6      	; 0x4310 <APP_ROOM2_Status+0xdc>
    430a:	81 30       	cpi	r24, 0x01	; 1
    430c:	91 f4       	brne	.+36     	; 0x4332 <APP_ROOM2_Status+0xfe>
    430e:	09 c0       	rjmp	.+18     	; 0x4322 <APP_ROOM2_Status+0xee>
				{
				case LedOff :
					CLCD_voidGoto(1,1);
    4310:	81 e0       	ldi	r24, 0x01	; 1
    4312:	61 e0       	ldi	r22, 0x01	; 1
    4314:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("ROOM2 IS OFF");
    4318:	85 ec       	ldi	r24, 0xC5	; 197
    431a:	93 e0       	ldi	r25, 0x03	; 3
    431c:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    4320:	08 c0       	rjmp	.+16     	; 0x4332 <APP_ROOM2_Status+0xfe>
					break;
				case LedOn :
					CLCD_voidGoto(1,1);
    4322:	81 e0       	ldi	r24, 0x01	; 1
    4324:	61 e0       	ldi	r22, 0x01	; 1
    4326:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("ROOM2 IS ON");
    432a:	82 ed       	ldi	r24, 0xD2	; 210
    432c:	93 e0       	ldi	r25, 0x03	; 3
    432e:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
					break;
				}

				switch(Local_u8Key)
    4332:	80 91 fb 07 	lds	r24, 0x07FB
    4336:	83 34       	cpi	r24, 0x43	; 67
    4338:	49 f0       	breq	.+18     	; 0x434c <APP_ROOM2_Status+0x118>
    433a:	82 35       	cpi	r24, 0x52	; 82
    433c:	69 f4       	brne	.+26     	; 0x4358 <APP_ROOM2_Status+0x124>
				{
				case 'R' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    433e:	81 e0       	ldi	r24, 0x01	; 1
    4340:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt4;
    4344:	84 e0       	ldi	r24, 0x04	; 4
    4346:	80 93 06 08 	sts	0x0806, r24
    434a:	06 c0       	rjmp	.+12     	; 0x4358 <APP_ROOM2_Status+0x124>
					break;

				case 'C' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    434c:	81 e0       	ldi	r24, 0x01	; 1
    434e:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt1;
    4352:	81 e0       	ldi	r24, 0x01	; 1
    4354:	80 93 06 08 	sts	0x0806, r24
					break;
				}
	}
	return Next;
}
    4358:	80 91 06 08 	lds	r24, 0x0806
    435c:	0f 90       	pop	r0
    435e:	0f 90       	pop	r0
    4360:	cf 91       	pop	r28
    4362:	df 91       	pop	r29
    4364:	1f 91       	pop	r17
    4366:	08 95       	ret

00004368 <APP_ROOM3_Status>:

static state APP_ROOM3_Status(Login_t Copy_LoginType){
    4368:	1f 93       	push	r17
    436a:	df 93       	push	r29
    436c:	cf 93       	push	r28
    436e:	00 d0       	rcall	.+0      	; 0x4370 <APP_ROOM3_Status+0x8>
    4370:	cd b7       	in	r28, 0x3d	; 61
    4372:	de b7       	in	r29, 0x3e	; 62
    4374:	18 2f       	mov	r17, r24
	volatile uint_8 Read = 0;
    4376:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	Led_State Local_u8LedState = LedOff;
    4378:	1a 82       	std	Y+2, r1	; 0x02
	Ecual_Led_GetStatus(&LED1[2], &Local_u8LedState);
    437a:	86 eb       	ldi	r24, 0xB6	; 182
    437c:	97 e0       	ldi	r25, 0x07	; 7
    437e:	be 01       	movw	r22, r28
    4380:	6e 5f       	subi	r22, 0xFE	; 254
    4382:	7f 4f       	sbci	r23, 0xFF	; 255
    4384:	0e 94 4a 10 	call	0x2094	; 0x2094 <Ecual_Led_GetStatus>

	switch(Copy_LoginType)
    4388:	11 30       	cpi	r17, 0x01	; 1
    438a:	71 f1       	breq	.+92     	; 0x43e8 <APP_ROOM3_Status+0x80>
    438c:	11 30       	cpi	r17, 0x01	; 1
    438e:	08 f4       	brcc	.+2      	; 0x4392 <APP_ROOM3_Status+0x2a>
    4390:	53 c0       	rjmp	.+166    	; 0x4438 <APP_ROOM3_Status+0xd0>
    4392:	12 30       	cpi	r17, 0x02	; 2
    4394:	09 f0       	breq	.+2      	; 0x4398 <APP_ROOM3_Status+0x30>
    4396:	7a c0       	rjmp	.+244    	; 0x448c <APP_ROOM3_Status+0x124>
	{
	case Admin :

		switch(Local_u8LedState)
    4398:	8a 81       	ldd	r24, Y+2	; 0x02
    439a:	88 23       	and	r24, r24
    439c:	19 f0       	breq	.+6      	; 0x43a4 <APP_ROOM3_Status+0x3c>
    439e:	81 30       	cpi	r24, 0x01	; 1
    43a0:	71 f4       	brne	.+28     	; 0x43be <APP_ROOM3_Status+0x56>
    43a2:	07 c0       	rjmp	.+14     	; 0x43b2 <APP_ROOM3_Status+0x4a>
		{
		case LedOff :
			transmitDataBlockOverBluetooth("[1] ROOM3 OFF\n",14);
    43a4:	8e ed       	ldi	r24, 0xDE	; 222
    43a6:	93 e0       	ldi	r25, 0x03	; 3
    43a8:	6e e0       	ldi	r22, 0x0E	; 14
    43aa:	70 e0       	ldi	r23, 0x00	; 0
    43ac:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    43b0:	06 c0       	rjmp	.+12     	; 0x43be <APP_ROOM3_Status+0x56>
			break;
		case LedOn :
			transmitDataBlockOverBluetooth("[2] ROOM3 ON\n",15);
    43b2:	8d ee       	ldi	r24, 0xED	; 237
    43b4:	93 e0       	ldi	r25, 0x03	; 3
    43b6:	6f e0       	ldi	r22, 0x0F	; 15
    43b8:	70 e0       	ldi	r23, 0x00	; 0
    43ba:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
			break;
		}

		while(Count){
				APP_SystemState();
    43be:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    43c2:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    43c6:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    43ca:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    43cc:	89 81       	ldd	r24, Y+1	; 0x01
    43ce:	80 33       	cpi	r24, 0x30	; 48
    43d0:	19 f0       	breq	.+6      	; 0x43d8 <APP_ROOM3_Status+0x70>
    43d2:	83 34       	cpi	r24, 0x43	; 67
    43d4:	a1 f7       	brne	.-24     	; 0x43be <APP_ROOM3_Status+0x56>
    43d6:	04 c0       	rjmp	.+8      	; 0x43e0 <APP_ROOM3_Status+0x78>
			{
			case '0' :
				Count = 0;
				Next = RSt16;
    43d8:	85 e2       	ldi	r24, 0x25	; 37
    43da:	80 93 06 08 	sts	0x0806, r24
    43de:	56 c0       	rjmp	.+172    	; 0x448c <APP_ROOM3_Status+0x124>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    43e0:	88 e1       	ldi	r24, 0x18	; 24
    43e2:	80 93 06 08 	sts	0x0806, r24
    43e6:	52 c0       	rjmp	.+164    	; 0x448c <APP_ROOM3_Status+0x124>
			}
		}
		break;

		case User_Remote :
			switch(Local_u8LedState)
    43e8:	8a 81       	ldd	r24, Y+2	; 0x02
    43ea:	88 23       	and	r24, r24
    43ec:	19 f0       	breq	.+6      	; 0x43f4 <APP_ROOM3_Status+0x8c>
    43ee:	81 30       	cpi	r24, 0x01	; 1
    43f0:	71 f4       	brne	.+28     	; 0x440e <APP_ROOM3_Status+0xa6>
    43f2:	07 c0       	rjmp	.+14     	; 0x4402 <APP_ROOM3_Status+0x9a>
			{
			case LedOff :
				transmitDataBlockOverBluetooth("[1] ROOM3 OFF\n",14);
    43f4:	8e ed       	ldi	r24, 0xDE	; 222
    43f6:	93 e0       	ldi	r25, 0x03	; 3
    43f8:	6e e0       	ldi	r22, 0x0E	; 14
    43fa:	70 e0       	ldi	r23, 0x00	; 0
    43fc:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    4400:	06 c0       	rjmp	.+12     	; 0x440e <APP_ROOM3_Status+0xa6>
				break;
			case LedOn :
				transmitDataBlockOverBluetooth("[2] ROOM3 ON\n",15);
    4402:	8d ee       	ldi	r24, 0xED	; 237
    4404:	93 e0       	ldi	r25, 0x03	; 3
    4406:	6f e0       	ldi	r22, 0x0F	; 15
    4408:	70 e0       	ldi	r23, 0x00	; 0
    440a:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				break;
			}

			while(Count){
					APP_SystemState();
    440e:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
					APP_TEMP_MOTOR();
    4412:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
					Read = UART_ReceiveCharfrist();
    4416:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    441a:	89 83       	std	Y+1, r24	; 0x01
				switch(Read)
    441c:	89 81       	ldd	r24, Y+1	; 0x01
    441e:	80 33       	cpi	r24, 0x30	; 48
    4420:	19 f0       	breq	.+6      	; 0x4428 <APP_ROOM3_Status+0xc0>
    4422:	83 34       	cpi	r24, 0x43	; 67
    4424:	a1 f7       	brne	.-24     	; 0x440e <APP_ROOM3_Status+0xa6>
    4426:	04 c0       	rjmp	.+8      	; 0x4430 <APP_ROOM3_Status+0xc8>
				{
				case '0' :
					Count = 0;
					Next = RSt23;
    4428:	8c e2       	ldi	r24, 0x2C	; 44
    442a:	80 93 06 08 	sts	0x0806, r24
    442e:	2e c0       	rjmp	.+92     	; 0x448c <APP_ROOM3_Status+0x124>
					break;
				case 'C' :
					Count = 0;
					Next = RSt4;
    4430:	89 e1       	ldi	r24, 0x19	; 25
    4432:	80 93 06 08 	sts	0x0806, r24
    4436:	2a c0       	rjmp	.+84     	; 0x448c <APP_ROOM3_Status+0x124>
				}
			}
			break;
			case User_Keypad :

				switch(Local_u8LedState)
    4438:	8a 81       	ldd	r24, Y+2	; 0x02
    443a:	88 23       	and	r24, r24
    443c:	19 f0       	breq	.+6      	; 0x4444 <APP_ROOM3_Status+0xdc>
    443e:	81 30       	cpi	r24, 0x01	; 1
    4440:	91 f4       	brne	.+36     	; 0x4466 <APP_ROOM3_Status+0xfe>
    4442:	09 c0       	rjmp	.+18     	; 0x4456 <APP_ROOM3_Status+0xee>
				{
				case LedOff :
					CLCD_voidGoto(1,1);
    4444:	81 e0       	ldi	r24, 0x01	; 1
    4446:	61 e0       	ldi	r22, 0x01	; 1
    4448:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("ROOM3 IS OFF");
    444c:	8b ef       	ldi	r24, 0xFB	; 251
    444e:	93 e0       	ldi	r25, 0x03	; 3
    4450:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    4454:	08 c0       	rjmp	.+16     	; 0x4466 <APP_ROOM3_Status+0xfe>
					break;
				case LedOn :
					CLCD_voidGoto(1,1);
    4456:	81 e0       	ldi	r24, 0x01	; 1
    4458:	61 e0       	ldi	r22, 0x01	; 1
    445a:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("ROOM3 IS ON");
    445e:	88 e0       	ldi	r24, 0x08	; 8
    4460:	94 e0       	ldi	r25, 0x04	; 4
    4462:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
					break;
				}

				switch(Local_u8Key)
    4466:	80 91 fb 07 	lds	r24, 0x07FB
    446a:	83 34       	cpi	r24, 0x43	; 67
    446c:	49 f0       	breq	.+18     	; 0x4480 <APP_ROOM3_Status+0x118>
    446e:	82 35       	cpi	r24, 0x52	; 82
    4470:	69 f4       	brne	.+26     	; 0x448c <APP_ROOM3_Status+0x124>
				{
				case 'R' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    4472:	81 e0       	ldi	r24, 0x01	; 1
    4474:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt4;
    4478:	84 e0       	ldi	r24, 0x04	; 4
    447a:	80 93 06 08 	sts	0x0806, r24
    447e:	06 c0       	rjmp	.+12     	; 0x448c <APP_ROOM3_Status+0x124>
					break;

				case 'C' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    4480:	81 e0       	ldi	r24, 0x01	; 1
    4482:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt1;
    4486:	81 e0       	ldi	r24, 0x01	; 1
    4488:	80 93 06 08 	sts	0x0806, r24
					break;
				}
	}
	return Next;
}
    448c:	80 91 06 08 	lds	r24, 0x0806
    4490:	0f 90       	pop	r0
    4492:	0f 90       	pop	r0
    4494:	cf 91       	pop	r28
    4496:	df 91       	pop	r29
    4498:	1f 91       	pop	r17
    449a:	08 95       	ret

0000449c <APP_ROOM4_Status>:
static state APP_ROOM4_Status(Login_t Copy_LoginType){
    449c:	1f 93       	push	r17
    449e:	df 93       	push	r29
    44a0:	cf 93       	push	r28
    44a2:	00 d0       	rcall	.+0      	; 0x44a4 <APP_ROOM4_Status+0x8>
    44a4:	cd b7       	in	r28, 0x3d	; 61
    44a6:	de b7       	in	r29, 0x3e	; 62
    44a8:	18 2f       	mov	r17, r24
	volatile uint_8 Read = 0;
    44aa:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	Led_State Local_u8LedState =LedOff;
    44ac:	1a 82       	std	Y+2, r1	; 0x02
	Ecual_Led_GetStatus(&LED1[3], &Local_u8LedState);
    44ae:	87 eb       	ldi	r24, 0xB7	; 183
    44b0:	97 e0       	ldi	r25, 0x07	; 7
    44b2:	be 01       	movw	r22, r28
    44b4:	6e 5f       	subi	r22, 0xFE	; 254
    44b6:	7f 4f       	sbci	r23, 0xFF	; 255
    44b8:	0e 94 4a 10 	call	0x2094	; 0x2094 <Ecual_Led_GetStatus>

	switch(Copy_LoginType)
    44bc:	11 30       	cpi	r17, 0x01	; 1
    44be:	71 f1       	breq	.+92     	; 0x451c <APP_ROOM4_Status+0x80>
    44c0:	11 30       	cpi	r17, 0x01	; 1
    44c2:	08 f4       	brcc	.+2      	; 0x44c6 <APP_ROOM4_Status+0x2a>
    44c4:	53 c0       	rjmp	.+166    	; 0x456c <APP_ROOM4_Status+0xd0>
    44c6:	12 30       	cpi	r17, 0x02	; 2
    44c8:	09 f0       	breq	.+2      	; 0x44cc <APP_ROOM4_Status+0x30>
    44ca:	7a c0       	rjmp	.+244    	; 0x45c0 <APP_ROOM4_Status+0x124>
	{
	case Admin :

		switch(Local_u8LedState)
    44cc:	8a 81       	ldd	r24, Y+2	; 0x02
    44ce:	88 23       	and	r24, r24
    44d0:	19 f0       	breq	.+6      	; 0x44d8 <APP_ROOM4_Status+0x3c>
    44d2:	81 30       	cpi	r24, 0x01	; 1
    44d4:	71 f4       	brne	.+28     	; 0x44f2 <APP_ROOM4_Status+0x56>
    44d6:	07 c0       	rjmp	.+14     	; 0x44e6 <APP_ROOM4_Status+0x4a>
		{
		case LedOff :
			transmitDataBlockOverBluetooth("[1] ROOM4 OFF\n",14);
    44d8:	84 e1       	ldi	r24, 0x14	; 20
    44da:	94 e0       	ldi	r25, 0x04	; 4
    44dc:	6e e0       	ldi	r22, 0x0E	; 14
    44de:	70 e0       	ldi	r23, 0x00	; 0
    44e0:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    44e4:	06 c0       	rjmp	.+12     	; 0x44f2 <APP_ROOM4_Status+0x56>
			break;
		case LedOn :
			transmitDataBlockOverBluetooth("[2] ROOM4 ON\n",15);
    44e6:	83 e2       	ldi	r24, 0x23	; 35
    44e8:	94 e0       	ldi	r25, 0x04	; 4
    44ea:	6f e0       	ldi	r22, 0x0F	; 15
    44ec:	70 e0       	ldi	r23, 0x00	; 0
    44ee:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
			break;
		}

		while(Count){
				APP_SystemState();
    44f2:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    44f6:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    44fa:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    44fe:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    4500:	89 81       	ldd	r24, Y+1	; 0x01
    4502:	80 33       	cpi	r24, 0x30	; 48
    4504:	19 f0       	breq	.+6      	; 0x450c <APP_ROOM4_Status+0x70>
    4506:	83 34       	cpi	r24, 0x43	; 67
    4508:	a1 f7       	brne	.-24     	; 0x44f2 <APP_ROOM4_Status+0x56>
    450a:	04 c0       	rjmp	.+8      	; 0x4514 <APP_ROOM4_Status+0x78>
			{
			case '0' :
				Count = 0;
				Next = RSt16;
    450c:	85 e2       	ldi	r24, 0x25	; 37
    450e:	80 93 06 08 	sts	0x0806, r24
    4512:	56 c0       	rjmp	.+172    	; 0x45c0 <APP_ROOM4_Status+0x124>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    4514:	88 e1       	ldi	r24, 0x18	; 24
    4516:	80 93 06 08 	sts	0x0806, r24
    451a:	52 c0       	rjmp	.+164    	; 0x45c0 <APP_ROOM4_Status+0x124>
			}
		}
		break;

		case User_Remote :
			switch(Local_u8LedState)
    451c:	8a 81       	ldd	r24, Y+2	; 0x02
    451e:	88 23       	and	r24, r24
    4520:	19 f0       	breq	.+6      	; 0x4528 <APP_ROOM4_Status+0x8c>
    4522:	81 30       	cpi	r24, 0x01	; 1
    4524:	71 f4       	brne	.+28     	; 0x4542 <APP_ROOM4_Status+0xa6>
    4526:	07 c0       	rjmp	.+14     	; 0x4536 <APP_ROOM4_Status+0x9a>
			{
			case LedOff :
				transmitDataBlockOverBluetooth("[1] ROOM4 OFF\n",14);
    4528:	84 e1       	ldi	r24, 0x14	; 20
    452a:	94 e0       	ldi	r25, 0x04	; 4
    452c:	6e e0       	ldi	r22, 0x0E	; 14
    452e:	70 e0       	ldi	r23, 0x00	; 0
    4530:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    4534:	06 c0       	rjmp	.+12     	; 0x4542 <APP_ROOM4_Status+0xa6>
				break;
			case LedOn :
				transmitDataBlockOverBluetooth("[2] ROOM4 ON\n",15);
    4536:	83 e2       	ldi	r24, 0x23	; 35
    4538:	94 e0       	ldi	r25, 0x04	; 4
    453a:	6f e0       	ldi	r22, 0x0F	; 15
    453c:	70 e0       	ldi	r23, 0x00	; 0
    453e:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				break;
			}

			while(Count){
					APP_SystemState();
    4542:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
					APP_TEMP_MOTOR();
    4546:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
					Read = UART_ReceiveCharfrist();
    454a:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    454e:	89 83       	std	Y+1, r24	; 0x01
				switch(Read)
    4550:	89 81       	ldd	r24, Y+1	; 0x01
    4552:	80 33       	cpi	r24, 0x30	; 48
    4554:	19 f0       	breq	.+6      	; 0x455c <APP_ROOM4_Status+0xc0>
    4556:	83 34       	cpi	r24, 0x43	; 67
    4558:	a1 f7       	brne	.-24     	; 0x4542 <APP_ROOM4_Status+0xa6>
    455a:	04 c0       	rjmp	.+8      	; 0x4564 <APP_ROOM4_Status+0xc8>
				{
				case '0' :
					Count = 0;
					Next = RSt23;
    455c:	8c e2       	ldi	r24, 0x2C	; 44
    455e:	80 93 06 08 	sts	0x0806, r24
    4562:	2e c0       	rjmp	.+92     	; 0x45c0 <APP_ROOM4_Status+0x124>
					break;
				case 'C' :
					Count = 0;
					Next = RSt4;
    4564:	89 e1       	ldi	r24, 0x19	; 25
    4566:	80 93 06 08 	sts	0x0806, r24
    456a:	2a c0       	rjmp	.+84     	; 0x45c0 <APP_ROOM4_Status+0x124>
				}
			}
			break;
			case User_Keypad :

				switch(Local_u8LedState)
    456c:	8a 81       	ldd	r24, Y+2	; 0x02
    456e:	88 23       	and	r24, r24
    4570:	19 f0       	breq	.+6      	; 0x4578 <APP_ROOM4_Status+0xdc>
    4572:	81 30       	cpi	r24, 0x01	; 1
    4574:	91 f4       	brne	.+36     	; 0x459a <APP_ROOM4_Status+0xfe>
    4576:	09 c0       	rjmp	.+18     	; 0x458a <APP_ROOM4_Status+0xee>
				{
				case LedOff :
					CLCD_voidGoto(1,1);
    4578:	81 e0       	ldi	r24, 0x01	; 1
    457a:	61 e0       	ldi	r22, 0x01	; 1
    457c:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("ROOM4 IS OFF");
    4580:	81 e3       	ldi	r24, 0x31	; 49
    4582:	94 e0       	ldi	r25, 0x04	; 4
    4584:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    4588:	08 c0       	rjmp	.+16     	; 0x459a <APP_ROOM4_Status+0xfe>
					break;
				case LedOn :
					CLCD_voidGoto(1,1);
    458a:	81 e0       	ldi	r24, 0x01	; 1
    458c:	61 e0       	ldi	r22, 0x01	; 1
    458e:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("ROOM4 IS ON");
    4592:	8e e3       	ldi	r24, 0x3E	; 62
    4594:	94 e0       	ldi	r25, 0x04	; 4
    4596:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
					break;
				}

				switch(Local_u8Key)
    459a:	80 91 fb 07 	lds	r24, 0x07FB
    459e:	83 34       	cpi	r24, 0x43	; 67
    45a0:	49 f0       	breq	.+18     	; 0x45b4 <APP_ROOM4_Status+0x118>
    45a2:	82 35       	cpi	r24, 0x52	; 82
    45a4:	69 f4       	brne	.+26     	; 0x45c0 <APP_ROOM4_Status+0x124>
				{
				case 'R' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    45a6:	81 e0       	ldi	r24, 0x01	; 1
    45a8:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt4;
    45ac:	84 e0       	ldi	r24, 0x04	; 4
    45ae:	80 93 06 08 	sts	0x0806, r24
    45b2:	06 c0       	rjmp	.+12     	; 0x45c0 <APP_ROOM4_Status+0x124>
					break;

				case 'C' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    45b4:	81 e0       	ldi	r24, 0x01	; 1
    45b6:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt1;
    45ba:	81 e0       	ldi	r24, 0x01	; 1
    45bc:	80 93 06 08 	sts	0x0806, r24
					break;
				}
	}
	return Next;
}
    45c0:	80 91 06 08 	lds	r24, 0x0806
    45c4:	0f 90       	pop	r0
    45c6:	0f 90       	pop	r0
    45c8:	cf 91       	pop	r28
    45ca:	df 91       	pop	r29
    45cc:	1f 91       	pop	r17
    45ce:	08 95       	ret

000045d0 <APP_ROOM5_Status>:


static state APP_ROOM5_Status(Login_t Copy_LoginType){
    45d0:	1f 93       	push	r17
    45d2:	df 93       	push	r29
    45d4:	cf 93       	push	r28
    45d6:	00 d0       	rcall	.+0      	; 0x45d8 <APP_ROOM5_Status+0x8>
    45d8:	cd b7       	in	r28, 0x3d	; 61
    45da:	de b7       	in	r29, 0x3e	; 62
    45dc:	18 2f       	mov	r17, r24
	volatile uint_8 Read = 0;
    45de:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	Led_State Local_u8LedState =LedOff;
    45e0:	1a 82       	std	Y+2, r1	; 0x02
	Ecual_Led_GetStatus(&LED1[4], &Local_u8LedState);
    45e2:	88 eb       	ldi	r24, 0xB8	; 184
    45e4:	97 e0       	ldi	r25, 0x07	; 7
    45e6:	be 01       	movw	r22, r28
    45e8:	6e 5f       	subi	r22, 0xFE	; 254
    45ea:	7f 4f       	sbci	r23, 0xFF	; 255
    45ec:	0e 94 4a 10 	call	0x2094	; 0x2094 <Ecual_Led_GetStatus>

	switch(Copy_LoginType)
    45f0:	11 30       	cpi	r17, 0x01	; 1
    45f2:	71 f1       	breq	.+92     	; 0x4650 <APP_ROOM5_Status+0x80>
    45f4:	11 30       	cpi	r17, 0x01	; 1
    45f6:	08 f4       	brcc	.+2      	; 0x45fa <APP_ROOM5_Status+0x2a>
    45f8:	53 c0       	rjmp	.+166    	; 0x46a0 <APP_ROOM5_Status+0xd0>
    45fa:	12 30       	cpi	r17, 0x02	; 2
    45fc:	09 f0       	breq	.+2      	; 0x4600 <APP_ROOM5_Status+0x30>
    45fe:	7a c0       	rjmp	.+244    	; 0x46f4 <APP_ROOM5_Status+0x124>
	{
	case Admin :

		switch(Local_u8LedState)
    4600:	8a 81       	ldd	r24, Y+2	; 0x02
    4602:	88 23       	and	r24, r24
    4604:	19 f0       	breq	.+6      	; 0x460c <APP_ROOM5_Status+0x3c>
    4606:	81 30       	cpi	r24, 0x01	; 1
    4608:	71 f4       	brne	.+28     	; 0x4626 <APP_ROOM5_Status+0x56>
    460a:	07 c0       	rjmp	.+14     	; 0x461a <APP_ROOM5_Status+0x4a>
		{
		case LedOff :
			transmitDataBlockOverBluetooth("[1] ROOM5 OFF\n",14);
    460c:	8a e4       	ldi	r24, 0x4A	; 74
    460e:	94 e0       	ldi	r25, 0x04	; 4
    4610:	6e e0       	ldi	r22, 0x0E	; 14
    4612:	70 e0       	ldi	r23, 0x00	; 0
    4614:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    4618:	06 c0       	rjmp	.+12     	; 0x4626 <APP_ROOM5_Status+0x56>
			break;
		case LedOn :
			transmitDataBlockOverBluetooth("[2] ROOM5 ON\n",15);
    461a:	89 e5       	ldi	r24, 0x59	; 89
    461c:	94 e0       	ldi	r25, 0x04	; 4
    461e:	6f e0       	ldi	r22, 0x0F	; 15
    4620:	70 e0       	ldi	r23, 0x00	; 0
    4622:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
			break;
		}

		while(Count){
				APP_SystemState();
    4626:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    462a:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    462e:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    4632:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    4634:	89 81       	ldd	r24, Y+1	; 0x01
    4636:	80 33       	cpi	r24, 0x30	; 48
    4638:	19 f0       	breq	.+6      	; 0x4640 <APP_ROOM5_Status+0x70>
    463a:	83 34       	cpi	r24, 0x43	; 67
    463c:	a1 f7       	brne	.-24     	; 0x4626 <APP_ROOM5_Status+0x56>
    463e:	04 c0       	rjmp	.+8      	; 0x4648 <APP_ROOM5_Status+0x78>
			{
			case '0' :
				Count = 0;
				Next = RSt16;
    4640:	85 e2       	ldi	r24, 0x25	; 37
    4642:	80 93 06 08 	sts	0x0806, r24
    4646:	56 c0       	rjmp	.+172    	; 0x46f4 <APP_ROOM5_Status+0x124>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    4648:	88 e1       	ldi	r24, 0x18	; 24
    464a:	80 93 06 08 	sts	0x0806, r24
    464e:	52 c0       	rjmp	.+164    	; 0x46f4 <APP_ROOM5_Status+0x124>
			}
		}
		break;

		case User_Remote :
			switch(Local_u8LedState)
    4650:	8a 81       	ldd	r24, Y+2	; 0x02
    4652:	88 23       	and	r24, r24
    4654:	19 f0       	breq	.+6      	; 0x465c <APP_ROOM5_Status+0x8c>
    4656:	81 30       	cpi	r24, 0x01	; 1
    4658:	71 f4       	brne	.+28     	; 0x4676 <APP_ROOM5_Status+0xa6>
    465a:	07 c0       	rjmp	.+14     	; 0x466a <APP_ROOM5_Status+0x9a>
			{
			case LedOff :
				transmitDataBlockOverBluetooth("[1] ROOM5 OFF\n",14);
    465c:	8a e4       	ldi	r24, 0x4A	; 74
    465e:	94 e0       	ldi	r25, 0x04	; 4
    4660:	6e e0       	ldi	r22, 0x0E	; 14
    4662:	70 e0       	ldi	r23, 0x00	; 0
    4664:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    4668:	06 c0       	rjmp	.+12     	; 0x4676 <APP_ROOM5_Status+0xa6>
				break;
			case LedOn :
				transmitDataBlockOverBluetooth("[2] ROOM5 ON\n",15);
    466a:	89 e5       	ldi	r24, 0x59	; 89
    466c:	94 e0       	ldi	r25, 0x04	; 4
    466e:	6f e0       	ldi	r22, 0x0F	; 15
    4670:	70 e0       	ldi	r23, 0x00	; 0
    4672:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				break;
			}

			while(Count){
					APP_SystemState();
    4676:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
					APP_TEMP_MOTOR();
    467a:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
					Read = UART_ReceiveCharfrist();
    467e:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    4682:	89 83       	std	Y+1, r24	; 0x01
				switch(Read)
    4684:	89 81       	ldd	r24, Y+1	; 0x01
    4686:	80 33       	cpi	r24, 0x30	; 48
    4688:	19 f0       	breq	.+6      	; 0x4690 <APP_ROOM5_Status+0xc0>
    468a:	83 34       	cpi	r24, 0x43	; 67
    468c:	a1 f7       	brne	.-24     	; 0x4676 <APP_ROOM5_Status+0xa6>
    468e:	04 c0       	rjmp	.+8      	; 0x4698 <APP_ROOM5_Status+0xc8>
				{
				case '0' :
					Count = 0;
					Next = RSt23;
    4690:	8c e2       	ldi	r24, 0x2C	; 44
    4692:	80 93 06 08 	sts	0x0806, r24
    4696:	2e c0       	rjmp	.+92     	; 0x46f4 <APP_ROOM5_Status+0x124>
					break;
				case 'C' :
					Count = 0;
					Next = RSt4;
    4698:	89 e1       	ldi	r24, 0x19	; 25
    469a:	80 93 06 08 	sts	0x0806, r24
    469e:	2a c0       	rjmp	.+84     	; 0x46f4 <APP_ROOM5_Status+0x124>
				}
			}
			break;
			case User_Keypad :

				switch(Local_u8LedState)
    46a0:	8a 81       	ldd	r24, Y+2	; 0x02
    46a2:	88 23       	and	r24, r24
    46a4:	19 f0       	breq	.+6      	; 0x46ac <APP_ROOM5_Status+0xdc>
    46a6:	81 30       	cpi	r24, 0x01	; 1
    46a8:	91 f4       	brne	.+36     	; 0x46ce <APP_ROOM5_Status+0xfe>
    46aa:	09 c0       	rjmp	.+18     	; 0x46be <APP_ROOM5_Status+0xee>
				{
				case LedOff :
					CLCD_voidGoto(1,1);
    46ac:	81 e0       	ldi	r24, 0x01	; 1
    46ae:	61 e0       	ldi	r22, 0x01	; 1
    46b0:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("ROOM5 IS OFF");
    46b4:	87 e6       	ldi	r24, 0x67	; 103
    46b6:	94 e0       	ldi	r25, 0x04	; 4
    46b8:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    46bc:	08 c0       	rjmp	.+16     	; 0x46ce <APP_ROOM5_Status+0xfe>
					break;
				case LedOn :
					CLCD_voidGoto(1,1);
    46be:	81 e0       	ldi	r24, 0x01	; 1
    46c0:	61 e0       	ldi	r22, 0x01	; 1
    46c2:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
					CLCD_voidWriteString("ROOM5 IS ON");
    46c6:	84 e7       	ldi	r24, 0x74	; 116
    46c8:	94 e0       	ldi	r25, 0x04	; 4
    46ca:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
					break;
				}

				switch(Local_u8Key)
    46ce:	80 91 fb 07 	lds	r24, 0x07FB
    46d2:	83 34       	cpi	r24, 0x43	; 67
    46d4:	49 f0       	breq	.+18     	; 0x46e8 <APP_ROOM5_Status+0x118>
    46d6:	82 35       	cpi	r24, 0x52	; 82
    46d8:	69 f4       	brne	.+26     	; 0x46f4 <APP_ROOM5_Status+0x124>
				{
				case 'R' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    46da:	81 e0       	ldi	r24, 0x01	; 1
    46dc:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt4;
    46e0:	84 e0       	ldi	r24, 0x04	; 4
    46e2:	80 93 06 08 	sts	0x0806, r24
    46e6:	06 c0       	rjmp	.+12     	; 0x46f4 <APP_ROOM5_Status+0x124>
					break;

				case 'C' :
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    46e8:	81 e0       	ldi	r24, 0x01	; 1
    46ea:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					Next = ESt1;
    46ee:	81 e0       	ldi	r24, 0x01	; 1
    46f0:	80 93 06 08 	sts	0x0806, r24
					break;
				}
	}
	return Next;
}
    46f4:	80 91 06 08 	lds	r24, 0x0806
    46f8:	0f 90       	pop	r0
    46fa:	0f 90       	pop	r0
    46fc:	cf 91       	pop	r28
    46fe:	df 91       	pop	r29
    4700:	1f 91       	pop	r17
    4702:	08 95       	ret

00004704 <APP_ADC_CONTROL_DIMMER>:
		writeDataToEEPROM(0x200,0XFF);//write false at blocked location in EEPROM
		CLCD_voidSendCommand(0x01);
	}
	BUZZER_voidToggle();
}
void APP_ADC_CONTROL_DIMMER(void){
    4704:	af 92       	push	r10
    4706:	bf 92       	push	r11
    4708:	cf 92       	push	r12
    470a:	df 92       	push	r13
    470c:	ef 92       	push	r14
    470e:	ff 92       	push	r15
    4710:	0f 93       	push	r16
    4712:	1f 93       	push	r17
    4714:	cf 93       	push	r28
    4716:	df 93       	push	r29
	uint32_t reads_digital_value=0;

	//start convertion
	ADCSRA|=(1<<ADSC);
    4718:	e6 e2       	ldi	r30, 0x26	; 38
    471a:	f0 e0       	ldi	r31, 0x00	; 0
    471c:	80 81       	ld	r24, Z
    471e:	80 64       	ori	r24, 0x40	; 64
    4720:	80 83       	st	Z, r24
	while(( (ADCSRA & (1<<ADSC))) ==1); //WAIT CNVERTION
    4722:	e0 81       	ld	r30, Z
	reads_digital_value=(uint32_t)((((uint32_t)ADC_u16ReadValue(CH_A2)<<8))+(ADCL));
    4724:	82 e0       	ldi	r24, 0x02	; 2
    4726:	0e 94 fc 0c 	call	0x19f8	; 0x19f8 <ADC_u16ReadValue>
    472a:	24 b1       	in	r18, 0x04	; 4
    472c:	98 2f       	mov	r25, r24
    472e:	87 2f       	mov	r24, r23
    4730:	76 2f       	mov	r23, r22
    4732:	66 27       	eor	r22, r22
    4734:	7b 01       	movw	r14, r22
    4736:	8c 01       	movw	r16, r24
    4738:	e2 0e       	add	r14, r18
    473a:	f1 1c       	adc	r15, r1
    473c:	01 1d       	adc	r16, r1
    473e:	11 1d       	adc	r17, r1
	TIMER1_voidSetTCNT1(0);
    4740:	80 e0       	ldi	r24, 0x00	; 0
    4742:	90 e0       	ldi	r25, 0x00	; 0
    4744:	0e 94 25 09 	call	0x124a	; 0x124a <TIMER1_voidSetTCNT1>
	for(uint16_t i=0;i<reads_digital_value;i++){
    4748:	e1 14       	cp	r14, r1
    474a:	f1 04       	cpc	r15, r1
    474c:	01 05       	cpc	r16, r1
    474e:	11 05       	cpc	r17, r1
    4750:	01 f1       	breq	.+64     	; 0x4792 <APP_ADC_CONTROL_DIMMER+0x8e>
    4752:	c0 e0       	ldi	r28, 0x00	; 0
    4754:	d0 e0       	ldi	r29, 0x00	; 0
		if((GET_BIT(ADCSRA, ADIF))==0){
    4756:	0f 2e       	mov	r0, r31
    4758:	f6 e2       	ldi	r31, 0x26	; 38
    475a:	cf 2e       	mov	r12, r31
    475c:	dd 24       	eor	r13, r13
    475e:	f0 2d       	mov	r31, r0
    4760:	0f 2e       	mov	r0, r31
    4762:	f0 ea       	ldi	r31, 0xA0	; 160
    4764:	af 2e       	mov	r10, r31
    4766:	ff e0       	ldi	r31, 0x0F	; 15
    4768:	bf 2e       	mov	r11, r31
    476a:	f0 2d       	mov	r31, r0
    476c:	f6 01       	movw	r30, r12
    476e:	80 81       	ld	r24, Z
    4770:	84 fd       	sbrc	r24, 4
    4772:	06 c0       	rjmp	.+12     	; 0x4780 <APP_ADC_CONTROL_DIMMER+0x7c>
			TIMER1_voidSetOCR1B(i);
    4774:	ce 01       	movw	r24, r28
    4776:	0e 94 1f 09 	call	0x123e	; 0x123e <TIMER1_voidSetOCR1B>
    477a:	c5 01       	movw	r24, r10
    477c:	01 97       	sbiw	r24, 0x01	; 1
    477e:	f1 f7       	brne	.-4      	; 0x477c <APP_ADC_CONTROL_DIMMER+0x78>
	//start convertion
	ADCSRA|=(1<<ADSC);
	while(( (ADCSRA & (1<<ADSC))) ==1); //WAIT CNVERTION
	reads_digital_value=(uint32_t)((((uint32_t)ADC_u16ReadValue(CH_A2)<<8))+(ADCL));
	TIMER1_voidSetTCNT1(0);
	for(uint16_t i=0;i<reads_digital_value;i++){
    4780:	21 96       	adiw	r28, 0x01	; 1
    4782:	ce 01       	movw	r24, r28
    4784:	a0 e0       	ldi	r26, 0x00	; 0
    4786:	b0 e0       	ldi	r27, 0x00	; 0
    4788:	8e 15       	cp	r24, r14
    478a:	9f 05       	cpc	r25, r15
    478c:	a0 07       	cpc	r26, r16
    478e:	b1 07       	cpc	r27, r17
    4790:	68 f3       	brcs	.-38     	; 0x476c <APP_ADC_CONTROL_DIMMER+0x68>
    4792:	20 e2       	ldi	r18, 0x20	; 32
    4794:	3e e4       	ldi	r19, 0x4E	; 78
    4796:	48 ec       	ldi	r20, 0xC8	; 200
    4798:	50 e0       	ldi	r21, 0x00	; 0
    479a:	ca 01       	movw	r24, r20
    479c:	01 97       	sbiw	r24, 0x01	; 1
    479e:	f1 f7       	brne	.-4      	; 0x479c <APP_ADC_CONTROL_DIMMER+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    47a0:	21 50       	subi	r18, 0x01	; 1
    47a2:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    47a4:	d1 f7       	brne	.-12     	; 0x479a <APP_ADC_CONTROL_DIMMER+0x96>
			_delay_ms(2);
		}
	}
	_delay_ms(2000);

}
    47a6:	df 91       	pop	r29
    47a8:	cf 91       	pop	r28
    47aa:	1f 91       	pop	r17
    47ac:	0f 91       	pop	r16
    47ae:	ff 90       	pop	r15
    47b0:	ef 90       	pop	r14
    47b2:	df 90       	pop	r13
    47b4:	cf 90       	pop	r12
    47b6:	bf 90       	pop	r11
    47b8:	af 90       	pop	r10
    47ba:	08 95       	ret

000047bc <APP_DimmerControl>:
		break;
	}
	return Next;
}

static state APP_DimmerControl(Login_t Copy_LoginType){
    47bc:	df 93       	push	r29
    47be:	cf 93       	push	r28
    47c0:	0f 92       	push	r0
    47c2:	cd b7       	in	r28, 0x3d	; 61
    47c4:	de b7       	in	r29, 0x3e	; 62
	volatile uint_8 Read = 0;
    47c6:	19 82       	std	Y+1, r1	; 0x01
	uint_8 Count = 1;

	switch(Copy_LoginType)
    47c8:	81 30       	cpi	r24, 0x01	; 1
    47ca:	e1 f1       	breq	.+120    	; 0x4844 <APP_DimmerControl+0x88>
    47cc:	81 30       	cpi	r24, 0x01	; 1
    47ce:	08 f4       	brcc	.+2      	; 0x47d2 <APP_DimmerControl+0x16>
    47d0:	6f c0       	rjmp	.+222    	; 0x48b0 <APP_DimmerControl+0xf4>
    47d2:	82 30       	cpi	r24, 0x02	; 2
    47d4:	09 f0       	breq	.+2      	; 0x47d8 <APP_DimmerControl+0x1c>
    47d6:	a5 c0       	rjmp	.+330    	; 0x4922 <APP_DimmerControl+0x166>
	{
	case Admin :
		transmitDataBlockOverBluetooth("[1] DIMMER ON\n",15);
    47d8:	80 e8       	ldi	r24, 0x80	; 128
    47da:	94 e0       	ldi	r25, 0x04	; 4
    47dc:	6f e0       	ldi	r22, 0x0F	; 15
    47de:	70 e0       	ldi	r23, 0x00	; 0
    47e0:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] DIMMER OFF\n",16);
    47e4:	8f e8       	ldi	r24, 0x8F	; 143
    47e6:	94 e0       	ldi	r25, 0x04	; 4
    47e8:	60 e1       	ldi	r22, 0x10	; 16
    47ea:	70 e0       	ldi	r23, 0x00	; 0
    47ec:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    47f0:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    47f4:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    47f8:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    47fc:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    47fe:	89 81       	ldd	r24, Y+1	; 0x01
    4800:	81 33       	cpi	r24, 0x31	; 49
    4802:	51 f0       	breq	.+20     	; 0x4818 <APP_DimmerControl+0x5c>
    4804:	82 33       	cpi	r24, 0x32	; 50
    4806:	18 f4       	brcc	.+6      	; 0x480e <APP_DimmerControl+0x52>
    4808:	80 33       	cpi	r24, 0x30	; 48
    480a:	91 f7       	brne	.-28     	; 0x47f0 <APP_DimmerControl+0x34>
    480c:	13 c0       	rjmp	.+38     	; 0x4834 <APP_DimmerControl+0x78>
    480e:	82 33       	cpi	r24, 0x32	; 50
    4810:	49 f0       	breq	.+18     	; 0x4824 <APP_DimmerControl+0x68>
    4812:	83 34       	cpi	r24, 0x43	; 67
    4814:	69 f7       	brne	.-38     	; 0x47f0 <APP_DimmerControl+0x34>
    4816:	12 c0       	rjmp	.+36     	; 0x483c <APP_DimmerControl+0x80>
			{
			case '1' :
				APP_ADC_CONTROL_DIMMER();
    4818:	0e 94 82 23 	call	0x4704	; 0x4704 <APP_ADC_CONTROL_DIMMER>
				Count = 0;
				Next = RSt13;
    481c:	82 e2       	ldi	r24, 0x22	; 34
    481e:	80 93 06 08 	sts	0x0806, r24
    4822:	7f c0       	rjmp	.+254    	; 0x4922 <APP_DimmerControl+0x166>
				break;
			case '2' :
				TIMER1_voidSetOCR1B(0);
    4824:	80 e0       	ldi	r24, 0x00	; 0
    4826:	90 e0       	ldi	r25, 0x00	; 0
    4828:	0e 94 1f 09 	call	0x123e	; 0x123e <TIMER1_voidSetOCR1B>
				Count = 0;
				Next = RSt13;
    482c:	82 e2       	ldi	r24, 0x22	; 34
    482e:	80 93 06 08 	sts	0x0806, r24
    4832:	77 c0       	rjmp	.+238    	; 0x4922 <APP_DimmerControl+0x166>
				break;
			case '0' :
				Count = 0;
				Next = RSt5;
    4834:	8a e1       	ldi	r24, 0x1A	; 26
    4836:	80 93 06 08 	sts	0x0806, r24
    483a:	73 c0       	rjmp	.+230    	; 0x4922 <APP_DimmerControl+0x166>
				break;
			case 'C' :
				Count = 0;
				Next = RSt3;
    483c:	88 e1       	ldi	r24, 0x18	; 24
    483e:	80 93 06 08 	sts	0x0806, r24
    4842:	6f c0       	rjmp	.+222    	; 0x4922 <APP_DimmerControl+0x166>
			}
		}
		break;

	case User_Remote :
		transmitDataBlockOverBluetooth("[1] DIMMER ON\n",15);
    4844:	80 e8       	ldi	r24, 0x80	; 128
    4846:	94 e0       	ldi	r25, 0x04	; 4
    4848:	6f e0       	ldi	r22, 0x0F	; 15
    484a:	70 e0       	ldi	r23, 0x00	; 0
    484c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("[2] DIMMER OFF\n",16);
    4850:	8f e8       	ldi	r24, 0x8F	; 143
    4852:	94 e0       	ldi	r25, 0x04	; 4
    4854:	60 e1       	ldi	r22, 0x10	; 16
    4856:	70 e0       	ldi	r23, 0x00	; 0
    4858:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>

		while(Count){
				APP_SystemState();
    485c:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
				APP_TEMP_MOTOR();
    4860:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
				Read = UART_ReceiveCharfrist();
    4864:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    4868:	89 83       	std	Y+1, r24	; 0x01
			switch(Read)
    486a:	89 81       	ldd	r24, Y+1	; 0x01
    486c:	81 33       	cpi	r24, 0x31	; 49
    486e:	51 f0       	breq	.+20     	; 0x4884 <APP_DimmerControl+0xc8>
    4870:	82 33       	cpi	r24, 0x32	; 50
    4872:	18 f4       	brcc	.+6      	; 0x487a <APP_DimmerControl+0xbe>
    4874:	80 33       	cpi	r24, 0x30	; 48
    4876:	91 f7       	brne	.-28     	; 0x485c <APP_DimmerControl+0xa0>
    4878:	13 c0       	rjmp	.+38     	; 0x48a0 <APP_DimmerControl+0xe4>
    487a:	82 33       	cpi	r24, 0x32	; 50
    487c:	49 f0       	breq	.+18     	; 0x4890 <APP_DimmerControl+0xd4>
    487e:	83 34       	cpi	r24, 0x43	; 67
    4880:	69 f7       	brne	.-38     	; 0x485c <APP_DimmerControl+0xa0>
    4882:	12 c0       	rjmp	.+36     	; 0x48a8 <APP_DimmerControl+0xec>
			{
			case '1' :
				APP_ADC_CONTROL_DIMMER();
    4884:	0e 94 82 23 	call	0x4704	; 0x4704 <APP_ADC_CONTROL_DIMMER>
				Count = 0;
				Next = RSt21;
    4888:	8a e2       	ldi	r24, 0x2A	; 42
    488a:	80 93 06 08 	sts	0x0806, r24
    488e:	49 c0       	rjmp	.+146    	; 0x4922 <APP_DimmerControl+0x166>
				break;
			case '2' :
				TIMER1_voidSetOCR1B(0);
    4890:	80 e0       	ldi	r24, 0x00	; 0
    4892:	90 e0       	ldi	r25, 0x00	; 0
    4894:	0e 94 1f 09 	call	0x123e	; 0x123e <TIMER1_voidSetOCR1B>
				Count = 0;
				Next = RSt21;
    4898:	8a e2       	ldi	r24, 0x2A	; 42
    489a:	80 93 06 08 	sts	0x0806, r24
    489e:	41 c0       	rjmp	.+130    	; 0x4922 <APP_DimmerControl+0x166>
				break;
			case '0' :
				Count = 0;
				Next = RSt10;
    48a0:	8f e1       	ldi	r24, 0x1F	; 31
    48a2:	80 93 06 08 	sts	0x0806, r24
    48a6:	3d c0       	rjmp	.+122    	; 0x4922 <APP_DimmerControl+0x166>
				break;
			case 'C' :
				Count = 0;
				Next = RSt4;
    48a8:	89 e1       	ldi	r24, 0x19	; 25
    48aa:	80 93 06 08 	sts	0x0806, r24
    48ae:	39 c0       	rjmp	.+114    	; 0x4922 <APP_DimmerControl+0x166>
			}
		}
		break;
	case User_Keypad :

		CLCD_voidGoto(1,1);
    48b0:	81 e0       	ldi	r24, 0x01	; 1
    48b2:	61 e0       	ldi	r22, 0x01	; 1
    48b4:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[1] DIMMER ON");
    48b8:	8f e9       	ldi	r24, 0x9F	; 159
    48ba:	94 e0       	ldi	r25, 0x04	; 4
    48bc:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    48c0:	82 e0       	ldi	r24, 0x02	; 2
    48c2:	61 e0       	ldi	r22, 0x01	; 1
    48c4:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("[2] DIMMER OFF");
    48c8:	8d ea       	ldi	r24, 0xAD	; 173
    48ca:	94 e0       	ldi	r25, 0x04	; 4
    48cc:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>

		switch(Local_u8Key)
    48d0:	80 91 fb 07 	lds	r24, 0x07FB
    48d4:	82 33       	cpi	r24, 0x32	; 50
    48d6:	81 f0       	breq	.+32     	; 0x48f8 <APP_DimmerControl+0x13c>
    48d8:	83 33       	cpi	r24, 0x33	; 51
    48da:	18 f4       	brcc	.+6      	; 0x48e2 <APP_DimmerControl+0x126>
    48dc:	81 33       	cpi	r24, 0x31	; 49
    48de:	09 f5       	brne	.+66     	; 0x4922 <APP_DimmerControl+0x166>
    48e0:	05 c0       	rjmp	.+10     	; 0x48ec <APP_DimmerControl+0x130>
    48e2:	83 34       	cpi	r24, 0x43	; 67
    48e4:	c1 f0       	breq	.+48     	; 0x4916 <APP_DimmerControl+0x15a>
    48e6:	82 35       	cpi	r24, 0x52	; 82
    48e8:	e1 f4       	brne	.+56     	; 0x4922 <APP_DimmerControl+0x166>
    48ea:	0e c0       	rjmp	.+28     	; 0x4908 <APP_DimmerControl+0x14c>
		{
		case '1' :
			APP_ADC_CONTROL_DIMMER();
    48ec:	0e 94 82 23 	call	0x4704	; 0x4704 <APP_ADC_CONTROL_DIMMER>
			Count = 0;
			Next = ESt9;
    48f0:	89 e0       	ldi	r24, 0x09	; 9
    48f2:	80 93 06 08 	sts	0x0806, r24
    48f6:	15 c0       	rjmp	.+42     	; 0x4922 <APP_DimmerControl+0x166>
			break;
		case '2' :
			TIMER1_voidSetOCR1B(0);
    48f8:	80 e0       	ldi	r24, 0x00	; 0
    48fa:	90 e0       	ldi	r25, 0x00	; 0
    48fc:	0e 94 1f 09 	call	0x123e	; 0x123e <TIMER1_voidSetOCR1B>
			Count = 0;
			Next = ESt9;
    4900:	89 e0       	ldi	r24, 0x09	; 9
    4902:	80 93 06 08 	sts	0x0806, r24
    4906:	0d c0       	rjmp	.+26     	; 0x4922 <APP_DimmerControl+0x166>
			break;
		case 'R' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    4908:	81 e0       	ldi	r24, 0x01	; 1
    490a:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt3;
    490e:	83 e0       	ldi	r24, 0x03	; 3
    4910:	80 93 06 08 	sts	0x0806, r24
    4914:	06 c0       	rjmp	.+12     	; 0x4922 <APP_DimmerControl+0x166>
			break;

		case 'C' :
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    4916:	81 e0       	ldi	r24, 0x01	; 1
    4918:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			Next = ESt1;
    491c:	81 e0       	ldi	r24, 0x01	; 1
    491e:	80 93 06 08 	sts	0x0806, r24
			break;
		}
	}
	return Next;
}
    4922:	80 91 06 08 	lds	r24, 0x0806
    4926:	0f 90       	pop	r0
    4928:	cf 91       	pop	r28
    492a:	df 91       	pop	r29
    492c:	08 95       	ret

0000492e <APP_voidFirstRun>:
	}
	CLCD_voidSendCommand(0X01);
}
/********************************************************************************** DONE**/
void APP_voidFirstRun(void)
{
    492e:	cf 93       	push	r28
    4930:	df 93       	push	r29
	Std_Return Local_u8Ret = 0;
	uint_8 read = 0;
	read = readDataFromEEPROM(0x99);
    4932:	89 e9       	ldi	r24, 0x99	; 153
    4934:	90 e0       	ldi	r25, 0x00	; 0
    4936:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>

	if(read == 0XFF)
    493a:	8f 3f       	cpi	r24, 0xFF	; 255
    493c:	09 f0       	breq	.+2      	; 0x4940 <APP_voidFirstRun+0x12>
    493e:	4f c0       	rjmp	.+158    	; 0x49de <APP_voidFirstRun+0xb0>
	{
		CLCD_voidGoto(2,1);
    4940:	82 e0       	ldi	r24, 0x02	; 2
    4942:	61 e0       	ldi	r22, 0x01	; 1
    4944:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("FIRST LOGIN.....");
    4948:	8c eb       	ldi	r24, 0xBC	; 188
    494a:	94 e0       	ldi	r25, 0x04	; 4
    494c:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(4,14);
    4950:	84 e0       	ldi	r24, 0x04	; 4
    4952:	6e e0       	ldi	r22, 0x0E	; 14
    4954:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("NTI");
    4958:	8d ec       	ldi	r24, 0xCD	; 205
    495a:	94 e0       	ldi	r25, 0x04	; 4
    495c:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>

		transmitDataBlockOverBluetooth("FIRST LOGIN", 11);
    4960:	81 ed       	ldi	r24, 0xD1	; 209
    4962:	94 e0       	ldi	r25, 0x04	; 4
    4964:	6b e0       	ldi	r22, 0x0B	; 11
    4966:	70 e0       	ldi	r23, 0x00	; 0
    4968:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth("SET ADMIN NAME",14);
    496c:	8d ed       	ldi	r24, 0xDD	; 221
    496e:	94 e0       	ldi	r25, 0x04	; 4
    4970:	6e e0       	ldi	r22, 0x0E	; 14
    4972:	70 e0       	ldi	r23, 0x00	; 0
    4974:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		transmitDataBlockOverBluetooth(" AND PASSWORD : \n",18);
    4978:	8c ee       	ldi	r24, 0xEC	; 236
    497a:	94 e0       	ldi	r25, 0x04	; 4
    497c:	62 e1       	ldi	r22, 0x12	; 18
    497e:	70 e0       	ldi	r23, 0x00	; 0
    4980:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
{
	Std_Return ret = R_NOT_OK;
	uint8_t Local_u8password = 0, Local_u8Ke = 0 ;
	uint16_t number = 0;

	transmitDataBlockOverBluetooth("Admin : \n",10);
    4984:	8e ef       	ldi	r24, 0xFE	; 254
    4986:	94 e0       	ldi	r25, 0x04	; 4
    4988:	6a e0       	ldi	r22, 0x0A	; 10
    498a:	70 e0       	ldi	r23, 0x00	; 0
    498c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
	while(Local_u8password < 1)
	{
		Local_u8Ke = UART_ReceiveChar();
    4990:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
		if(Local_u8Ke >= '0' && Local_u8Ke <= '9')
    4994:	68 2f       	mov	r22, r24
    4996:	60 53       	subi	r22, 0x30	; 48
    4998:	6a 30       	cpi	r22, 0x0A	; 10
    499a:	d0 f7       	brcc	.-12     	; 0x4990 <APP_voidFirstRun+0x62>
		{
			eeprom_write_byte((uint_8*)(EEPROM_ADDR_F_Admin ), Local_u8Ke - '0');
    499c:	82 e3       	ldi	r24, 0x32	; 50
    499e:	90 e0       	ldi	r25, 0x00	; 0
    49a0:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
			Local_u8password++;
		}
	}
	Local_u8Ke = 0;
	Local_u8password = 0;
	transmitDataBlockOverBluetooth("Pass : \n",9);
    49a4:	88 e0       	ldi	r24, 0x08	; 8
    49a6:	95 e0       	ldi	r25, 0x05	; 5
    49a8:	69 e0       	ldi	r22, 0x09	; 9
    49aa:	70 e0       	ldi	r23, 0x00	; 0
    49ac:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    49b0:	c3 e3       	ldi	r28, 0x33	; 51
    49b2:	d0 e0       	ldi	r29, 0x00	; 0
	while (Local_u8password < 4)
	{
		Local_u8Ke = UART_ReceiveChar();
    49b4:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
		if(Local_u8Ke >= '0' && Local_u8Ke <= '9')
    49b8:	68 2f       	mov	r22, r24
    49ba:	60 53       	subi	r22, 0x30	; 48
    49bc:	6a 30       	cpi	r22, 0x0A	; 10
    49be:	d0 f7       	brcc	.-12     	; 0x49b4 <APP_voidFirstRun+0x86>
		{
			number = number * 10 + (Local_u8Ke-'0');

			Local_u8password++;

			eeprom_write_byte((uint_8*)(EEPROM_ADDR_F_Admin + Local_u8password), Local_u8Ke - '0');
    49c0:	ce 01       	movw	r24, r28
    49c2:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
    49c6:	21 96       	adiw	r28, 0x01	; 1
		}
	}
	Local_u8Ke = 0;
	Local_u8password = 0;
	transmitDataBlockOverBluetooth("Pass : \n",9);
	while (Local_u8password < 4)
    49c8:	c7 33       	cpi	r28, 0x37	; 55
    49ca:	d1 05       	cpc	r29, r1
    49cc:	99 f7       	brne	.-26     	; 0x49b4 <APP_voidFirstRun+0x86>
		transmitDataBlockOverBluetooth("FIRST LOGIN", 11);
		transmitDataBlockOverBluetooth("SET ADMIN NAME",14);
		transmitDataBlockOverBluetooth(" AND PASSWORD : \n",18);
		Local_u8Ret = APP_SetAdmin_and_Pass_First();
		if(R_OK == Local_u8Ret){
				writeDataToEEPROM(0x99,0XAA);
    49ce:	89 e9       	ldi	r24, 0x99	; 153
    49d0:	90 e0       	ldi	r25, 0x00	; 0
    49d2:	6a ea       	ldi	r22, 0xAA	; 170
    49d4:	0e 94 ce 0c 	call	0x199c	; 0x199c <writeDataToEEPROM>
		}
		Next = RSt3;
    49d8:	88 e1       	ldi	r24, 0x18	; 24
    49da:	80 93 06 08 	sts	0x0806, r24
	}

	CLCD_voidSendCommand(0X01);
    49de:	81 e0       	ldi	r24, 0x01	; 1
    49e0:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>

}
    49e4:	df 91       	pop	r29
    49e6:	cf 91       	pop	r28
    49e8:	08 95       	ret

000049ea <APP_BlockingMode>:

void APP_BlockingMode(void)
{
	writeDataToEEPROM(0x200,0);//write false at blocked location in EEPROM
    49ea:	80 e0       	ldi	r24, 0x00	; 0
    49ec:	92 e0       	ldi	r25, 0x02	; 2
    49ee:	60 e0       	ldi	r22, 0x00	; 0
    49f0:	0e 94 ce 0c 	call	0x199c	; 0x199c <writeDataToEEPROM>
	BUZZER_voidToggle();
    49f4:	0e 94 cb 12 	call	0x2596	; 0x2596 <BUZZER_voidToggle>
	if(0 == readDataFromEEPROM(0x200))//if the login process was blocked wait till the end of the block period
    49f8:	80 e0       	ldi	r24, 0x00	; 0
    49fa:	92 e0       	ldi	r25, 0x02	; 2
    49fc:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    4a00:	88 23       	and	r24, r24
    4a02:	09 f5       	brne	.+66     	; 0x4a46 <APP_BlockingMode+0x5c>
	{
		CLCD_voidSendCommand(0x01);//remove all previously printed characters on the LCD and move the cursor to the first column of the first row
    4a04:	81 e0       	ldi	r24, 0x01	; 1
    4a06:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
		CLCD_voidWriteString("Login blocked");
    4a0a:	81 e1       	ldi	r24, 0x11	; 17
    4a0c:	95 e0       	ldi	r25, 0x05	; 5
    4a0e:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
		CLCD_voidGoto(2,1);
    4a12:	82 e0       	ldi	r24, 0x02	; 2
    4a14:	61 e0       	ldi	r22, 0x01	; 1
    4a16:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
		CLCD_voidWriteString("wait 20 seconds");
    4a1a:	8f e1       	ldi	r24, 0x1F	; 31
    4a1c:	95 e0       	ldi	r25, 0x05	; 5
    4a1e:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    4a22:	2f ef       	ldi	r18, 0xFF	; 255
    4a24:	3f ef       	ldi	r19, 0xFF	; 255
    4a26:	48 ec       	ldi	r20, 0xC8	; 200
    4a28:	50 e0       	ldi	r21, 0x00	; 0
    4a2a:	ca 01       	movw	r24, r20
    4a2c:	01 97       	sbiw	r24, 0x01	; 1
    4a2e:	f1 f7       	brne	.-4      	; 0x4a2c <APP_BlockingMode+0x42>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a30:	21 50       	subi	r18, 0x01	; 1
    4a32:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a34:	d1 f7       	brne	.-12     	; 0x4a2a <APP_BlockingMode+0x40>
		_delay_ms(20000);//Halt the system for the given time in (ms)

		writeDataToEEPROM(0x200,0XFF);//write false at blocked location in EEPROM
    4a36:	80 e0       	ldi	r24, 0x00	; 0
    4a38:	92 e0       	ldi	r25, 0x02	; 2
    4a3a:	6f ef       	ldi	r22, 0xFF	; 255
    4a3c:	0e 94 ce 0c 	call	0x199c	; 0x199c <writeDataToEEPROM>
		CLCD_voidSendCommand(0x01);
    4a40:	81 e0       	ldi	r24, 0x01	; 1
    4a42:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
	}
	BUZZER_voidToggle();
    4a46:	0e 94 cb 12 	call	0x2596	; 0x2596 <BUZZER_voidToggle>
}
    4a4a:	08 95       	ret

00004a4c <APP_LoginSystem>:

	return ret;
}
/*** Ahmed Ashraf___V1 ********************************************************  DONE**/
static state APP_LoginSystem(Login_t Copy_LoginType)
{
    4a4c:	2f 92       	push	r2
    4a4e:	3f 92       	push	r3
    4a50:	4f 92       	push	r4
    4a52:	5f 92       	push	r5
    4a54:	6f 92       	push	r6
    4a56:	7f 92       	push	r7
    4a58:	8f 92       	push	r8
    4a5a:	9f 92       	push	r9
    4a5c:	af 92       	push	r10
    4a5e:	bf 92       	push	r11
    4a60:	cf 92       	push	r12
    4a62:	df 92       	push	r13
    4a64:	ef 92       	push	r14
    4a66:	ff 92       	push	r15
    4a68:	0f 93       	push	r16
    4a6a:	1f 93       	push	r17
    4a6c:	df 93       	push	r29
    4a6e:	cf 93       	push	r28
    4a70:	00 d0       	rcall	.+0      	; 0x4a72 <APP_LoginSystem+0x26>
    4a72:	00 d0       	rcall	.+0      	; 0x4a74 <APP_LoginSystem+0x28>
    4a74:	0f 92       	push	r0
    4a76:	cd b7       	in	r28, 0x3d	; 61
    4a78:	de b7       	in	r29, 0x3e	; 62
    4a7a:	18 2f       	mov	r17, r24
	uint_8 Trial = 0;
	CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    4a7c:	81 e0       	ldi	r24, 0x01	; 1
    4a7e:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
	*LOCAL_u8N =0;
    4a82:	10 92 f1 07 	sts	0x07F1, r1
	switch (Copy_LoginType) {
    4a86:	11 30       	cpi	r17, 0x01	; 1
    4a88:	09 f4       	brne	.+2      	; 0x4a8c <APP_LoginSystem+0x40>
    4a8a:	f0 c0       	rjmp	.+480    	; 0x4c6c <APP_LoginSystem+0x220>
    4a8c:	11 30       	cpi	r17, 0x01	; 1
    4a8e:	20 f0       	brcs	.+8      	; 0x4a98 <APP_LoginSystem+0x4c>
    4a90:	12 30       	cpi	r17, 0x02	; 2
    4a92:	09 f0       	breq	.+2      	; 0x4a96 <APP_LoginSystem+0x4a>
    4a94:	35 c2       	rjmp	.+1130   	; 0x4f00 <APP_LoginSystem+0x4b4>
    4a96:	9d c1       	rjmp	.+826    	; 0x4dd2 <APP_LoginSystem+0x386>
{
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8Name = 0;
	uint_8 LOCAL_u8Counter2 = 11;
	uint_8 X = '+';
	CLCD_voidGoto(1,1);
    4a98:	81 e0       	ldi	r24, 0x01	; 1
    4a9a:	61 e0       	ldi	r22, 0x01	; 1
    4a9c:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
	CLCD_voidWriteString("UserName: ");
    4aa0:	8f e2       	ldi	r24, 0x2F	; 47
    4aa2:	95 e0       	ldi	r25, 0x05	; 5
    4aa4:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    4aa8:	0b e0       	ldi	r16, 0x0B	; 11
    4aaa:	cc 24       	eor	r12, r12
    4aac:	dd 24       	eor	r13, r13
    4aae:	76 01       	movw	r14, r12
	while((LOCAL_u8Counter2 < 12)&& (X  !='K')){
		X = Keypad_u8GetPressed(Keypad_Array);
    4ab0:	0f 2e       	mov	r0, r31
    4ab2:	f9 eb       	ldi	r31, 0xB9	; 185
    4ab4:	af 2e       	mov	r10, r31
    4ab6:	f7 e0       	ldi	r31, 0x07	; 7
    4ab8:	bf 2e       	mov	r11, r31
    4aba:	f0 2d       	mov	r31, r0
    4abc:	c5 01       	movw	r24, r10
    4abe:	0e 94 b3 10 	call	0x2166	; 0x2166 <Keypad_u8GetPressed>
    4ac2:	18 2f       	mov	r17, r24
		if(X != '+'){
    4ac4:	8b 32       	cpi	r24, 0x2B	; 43
    4ac6:	81 f0       	breq	.+32     	; 0x4ae8 <APP_LoginSystem+0x9c>
			if((X >= '0') &&(X <= '9')){
    4ac8:	80 53       	subi	r24, 0x30	; 48
    4aca:	8a 30       	cpi	r24, 0x0A	; 10
    4acc:	68 f4       	brcc	.+26     	; 0x4ae8 <APP_LoginSystem+0x9c>
				CLCD_voidWriteNumbers(X-'0');
    4ace:	81 2f       	mov	r24, r17
    4ad0:	90 e0       	ldi	r25, 0x00	; 0
    4ad2:	c0 97       	sbiw	r24, 0x30	; 48
    4ad4:	6c 01       	movw	r12, r24
    4ad6:	ee 24       	eor	r14, r14
    4ad8:	d7 fc       	sbrc	r13, 7
    4ada:	e0 94       	com	r14
    4adc:	fe 2c       	mov	r15, r14
    4ade:	c7 01       	movw	r24, r14
    4ae0:	b6 01       	movw	r22, r12
    4ae2:	0e 94 1c 11 	call	0x2238	; 0x2238 <CLCD_voidWriteNumbers>
				LOCAL_u8Name = X-'0';
				LOCAL_u8Counter2++;
    4ae6:	0f 5f       	subi	r16, 0xFF	; 255
	uint_32 LOCAL_u8Name = 0;
	uint_8 LOCAL_u8Counter2 = 11;
	uint_8 X = '+';
	CLCD_voidGoto(1,1);
	CLCD_voidWriteString("UserName: ");
	while((LOCAL_u8Counter2 < 12)&& (X  !='K')){
    4ae8:	0c 30       	cpi	r16, 0x0C	; 12
    4aea:	08 f0       	brcs	.+2      	; 0x4aee <APP_LoginSystem+0xa2>
    4aec:	74 c2       	rjmp	.+1256   	; 0x4fd6 <APP_LoginSystem+0x58a>
    4aee:	1b 34       	cpi	r17, 0x4B	; 75
    4af0:	29 f7       	brne	.-54     	; 0x4abc <APP_LoginSystem+0x70>
    4af2:	71 c2       	rjmp	.+1250   	; 0x4fd6 <APP_LoginSystem+0x58a>
			}
		}
	}
	for(LOCAL_u8Counter2 = 0; LOCAL_u8Counter2 <= 20; LOCAL_u8Counter2 +=5)
	{
		(*LOCAL_u8N)++;
    4af4:	80 91 f1 07 	lds	r24, 0x07F1
    4af8:	8f 5f       	subi	r24, 0xFF	; 255
    4afa:	80 93 f1 07 	sts	0x07F1, r24
		if(LOCAL_u8Name == readDataFromEEPROM(LOCAL_u8Counter2 + EEPROM_ADDR_F_UsersKeypad))
    4afe:	c8 01       	movw	r24, r16
    4b00:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    4b04:	90 e0       	ldi	r25, 0x00	; 0
    4b06:	a0 e0       	ldi	r26, 0x00	; 0
    4b08:	b0 e0       	ldi	r27, 0x00	; 0
    4b0a:	8c 15       	cp	r24, r12
    4b0c:	9d 05       	cpc	r25, r13
    4b0e:	ae 05       	cpc	r26, r14
    4b10:	bf 05       	cpc	r27, r15
    4b12:	a1 f4       	brne	.+40     	; 0x4b3c <APP_LoginSystem+0xf0>
		{
			*Copy_add = LOCAL_u8Counter2 + EEPROM_ADDR_F_UsersKeypad;
    4b14:	00 93 f0 07 	sts	0x07F0, r16
    4b18:	33 24       	eor	r3, r3
{
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8pass = 0;
	uint_8 LOCAL_u8Counter1 = 0, LOCAL_u8TrueCounter = 0, LOCAL_u8Counter2 = 6;
	uint_8 X = '+';
	uint_8 Arr[4] ={0,0,0,0};
    4b1a:	22 24       	eor	r2, r2
    4b1c:	0f 2e       	mov	r0, r31
    4b1e:	f8 ec       	ldi	r31, 0xC8	; 200
    4b20:	cf 2e       	mov	r12, r31
    4b22:	dd 24       	eor	r13, r13
    4b24:	f0 2d       	mov	r31, r0
	{
		X = Keypad_u8GetPressed(Keypad_Array);
		if(X != '+'){
			if((X >= '0') &&(X <= '9')){
				LOCAL_u8pass = X-'0';
				Arr[LOCAL_u8Counter1] =LOCAL_u8pass;
    4b26:	3e 01       	movw	r6, r28
    4b28:	08 94       	sec
    4b2a:	61 1c       	adc	r6, r1
    4b2c:	71 1c       	adc	r7, r1
	uint_8 LOCAL_u8Counter1 = 0, LOCAL_u8TrueCounter = 0, LOCAL_u8Counter2 = 6;
	uint_8 X = '+';
	uint_8 Arr[4] ={0,0,0,0};
	while((LOCAL_u8Counter2 < 10)&& (X  !='K'))
	{
		X = Keypad_u8GetPressed(Keypad_Array);
    4b2e:	0f 2e       	mov	r0, r31
    4b30:	f9 eb       	ldi	r31, 0xB9	; 185
    4b32:	4f 2e       	mov	r4, r31
    4b34:	f7 e0       	ldi	r31, 0x07	; 7
    4b36:	5f 2e       	mov	r5, r31
    4b38:	f0 2d       	mov	r31, r0
    4b3a:	06 c0       	rjmp	.+12     	; 0x4b48 <APP_LoginSystem+0xfc>
	for(LOCAL_u8Counter2 = 0; LOCAL_u8Counter2 <= 20; LOCAL_u8Counter2 +=5)
	{
		(*LOCAL_u8N)++;
		if(LOCAL_u8Name == readDataFromEEPROM(LOCAL_u8Counter2 + EEPROM_ADDR_F_UsersKeypad))
		{
			*Copy_add = LOCAL_u8Counter2 + EEPROM_ADDR_F_UsersKeypad;
    4b3c:	0b 5f       	subi	r16, 0xFB	; 251
    4b3e:	1f 4f       	sbci	r17, 0xFF	; 255
				LOCAL_u8Name = X-'0';
				LOCAL_u8Counter2++;
			}
		}
	}
	for(LOCAL_u8Counter2 = 0; LOCAL_u8Counter2 <= 20; LOCAL_u8Counter2 +=5)
    4b40:	09 31       	cpi	r16, 0x19	; 25
    4b42:	11 05       	cpc	r17, r1
    4b44:	b9 f6       	brne	.-82     	; 0x4af4 <APP_LoginSystem+0xa8>
    4b46:	f6 c1       	rjmp	.+1004   	; 0x4f34 <APP_LoginSystem+0x4e8>
	case User_Keypad:
		if(Check_Usernamekeypad(LOCAL_u8NameAdd) == OK )
		{
			while(Trial < 3)
			{
				CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    4b48:	81 e0       	ldi	r24, 0x01	; 1
    4b4a:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
				CLCD_voidWriteString("UserName ");
    4b4e:	8a e3       	ldi	r24, 0x3A	; 58
    4b50:	95 e0       	ldi	r25, 0x05	; 5
    4b52:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
				CLCD_voidWriteNumbers((*LOCAL_u8N));
    4b56:	60 91 f1 07 	lds	r22, 0x07F1
    4b5a:	70 e0       	ldi	r23, 0x00	; 0
    4b5c:	80 e0       	ldi	r24, 0x00	; 0
    4b5e:	90 e0       	ldi	r25, 0x00	; 0
    4b60:	0e 94 1c 11 	call	0x2238	; 0x2238 <CLCD_voidWriteNumbers>
				CLCD_voidGoto(2,1);
    4b64:	82 e0       	ldi	r24, 0x02	; 2
    4b66:	61 e0       	ldi	r22, 0x01	; 1
    4b68:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
				CLCD_voidWriteString("Pass: ");
    4b6c:	84 e4       	ldi	r24, 0x44	; 68
    4b6e:	95 e0       	ldi	r25, 0x05	; 5
    4b70:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
{
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8pass = 0;
	uint_8 LOCAL_u8Counter1 = 0, LOCAL_u8TrueCounter = 0, LOCAL_u8Counter2 = 6;
	uint_8 X = '+';
	uint_8 Arr[4] ={0,0,0,0};
    4b74:	19 82       	std	Y+1, r1	; 0x01
    4b76:	1a 82       	std	Y+2, r1	; 0x02
    4b78:	1b 82       	std	Y+3, r1	; 0x03
    4b7a:	1c 82       	std	Y+4, r1	; 0x04
    4b7c:	f2 2c       	mov	r15, r2
    4b7e:	06 e0       	ldi	r16, 0x06	; 6
	while((LOCAL_u8Counter2 < 10)&& (X  !='K'))
	{
		X = Keypad_u8GetPressed(Keypad_Array);
    4b80:	c2 01       	movw	r24, r4
    4b82:	0e 94 b3 10 	call	0x2166	; 0x2166 <Keypad_u8GetPressed>
    4b86:	18 2f       	mov	r17, r24
		if(X != '+'){
    4b88:	8b 32       	cpi	r24, 0x2B	; 43
    4b8a:	21 f1       	breq	.+72     	; 0x4bd4 <APP_LoginSystem+0x188>
			if((X >= '0') &&(X <= '9')){
    4b8c:	80 53       	subi	r24, 0x30	; 48
    4b8e:	8a 30       	cpi	r24, 0x0A	; 10
    4b90:	08 f5       	brcc	.+66     	; 0x4bd4 <APP_LoginSystem+0x188>
				LOCAL_u8pass = X-'0';
    4b92:	81 2f       	mov	r24, r17
    4b94:	90 e0       	ldi	r25, 0x00	; 0
    4b96:	c0 97       	sbiw	r24, 0x30	; 48
    4b98:	4c 01       	movw	r8, r24
    4b9a:	aa 24       	eor	r10, r10
    4b9c:	97 fc       	sbrc	r9, 7
    4b9e:	a0 94       	com	r10
    4ba0:	ba 2c       	mov	r11, r10
				Arr[LOCAL_u8Counter1] =LOCAL_u8pass;
				CLCD_voidWriteNumbers(LOCAL_u8pass);
    4ba2:	c5 01       	movw	r24, r10
    4ba4:	b4 01       	movw	r22, r8
    4ba6:	0e 94 1c 11 	call	0x2238	; 0x2238 <CLCD_voidWriteNumbers>
    4baa:	28 ee       	ldi	r18, 0xE8	; 232
    4bac:	33 e0       	ldi	r19, 0x03	; 3
    4bae:	c6 01       	movw	r24, r12
    4bb0:	01 97       	sbiw	r24, 0x01	; 1
    4bb2:	f1 f7       	brne	.-4      	; 0x4bb0 <APP_LoginSystem+0x164>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4bb4:	21 50       	subi	r18, 0x01	; 1
    4bb6:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4bb8:	d1 f7       	brne	.-12     	; 0x4bae <APP_LoginSystem+0x162>
	{
		X = Keypad_u8GetPressed(Keypad_Array);
		if(X != '+'){
			if((X >= '0') &&(X <= '9')){
				LOCAL_u8pass = X-'0';
				Arr[LOCAL_u8Counter1] =LOCAL_u8pass;
    4bba:	f3 01       	movw	r30, r6
    4bbc:	ef 0d       	add	r30, r15
    4bbe:	f1 1d       	adc	r31, r1
    4bc0:	80 82       	st	Z, r8
				CLCD_voidWriteNumbers(LOCAL_u8pass);
				_delay_ms(100);
				CLCD_voidGoto(2,LOCAL_u8Counter2+1);
    4bc2:	0f 5f       	subi	r16, 0xFF	; 255
    4bc4:	82 e0       	ldi	r24, 0x02	; 2
    4bc6:	60 2f       	mov	r22, r16
    4bc8:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
				CLCD_voidWriteData('*');
    4bcc:	8a e2       	ldi	r24, 0x2A	; 42
    4bce:	0e 94 fb 10 	call	0x21f6	; 0x21f6 <CLCD_voidWriteData>
				LOCAL_u8Counter2++;
				LOCAL_u8Counter1++;
    4bd2:	f3 94       	inc	r15
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8pass = 0;
	uint_8 LOCAL_u8Counter1 = 0, LOCAL_u8TrueCounter = 0, LOCAL_u8Counter2 = 6;
	uint_8 X = '+';
	uint_8 Arr[4] ={0,0,0,0};
	while((LOCAL_u8Counter2 < 10)&& (X  !='K'))
    4bd4:	0a 30       	cpi	r16, 0x0A	; 10
    4bd6:	08 f0       	brcs	.+2      	; 0x4bda <APP_LoginSystem+0x18e>
    4bd8:	fb c1       	rjmp	.+1014   	; 0x4fd0 <APP_LoginSystem+0x584>
    4bda:	1b 34       	cpi	r17, 0x4B	; 75
    4bdc:	89 f6       	brne	.-94     	; 0x4b80 <APP_LoginSystem+0x134>
    4bde:	f8 c1       	rjmp	.+1008   	; 0x4fd0 <APP_LoginSystem+0x584>
    4be0:	0e 2d       	mov	r16, r14


	for(LOCAL_u8Counter1 =0; LOCAL_u8Counter1 <4; LOCAL_u8Counter1++)
	{

		if(Arr[LOCAL_u8Counter1] == readDataFromEEPROM( (*Copy_add) + LOCAL_u8Counter1 + 1))
    4be2:	f3 01       	movw	r30, r6
    4be4:	ee 0d       	add	r30, r14
    4be6:	ff 1d       	adc	r31, r15
    4be8:	10 81       	ld	r17, Z
    4bea:	80 91 f0 07 	lds	r24, 0x07F0
    4bee:	90 e0       	ldi	r25, 0x00	; 0
    4bf0:	01 96       	adiw	r24, 0x01	; 1
    4bf2:	8e 0d       	add	r24, r14
    4bf4:	9f 1d       	adc	r25, r15
    4bf6:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    4bfa:	18 17       	cp	r17, r24
    4bfc:	41 f4       	brne	.+16     	; 0x4c0e <APP_LoginSystem+0x1c2>
    4bfe:	0f 5f       	subi	r16, 0xFF	; 255
    4c00:	08 94       	sec
    4c02:	e1 1c       	adc	r14, r1
    4c04:	f1 1c       	adc	r15, r1
			}
		}
	}


	for(LOCAL_u8Counter1 =0; LOCAL_u8Counter1 <4; LOCAL_u8Counter1++)
    4c06:	84 e0       	ldi	r24, 0x04	; 4
    4c08:	e8 16       	cp	r14, r24
    4c0a:	f1 04       	cpc	r15, r1
    4c0c:	49 f7       	brne	.-46     	; 0x4be0 <APP_LoginSystem+0x194>
		else
		{
			break;
		}
	}
	if(LOCAL_u8TrueCounter == 4)
    4c0e:	04 30       	cpi	r16, 0x04	; 4
    4c10:	09 f4       	brne	.+2      	; 0x4c14 <APP_LoginSystem+0x1c8>
    4c12:	9a c1       	rjmp	.+820    	; 0x4f48 <APP_LoginSystem+0x4fc>
					//*LOCAL_u8N =0;
					break;
				}
				else
				{
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    4c14:	81 e0       	ldi	r24, 0x01	; 1
    4c16:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					CLCD_voidWriteString("Try again ");
    4c1a:	8b e4       	ldi	r24, 0x4B	; 75
    4c1c:	95 e0       	ldi	r25, 0x05	; 5
    4c1e:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    4c22:	28 e8       	ldi	r18, 0x88	; 136
    4c24:	33 e1       	ldi	r19, 0x13	; 19
    4c26:	0d c0       	rjmp	.+26     	; 0x4c42 <APP_LoginSystem+0x1f6>
    4c28:	ca 01       	movw	r24, r20
    4c2a:	01 97       	sbiw	r24, 0x01	; 1
    4c2c:	f1 f7       	brne	.-4      	; 0x4c2a <APP_LoginSystem+0x1de>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4c2e:	21 50       	subi	r18, 0x01	; 1
    4c30:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4c32:	d1 f7       	brne	.-12     	; 0x4c28 <APP_LoginSystem+0x1dc>
				{
					MotorFlag = 1;
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
					CLCD_voidWriteString("Correct Pass ");
					_delay_ms(500);
					Next = ESt1;
    4c34:	81 e0       	ldi	r24, 0x01	; 1
    4c36:	80 93 06 08 	sts	0x0806, r24
					/*try again*/
					Trial++;
					//Next = St1;
				}
			}
			if(Trial ==3)
    4c3a:	83 e0       	ldi	r24, 0x03	; 3
    4c3c:	38 16       	cp	r3, r24
    4c3e:	81 f4       	brne	.+32     	; 0x4c60 <APP_LoginSystem+0x214>
    4c40:	0b c0       	rjmp	.+22     	; 0x4c58 <APP_LoginSystem+0x20c>
    4c42:	c6 01       	movw	r24, r12
    4c44:	01 97       	sbiw	r24, 0x01	; 1
    4c46:	f1 f7       	brne	.-4      	; 0x4c44 <APP_LoginSystem+0x1f8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4c48:	21 50       	subi	r18, 0x01	; 1
    4c4a:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4c4c:	d1 f7       	brne	.-12     	; 0x4c42 <APP_LoginSystem+0x1f6>
				{
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
					CLCD_voidWriteString("Try again ");
					_delay_ms(500);
					/*try again*/
					Trial++;
    4c4e:	33 94       	inc	r3
	*LOCAL_u8N =0;
	switch (Copy_LoginType) {
	case User_Keypad:
		if(Check_Usernamekeypad(LOCAL_u8NameAdd) == OK )
		{
			while(Trial < 3)
    4c50:	83 e0       	ldi	r24, 0x03	; 3
    4c52:	38 16       	cp	r3, r24
    4c54:	09 f0       	breq	.+2      	; 0x4c58 <APP_LoginSystem+0x20c>
    4c56:	78 cf       	rjmp	.-272    	; 0x4b48 <APP_LoginSystem+0xfc>
				}
			}
			if(Trial ==3)
			{
				Trial=0;
				APP_BlockingMode();
    4c58:	0e 94 f5 24 	call	0x49ea	; 0x49ea <APP_BlockingMode>
				Next = ESt0;
    4c5c:	10 92 06 08 	sts	0x0806, r1
			}
			*LOCAL_u8N =0;
    4c60:	10 92 f1 07 	sts	0x07F1, r1
		{
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
			CLCD_voidWriteString("Try again ");
			Next = ESt0;
		}
		CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    4c64:	81 e0       	ldi	r24, 0x01	; 1
    4c66:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
    4c6a:	4a c1       	rjmp	.+660    	; 0x4f00 <APP_LoginSystem+0x4b4>
{
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8Name = 0;
	uint_8 LOCAL_u8Counter2 = 11;
	uint_8 X = '+';
	transmitDataBlockOverBluetooth("UserName: \n",12);
    4c6c:	86 e5       	ldi	r24, 0x56	; 86
    4c6e:	95 e0       	ldi	r25, 0x05	; 5
    4c70:	6c e0       	ldi	r22, 0x0C	; 12
    4c72:	70 e0       	ldi	r23, 0x00	; 0
    4c74:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    4c78:	1b e0       	ldi	r17, 0x0B	; 11
    4c7a:	cc 24       	eor	r12, r12
    4c7c:	dd 24       	eor	r13, r13
    4c7e:	76 01       	movw	r14, r12
	while((LOCAL_u8Counter2 < 12)&& (X  !='K')){
		X = UART_ReceiveChar();
    4c80:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
    4c84:	28 2f       	mov	r18, r24
		if(X != '+'){
    4c86:	8b 32       	cpi	r24, 0x2B	; 43
    4c88:	61 f0       	breq	.+24     	; 0x4ca2 <APP_LoginSystem+0x256>
			if((X >= '0') &&(X <= '9')){
    4c8a:	80 53       	subi	r24, 0x30	; 48
    4c8c:	8a 30       	cpi	r24, 0x0A	; 10
    4c8e:	48 f4       	brcc	.+18     	; 0x4ca2 <APP_LoginSystem+0x256>
				LOCAL_u8Name = X-'0';
    4c90:	82 2f       	mov	r24, r18
    4c92:	90 e0       	ldi	r25, 0x00	; 0
    4c94:	c0 97       	sbiw	r24, 0x30	; 48
    4c96:	6c 01       	movw	r12, r24
    4c98:	ee 24       	eor	r14, r14
    4c9a:	d7 fc       	sbrc	r13, 7
    4c9c:	e0 94       	com	r14
    4c9e:	fe 2c       	mov	r15, r14
				LOCAL_u8Counter2++;
    4ca0:	1f 5f       	subi	r17, 0xFF	; 255
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8Name = 0;
	uint_8 LOCAL_u8Counter2 = 11;
	uint_8 X = '+';
	transmitDataBlockOverBluetooth("UserName: \n",12);
	while((LOCAL_u8Counter2 < 12)&& (X  !='K')){
    4ca2:	1c 30       	cpi	r17, 0x0C	; 12
    4ca4:	08 f0       	brcs	.+2      	; 0x4ca8 <APP_LoginSystem+0x25c>
    4ca6:	9c c1       	rjmp	.+824    	; 0x4fe0 <APP_LoginSystem+0x594>
    4ca8:	2b 34       	cpi	r18, 0x4B	; 75
    4caa:	51 f7       	brne	.-44     	; 0x4c80 <APP_LoginSystem+0x234>
    4cac:	99 c1       	rjmp	.+818    	; 0x4fe0 <APP_LoginSystem+0x594>
    4cae:	80 2f       	mov	r24, r16
    4cb0:	89 51       	subi	r24, 0x19	; 25
    4cb2:	8d 83       	std	Y+5, r24	; 0x05
	}

	for(LOCAL_u8Counter2 = 0; LOCAL_u8Counter2 <= 20; LOCAL_u8Counter2 +=5)
	{

		(*LOCAL_u8N)++;
    4cb4:	80 91 f1 07 	lds	r24, 0x07F1
    4cb8:	8f 5f       	subi	r24, 0xFF	; 255
    4cba:	80 93 f1 07 	sts	0x07F1, r24

		if(LOCAL_u8Name == readDataFromEEPROM(LOCAL_u8Counter2 + EEPROM_ADDR_F_UsersRemote))
    4cbe:	c8 01       	movw	r24, r16
    4cc0:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    4cc4:	90 e0       	ldi	r25, 0x00	; 0
    4cc6:	a0 e0       	ldi	r26, 0x00	; 0
    4cc8:	b0 e0       	ldi	r27, 0x00	; 0
    4cca:	8c 15       	cp	r24, r12
    4ccc:	9d 05       	cpc	r25, r13
    4cce:	ae 05       	cpc	r26, r14
    4cd0:	bf 05       	cpc	r27, r15
    4cd2:	e1 f4       	brne	.+56     	; 0x4d0c <APP_LoginSystem+0x2c0>
		{

			*Copy_add = LOCAL_u8Counter2 + EEPROM_ADDR_F_UsersRemote;
    4cd4:	8d 81       	ldd	r24, Y+5	; 0x05
    4cd6:	87 5e       	subi	r24, 0xE7	; 231
    4cd8:	80 93 f0 07 	sts	0x07F0, r24
    4cdc:	cc 24       	eor	r12, r12
	case User_Remote:
		if(Check_UsernameRemote(LOCAL_u8NameAdd) == OK )
		{
			while(Trial < 3)
			{
				transmitDataBlockOverBluetooth("UserName-\n",11);
    4cde:	0f 2e       	mov	r0, r31
    4ce0:	f2 e6       	ldi	r31, 0x62	; 98
    4ce2:	8f 2e       	mov	r8, r31
    4ce4:	f5 e0       	ldi	r31, 0x05	; 5
    4ce6:	9f 2e       	mov	r9, r31
    4ce8:	f0 2d       	mov	r31, r0
				UART_TransmitChar((*LOCAL_u8N)+'0');
				*LOCAL_u8N =0;

				transmitDataBlockOverBluetooth("Pass \n",7);
    4cea:	0f 2e       	mov	r0, r31
    4cec:	fd e6       	ldi	r31, 0x6D	; 109
    4cee:	6f 2e       	mov	r6, r31
    4cf0:	f5 e0       	ldi	r31, 0x05	; 5
    4cf2:	7f 2e       	mov	r7, r31
    4cf4:	f0 2d       	mov	r31, r0
{
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8pass = 0;
	uint_8 LOCAL_u8Counter1 = 0, LOCAL_u8TrueCounter = 0, LOCAL_u8Counter2 = 6;
	uint_8 X = '+';
	uint_8 Arr[4] ={0,0,0,0};
    4cf6:	0f 2e       	mov	r0, r31
    4cf8:	f6 e0       	ldi	r31, 0x06	; 6
    4cfa:	5f 2e       	mov	r5, r31
    4cfc:	f0 2d       	mov	r31, r0
	{
		X = UART_ReceiveChar();
		if(X != '+'){
			if((X >= '0') &&(X <= '9')){
				LOCAL_u8pass = X-'0';
				Arr[LOCAL_u8Counter1] =X;
    4cfe:	5e 01       	movw	r10, r28
    4d00:	08 94       	sec
    4d02:	a1 1c       	adc	r10, r1
    4d04:	b1 1c       	adc	r11, r1
				{
					transmitDataBlockOverBluetooth("Try again \n",12);
					Trial++;
				}
			}
			if(Trial ==3)
    4d06:	22 24       	eor	r2, r2
    4d08:	33 24       	eor	r3, r3
    4d0a:	06 c0       	rjmp	.+12     	; 0x4d18 <APP_LoginSystem+0x2cc>
		(*LOCAL_u8N)++;

		if(LOCAL_u8Name == readDataFromEEPROM(LOCAL_u8Counter2 + EEPROM_ADDR_F_UsersRemote))
		{

			*Copy_add = LOCAL_u8Counter2 + EEPROM_ADDR_F_UsersRemote;
    4d0c:	0b 5f       	subi	r16, 0xFB	; 251
    4d0e:	1f 4f       	sbci	r17, 0xFF	; 255
				LOCAL_u8Counter2++;
			}
		}
	}

	for(LOCAL_u8Counter2 = 0; LOCAL_u8Counter2 <= 20; LOCAL_u8Counter2 +=5)
    4d10:	02 33       	cpi	r16, 0x32	; 50
    4d12:	11 05       	cpc	r17, r1
    4d14:	61 f6       	brne	.-104    	; 0x4cae <APP_LoginSystem+0x262>
    4d16:	26 c1       	rjmp	.+588    	; 0x4f64 <APP_LoginSystem+0x518>
	case User_Remote:
		if(Check_UsernameRemote(LOCAL_u8NameAdd) == OK )
		{
			while(Trial < 3)
			{
				transmitDataBlockOverBluetooth("UserName-\n",11);
    4d18:	c4 01       	movw	r24, r8
    4d1a:	6b e0       	ldi	r22, 0x0B	; 11
    4d1c:	70 e0       	ldi	r23, 0x00	; 0
    4d1e:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				UART_TransmitChar((*LOCAL_u8N)+'0');
    4d22:	80 91 f1 07 	lds	r24, 0x07F1
    4d26:	90 e0       	ldi	r25, 0x00	; 0
    4d28:	c0 96       	adiw	r24, 0x30	; 48
    4d2a:	0e 94 fa 12 	call	0x25f4	; 0x25f4 <UART_TransmitChar>
				*LOCAL_u8N =0;
    4d2e:	10 92 f1 07 	sts	0x07F1, r1

				transmitDataBlockOverBluetooth("Pass \n",7);
    4d32:	c3 01       	movw	r24, r6
    4d34:	67 e0       	ldi	r22, 0x07	; 7
    4d36:	70 e0       	ldi	r23, 0x00	; 0
    4d38:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
{
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8pass = 0;
	uint_8 LOCAL_u8Counter1 = 0, LOCAL_u8TrueCounter = 0, LOCAL_u8Counter2 = 6;
	uint_8 X = '+';
	uint_8 Arr[4] ={0,0,0,0};
    4d3c:	19 82       	std	Y+1, r1	; 0x01
    4d3e:	1a 82       	std	Y+2, r1	; 0x02
    4d40:	1b 82       	std	Y+3, r1	; 0x03
    4d42:	1c 82       	std	Y+4, r1	; 0x04
    4d44:	00 e0       	ldi	r16, 0x00	; 0
    4d46:	15 2d       	mov	r17, r5
	while((LOCAL_u8Counter2 < 10)&& (X  !='K'))
	{
		X = UART_ReceiveChar();
    4d48:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
    4d4c:	98 2f       	mov	r25, r24
		if(X != '+'){
    4d4e:	8b 32       	cpi	r24, 0x2B	; 43
    4d50:	49 f0       	breq	.+18     	; 0x4d64 <APP_LoginSystem+0x318>
			if((X >= '0') &&(X <= '9')){
    4d52:	80 53       	subi	r24, 0x30	; 48
    4d54:	8a 30       	cpi	r24, 0x0A	; 10
    4d56:	30 f4       	brcc	.+12     	; 0x4d64 <APP_LoginSystem+0x318>
				LOCAL_u8pass = X-'0';
				Arr[LOCAL_u8Counter1] =X;
    4d58:	f5 01       	movw	r30, r10
    4d5a:	e0 0f       	add	r30, r16
    4d5c:	f1 1d       	adc	r31, r1
    4d5e:	90 83       	st	Z, r25
				LOCAL_u8Counter2++;
    4d60:	1f 5f       	subi	r17, 0xFF	; 255
				LOCAL_u8Counter1++;
    4d62:	0f 5f       	subi	r16, 0xFF	; 255
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8pass = 0;
	uint_8 LOCAL_u8Counter1 = 0, LOCAL_u8TrueCounter = 0, LOCAL_u8Counter2 = 6;
	uint_8 X = '+';
	uint_8 Arr[4] ={0,0,0,0};
	while((LOCAL_u8Counter2 < 10)&& (X  !='K'))
    4d64:	1a 30       	cpi	r17, 0x0A	; 10
    4d66:	08 f0       	brcs	.+2      	; 0x4d6a <APP_LoginSystem+0x31e>
    4d68:	39 c1       	rjmp	.+626    	; 0x4fdc <APP_LoginSystem+0x590>
    4d6a:	9b 34       	cpi	r25, 0x4B	; 75
    4d6c:	69 f7       	brne	.-38     	; 0x4d48 <APP_LoginSystem+0x2fc>
    4d6e:	36 c1       	rjmp	.+620    	; 0x4fdc <APP_LoginSystem+0x590>
    4d70:	de 2c       	mov	r13, r14
		}
	}
	for(LOCAL_u8Counter1 =0; LOCAL_u8Counter1 <4; LOCAL_u8Counter1++)
	{
		;
		if(Arr[LOCAL_u8Counter1] - '0' == readDataFromEEPROM( (*Copy_add) + LOCAL_u8Counter1 + 1))
    4d72:	f5 01       	movw	r30, r10
    4d74:	ee 0d       	add	r30, r14
    4d76:	ff 1d       	adc	r31, r15
    4d78:	00 81       	ld	r16, Z
    4d7a:	10 e0       	ldi	r17, 0x00	; 0
    4d7c:	00 53       	subi	r16, 0x30	; 48
    4d7e:	10 40       	sbci	r17, 0x00	; 0
    4d80:	80 91 f0 07 	lds	r24, 0x07F0
    4d84:	90 e0       	ldi	r25, 0x00	; 0
    4d86:	01 96       	adiw	r24, 0x01	; 1
    4d88:	8e 0d       	add	r24, r14
    4d8a:	9f 1d       	adc	r25, r15
    4d8c:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    4d90:	90 e0       	ldi	r25, 0x00	; 0
    4d92:	08 17       	cp	r16, r24
    4d94:	19 07       	cpc	r17, r25
    4d96:	41 f4       	brne	.+16     	; 0x4da8 <APP_LoginSystem+0x35c>
    4d98:	d3 94       	inc	r13
    4d9a:	08 94       	sec
    4d9c:	e1 1c       	adc	r14, r1
    4d9e:	f1 1c       	adc	r15, r1
				LOCAL_u8Counter2++;
				LOCAL_u8Counter1++;
			}
		}
	}
	for(LOCAL_u8Counter1 =0; LOCAL_u8Counter1 <4; LOCAL_u8Counter1++)
    4da0:	84 e0       	ldi	r24, 0x04	; 4
    4da2:	e8 16       	cp	r14, r24
    4da4:	f1 04       	cpc	r15, r1
    4da6:	21 f7       	brne	.-56     	; 0x4d70 <APP_LoginSystem+0x324>
		else
		{
			break;
		}
	}
	if(LOCAL_u8TrueCounter == 4)
    4da8:	84 e0       	ldi	r24, 0x04	; 4
    4daa:	d8 16       	cp	r13, r24
    4dac:	09 f4       	brne	.+2      	; 0x4db0 <APP_LoginSystem+0x364>
    4dae:	e4 c0       	rjmp	.+456    	; 0x4f78 <APP_LoginSystem+0x52c>
					transmitDataBlockOverBluetooth("Correct Pass \n",15);
					Next = RSt4;
					break;
				}
				else{
					transmitDataBlockOverBluetooth("Try again \n",12);
    4db0:	84 e7       	ldi	r24, 0x74	; 116
    4db2:	95 e0       	ldi	r25, 0x05	; 5
    4db4:	6c e0       	ldi	r22, 0x0C	; 12
    4db6:	70 e0       	ldi	r23, 0x00	; 0
    4db8:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
					Trial++;
    4dbc:	c3 94       	inc	r12
		CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
		break;
	case User_Remote:
		if(Check_UsernameRemote(LOCAL_u8NameAdd) == OK )
		{
			while(Trial < 3)
    4dbe:	83 e0       	ldi	r24, 0x03	; 3
    4dc0:	c8 16       	cp	r12, r24
    4dc2:	09 f0       	breq	.+2      	; 0x4dc6 <APP_LoginSystem+0x37a>
    4dc4:	a9 cf       	rjmp	.-174    	; 0x4d18 <APP_LoginSystem+0x2cc>
				}
			}
			if(Trial ==3)
			{
				Trial=0;
				APP_BlockingMode();
    4dc6:	0e 94 f5 24 	call	0x49ea	; 0x49ea <APP_BlockingMode>

				Next = RSt2;
    4dca:	87 e1       	ldi	r24, 0x17	; 23
    4dcc:	80 93 06 08 	sts	0x0806, r24
    4dd0:	97 c0       	rjmp	.+302    	; 0x4f00 <APP_LoginSystem+0x4b4>
{
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8Name = 0;
	uint_8 LOCAL_u8Counter2 = 11;
	uint_8 X = '+';
	transmitDataBlockOverBluetooth("Admin Name: \n",14);
    4dd2:	80 e8       	ldi	r24, 0x80	; 128
    4dd4:	95 e0       	ldi	r25, 0x05	; 5
    4dd6:	6e e0       	ldi	r22, 0x0E	; 14
    4dd8:	70 e0       	ldi	r23, 0x00	; 0
    4dda:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    4dde:	1b e0       	ldi	r17, 0x0B	; 11
    4de0:	cc 24       	eor	r12, r12
    4de2:	dd 24       	eor	r13, r13
    4de4:	76 01       	movw	r14, r12
	while((LOCAL_u8Counter2 < 12)&& (X  !='K')){
		X = UART_ReceiveChar();
    4de6:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
    4dea:	28 2f       	mov	r18, r24
		if(X != '+'){
    4dec:	8b 32       	cpi	r24, 0x2B	; 43
    4dee:	61 f0       	breq	.+24     	; 0x4e08 <APP_LoginSystem+0x3bc>
			if((X >= '0') &&(X <= '9')){
    4df0:	80 53       	subi	r24, 0x30	; 48
    4df2:	8a 30       	cpi	r24, 0x0A	; 10
    4df4:	48 f4       	brcc	.+18     	; 0x4e08 <APP_LoginSystem+0x3bc>
				LOCAL_u8Name = X-'0';
    4df6:	82 2f       	mov	r24, r18
    4df8:	90 e0       	ldi	r25, 0x00	; 0
    4dfa:	c0 97       	sbiw	r24, 0x30	; 48
    4dfc:	6c 01       	movw	r12, r24
    4dfe:	ee 24       	eor	r14, r14
    4e00:	d7 fc       	sbrc	r13, 7
    4e02:	e0 94       	com	r14
    4e04:	fe 2c       	mov	r15, r14
				LOCAL_u8Counter2++;
    4e06:	1f 5f       	subi	r17, 0xFF	; 255
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8Name = 0;
	uint_8 LOCAL_u8Counter2 = 11;
	uint_8 X = '+';
	transmitDataBlockOverBluetooth("Admin Name: \n",14);
	while((LOCAL_u8Counter2 < 12)&& (X  !='K')){
    4e08:	1c 30       	cpi	r17, 0x0C	; 12
    4e0a:	08 f0       	brcs	.+2      	; 0x4e0e <APP_LoginSystem+0x3c2>
    4e0c:	ee c0       	rjmp	.+476    	; 0x4fea <APP_LoginSystem+0x59e>
    4e0e:	2b 34       	cpi	r18, 0x4B	; 75
    4e10:	51 f7       	brne	.-44     	; 0x4de6 <APP_LoginSystem+0x39a>
    4e12:	eb c0       	rjmp	.+470    	; 0x4fea <APP_LoginSystem+0x59e>
	for(LOCAL_u8Counter2 = 0; LOCAL_u8Counter2 < 1; LOCAL_u8Counter2++)
	{
		(*LOCAL_u8N)++;
		if(LOCAL_u8Name == readDataFromEEPROM(LOCAL_u8Counter2 + EEPROM_ADDR_F_Admin))
		{
			*Copy_add = LOCAL_u8Counter2 + EEPROM_ADDR_F_Admin;
    4e14:	82 e3       	ldi	r24, 0x32	; 50
    4e16:	80 93 f0 07 	sts	0x07F0, r24
    4e1a:	cc 24       	eor	r12, r12
		if(Check_AdminName(LOCAL_u8NameAdd) == OK )
		{
			while(Trial < 3)
			{

				transmitDataBlockOverBluetooth("Admin Name \n",13);
    4e1c:	0f 2e       	mov	r0, r31
    4e1e:	fe e8       	ldi	r31, 0x8E	; 142
    4e20:	8f 2e       	mov	r8, r31
    4e22:	f5 e0       	ldi	r31, 0x05	; 5
    4e24:	9f 2e       	mov	r9, r31
    4e26:	f0 2d       	mov	r31, r0
				UART_TransmitChar((*LOCAL_u8N)+'0');
				*LOCAL_u8N =0;

				transmitDataBlockOverBluetooth("Pass \n",7);
    4e28:	0f 2e       	mov	r0, r31
    4e2a:	fd e6       	ldi	r31, 0x6D	; 109
    4e2c:	6f 2e       	mov	r6, r31
    4e2e:	f5 e0       	ldi	r31, 0x05	; 5
    4e30:	7f 2e       	mov	r7, r31
    4e32:	f0 2d       	mov	r31, r0
{
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8pass = 0;
	uint_8 LOCAL_u8Counter1 = 0, LOCAL_u8TrueCounter = 0, LOCAL_u8Counter2 = 6;
	uint_8 X = '+';
	uint_8 Arr[4] ={0,0,0,0};
    4e34:	0f 2e       	mov	r0, r31
    4e36:	f6 e0       	ldi	r31, 0x06	; 6
    4e38:	5f 2e       	mov	r5, r31
    4e3a:	f0 2d       	mov	r31, r0
	{
		X = UART_ReceiveChar();
		if(X != '+'){
			if((X >= '0') &&(X <= '9')){
				LOCAL_u8pass = X-'0';
				Arr[LOCAL_u8Counter1] =X;
    4e3c:	5e 01       	movw	r10, r28
    4e3e:	08 94       	sec
    4e40:	a1 1c       	adc	r10, r1
    4e42:	b1 1c       	adc	r11, r1
				{
					transmitDataBlockOverBluetooth("Try again \n",12);
					Trial++;
				}
			}
			if(Trial ==3)
    4e44:	22 24       	eor	r2, r2
    4e46:	33 24       	eor	r3, r3
		if(Check_AdminName(LOCAL_u8NameAdd) == OK )
		{
			while(Trial < 3)
			{

				transmitDataBlockOverBluetooth("Admin Name \n",13);
    4e48:	c4 01       	movw	r24, r8
    4e4a:	6d e0       	ldi	r22, 0x0D	; 13
    4e4c:	70 e0       	ldi	r23, 0x00	; 0
    4e4e:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				UART_TransmitChar((*LOCAL_u8N)+'0');
    4e52:	80 91 f1 07 	lds	r24, 0x07F1
    4e56:	90 e0       	ldi	r25, 0x00	; 0
    4e58:	c0 96       	adiw	r24, 0x30	; 48
    4e5a:	0e 94 fa 12 	call	0x25f4	; 0x25f4 <UART_TransmitChar>
				*LOCAL_u8N =0;
    4e5e:	10 92 f1 07 	sts	0x07F1, r1

				transmitDataBlockOverBluetooth("Pass \n",7);
    4e62:	c3 01       	movw	r24, r6
    4e64:	67 e0       	ldi	r22, 0x07	; 7
    4e66:	70 e0       	ldi	r23, 0x00	; 0
    4e68:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
{
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8pass = 0;
	uint_8 LOCAL_u8Counter1 = 0, LOCAL_u8TrueCounter = 0, LOCAL_u8Counter2 = 6;
	uint_8 X = '+';
	uint_8 Arr[4] ={0,0,0,0};
    4e6c:	19 82       	std	Y+1, r1	; 0x01
    4e6e:	1a 82       	std	Y+2, r1	; 0x02
    4e70:	1b 82       	std	Y+3, r1	; 0x03
    4e72:	1c 82       	std	Y+4, r1	; 0x04
    4e74:	00 e0       	ldi	r16, 0x00	; 0
    4e76:	15 2d       	mov	r17, r5
	while((LOCAL_u8Counter2 < 10)&& (X  !='K'))
	{
		X = UART_ReceiveChar();
    4e78:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
    4e7c:	98 2f       	mov	r25, r24
		if(X != '+'){
    4e7e:	8b 32       	cpi	r24, 0x2B	; 43
    4e80:	49 f0       	breq	.+18     	; 0x4e94 <APP_LoginSystem+0x448>
			if((X >= '0') &&(X <= '9')){
    4e82:	80 53       	subi	r24, 0x30	; 48
    4e84:	8a 30       	cpi	r24, 0x0A	; 10
    4e86:	30 f4       	brcc	.+12     	; 0x4e94 <APP_LoginSystem+0x448>
				LOCAL_u8pass = X-'0';
				Arr[LOCAL_u8Counter1] =X;
    4e88:	f5 01       	movw	r30, r10
    4e8a:	e0 0f       	add	r30, r16
    4e8c:	f1 1d       	adc	r31, r1
    4e8e:	90 83       	st	Z, r25
				LOCAL_u8Counter2++;
    4e90:	1f 5f       	subi	r17, 0xFF	; 255
				LOCAL_u8Counter1++;
    4e92:	0f 5f       	subi	r16, 0xFF	; 255
	Std_Return ret = R_NOT_OK;
	uint_32 LOCAL_u8pass = 0;
	uint_8 LOCAL_u8Counter1 = 0, LOCAL_u8TrueCounter = 0, LOCAL_u8Counter2 = 6;
	uint_8 X = '+';
	uint_8 Arr[4] ={0,0,0,0};
	while((LOCAL_u8Counter2 < 10)&& (X  !='K'))
    4e94:	1a 30       	cpi	r17, 0x0A	; 10
    4e96:	08 f0       	brcs	.+2      	; 0x4e9a <APP_LoginSystem+0x44e>
    4e98:	a6 c0       	rjmp	.+332    	; 0x4fe6 <APP_LoginSystem+0x59a>
    4e9a:	9b 34       	cpi	r25, 0x4B	; 75
    4e9c:	69 f7       	brne	.-38     	; 0x4e78 <APP_LoginSystem+0x42c>
    4e9e:	a3 c0       	rjmp	.+326    	; 0x4fe6 <APP_LoginSystem+0x59a>
    4ea0:	de 2c       	mov	r13, r14
			}
		}
	}
	for(LOCAL_u8Counter1 =0; LOCAL_u8Counter1 <4; LOCAL_u8Counter1++)
	{
		if(Arr[LOCAL_u8Counter1] - '0' == readDataFromEEPROM( (*Copy_add) + LOCAL_u8Counter1 + 1))
    4ea2:	f5 01       	movw	r30, r10
    4ea4:	ee 0d       	add	r30, r14
    4ea6:	ff 1d       	adc	r31, r15
    4ea8:	00 81       	ld	r16, Z
    4eaa:	10 e0       	ldi	r17, 0x00	; 0
    4eac:	00 53       	subi	r16, 0x30	; 48
    4eae:	10 40       	sbci	r17, 0x00	; 0
    4eb0:	80 91 f0 07 	lds	r24, 0x07F0
    4eb4:	90 e0       	ldi	r25, 0x00	; 0
    4eb6:	01 96       	adiw	r24, 0x01	; 1
    4eb8:	8e 0d       	add	r24, r14
    4eba:	9f 1d       	adc	r25, r15
    4ebc:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    4ec0:	90 e0       	ldi	r25, 0x00	; 0
    4ec2:	08 17       	cp	r16, r24
    4ec4:	19 07       	cpc	r17, r25
    4ec6:	41 f4       	brne	.+16     	; 0x4ed8 <APP_LoginSystem+0x48c>
    4ec8:	d3 94       	inc	r13
    4eca:	08 94       	sec
    4ecc:	e1 1c       	adc	r14, r1
    4ece:	f1 1c       	adc	r15, r1
				LOCAL_u8Counter2++;
				LOCAL_u8Counter1++;
			}
		}
	}
	for(LOCAL_u8Counter1 =0; LOCAL_u8Counter1 <4; LOCAL_u8Counter1++)
    4ed0:	84 e0       	ldi	r24, 0x04	; 4
    4ed2:	e8 16       	cp	r14, r24
    4ed4:	f1 04       	cpc	r15, r1
    4ed6:	21 f7       	brne	.-56     	; 0x4ea0 <APP_LoginSystem+0x454>
		else
		{
			break;
		}
	}
	if(LOCAL_u8TrueCounter == 4)
    4ed8:	84 e0       	ldi	r24, 0x04	; 4
    4eda:	d8 16       	cp	r13, r24
    4edc:	09 f4       	brne	.+2      	; 0x4ee0 <APP_LoginSystem+0x494>
    4ede:	67 c0       	rjmp	.+206    	; 0x4fae <APP_LoginSystem+0x562>
					Next = RSt3;
					break;
				}
				else
				{
					transmitDataBlockOverBluetooth("Try again \n",12);
    4ee0:	84 e7       	ldi	r24, 0x74	; 116
    4ee2:	95 e0       	ldi	r25, 0x05	; 5
    4ee4:	6c e0       	ldi	r22, 0x0C	; 12
    4ee6:	70 e0       	ldi	r23, 0x00	; 0
    4ee8:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
					Trial++;
    4eec:	c3 94       	inc	r12
		}
		break;
	case Admin:
		if(Check_AdminName(LOCAL_u8NameAdd) == OK )
		{
			while(Trial < 3)
    4eee:	83 e0       	ldi	r24, 0x03	; 3
    4ef0:	c8 16       	cp	r12, r24
    4ef2:	09 f0       	breq	.+2      	; 0x4ef6 <APP_LoginSystem+0x4aa>
    4ef4:	a9 cf       	rjmp	.-174    	; 0x4e48 <APP_LoginSystem+0x3fc>
				}
			}
			if(Trial ==3)
			{
				Trial=0;
				APP_BlockingMode();
    4ef6:	0e 94 f5 24 	call	0x49ea	; 0x49ea <APP_BlockingMode>
				Next = RSt1;
    4efa:	86 e1       	ldi	r24, 0x16	; 22
    4efc:	80 93 06 08 	sts	0x0806, r24
		}
		break;
	}

	return Next;
}
    4f00:	80 91 06 08 	lds	r24, 0x0806
    4f04:	0f 90       	pop	r0
    4f06:	0f 90       	pop	r0
    4f08:	0f 90       	pop	r0
    4f0a:	0f 90       	pop	r0
    4f0c:	0f 90       	pop	r0
    4f0e:	cf 91       	pop	r28
    4f10:	df 91       	pop	r29
    4f12:	1f 91       	pop	r17
    4f14:	0f 91       	pop	r16
    4f16:	ff 90       	pop	r15
    4f18:	ef 90       	pop	r14
    4f1a:	df 90       	pop	r13
    4f1c:	cf 90       	pop	r12
    4f1e:	bf 90       	pop	r11
    4f20:	af 90       	pop	r10
    4f22:	9f 90       	pop	r9
    4f24:	8f 90       	pop	r8
    4f26:	7f 90       	pop	r7
    4f28:	6f 90       	pop	r6
    4f2a:	5f 90       	pop	r5
    4f2c:	4f 90       	pop	r4
    4f2e:	3f 90       	pop	r3
    4f30:	2f 90       	pop	r2
    4f32:	08 95       	ret
			}
			*LOCAL_u8N =0;
		}
		else
		{
			CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    4f34:	81 e0       	ldi	r24, 0x01	; 1
    4f36:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
			CLCD_voidWriteString("Try again ");
    4f3a:	8b e4       	ldi	r24, 0x4B	; 75
    4f3c:	95 e0       	ldi	r25, 0x05	; 5
    4f3e:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
			Next = ESt0;
    4f42:	10 92 06 08 	sts	0x0806, r1
    4f46:	8e ce       	rjmp	.-740    	; 0x4c64 <APP_LoginSystem+0x218>
				CLCD_voidWriteNumbers((*LOCAL_u8N));
				CLCD_voidGoto(2,1);
				CLCD_voidWriteString("Pass: ");
				if(Check_PassKeypad(LOCAL_u8NameAdd) == OK)
				{
					MotorFlag = 1;
    4f48:	81 e0       	ldi	r24, 0x01	; 1
    4f4a:	80 93 f2 07 	sts	0x07F2, r24
					CLCD_voidSendCommand(CLCD_CLEAR_DIISPLAY);
    4f4e:	0e 94 9f 11 	call	0x233e	; 0x233e <CLCD_voidSendCommand>
					CLCD_voidWriteString("Correct Pass ");
    4f52:	8b e9       	ldi	r24, 0x9B	; 155
    4f54:	95 e0       	ldi	r25, 0x05	; 5
    4f56:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
    4f5a:	28 e8       	ldi	r18, 0x88	; 136
    4f5c:	33 e1       	ldi	r19, 0x13	; 19
    4f5e:	48 ec       	ldi	r20, 0xC8	; 200
    4f60:	50 e0       	ldi	r21, 0x00	; 0
    4f62:	62 ce       	rjmp	.-828    	; 0x4c28 <APP_LoginSystem+0x1dc>
				Next = RSt2;
			}
		}
		else
		{
			transmitDataBlockOverBluetooth("Try again \n",12);
    4f64:	84 e7       	ldi	r24, 0x74	; 116
    4f66:	95 e0       	ldi	r25, 0x05	; 5
    4f68:	6c e0       	ldi	r22, 0x0C	; 12
    4f6a:	70 e0       	ldi	r23, 0x00	; 0
    4f6c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
			Next = RSt2;
    4f70:	87 e1       	ldi	r24, 0x17	; 23
    4f72:	80 93 06 08 	sts	0x0806, r24
    4f76:	c4 cf       	rjmp	.-120    	; 0x4f00 <APP_LoginSystem+0x4b4>

				transmitDataBlockOverBluetooth("Pass \n",7);

				if(Check_PassRemote(LOCAL_u8NameAdd) == OK)
				{
					MotorFlag = 1;
    4f78:	81 e0       	ldi	r24, 0x01	; 1
    4f7a:	80 93 f2 07 	sts	0x07F2, r24
					transmitDataBlockOverBluetooth("Correct Pass \n",15);
    4f7e:	89 ea       	ldi	r24, 0xA9	; 169
    4f80:	95 e0       	ldi	r25, 0x05	; 5
    4f82:	6f e0       	ldi	r22, 0x0F	; 15
    4f84:	70 e0       	ldi	r23, 0x00	; 0
    4f86:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
					Next = RSt4;
    4f8a:	89 e1       	ldi	r24, 0x19	; 25
    4f8c:	80 93 06 08 	sts	0x0806, r24
				else{
					transmitDataBlockOverBluetooth("Try again \n",12);
					Trial++;
				}
			}
			if(Trial ==3)
    4f90:	83 e0       	ldi	r24, 0x03	; 3
    4f92:	c8 16       	cp	r12, r24
    4f94:	09 f0       	breq	.+2      	; 0x4f98 <APP_LoginSystem+0x54c>
    4f96:	b4 cf       	rjmp	.-152    	; 0x4f00 <APP_LoginSystem+0x4b4>
    4f98:	16 cf       	rjmp	.-468    	; 0x4dc6 <APP_LoginSystem+0x37a>
				Next = RSt1;
			}
		}
		else
		{
			transmitDataBlockOverBluetooth("Try again \n",12);
    4f9a:	84 e7       	ldi	r24, 0x74	; 116
    4f9c:	95 e0       	ldi	r25, 0x05	; 5
    4f9e:	6c e0       	ldi	r22, 0x0C	; 12
    4fa0:	70 e0       	ldi	r23, 0x00	; 0
    4fa2:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
			Next = RSt1;
    4fa6:	86 e1       	ldi	r24, 0x16	; 22
    4fa8:	80 93 06 08 	sts	0x0806, r24
    4fac:	a9 cf       	rjmp	.-174    	; 0x4f00 <APP_LoginSystem+0x4b4>
				*LOCAL_u8N =0;

				transmitDataBlockOverBluetooth("Pass \n",7);
				if(Check_AdminPass(LOCAL_u8NameAdd) == OK)
				{
					MotorFlag = 1;
    4fae:	81 e0       	ldi	r24, 0x01	; 1
    4fb0:	80 93 f2 07 	sts	0x07F2, r24
					transmitDataBlockOverBluetooth("Correct Pass \n",15);
    4fb4:	89 ea       	ldi	r24, 0xA9	; 169
    4fb6:	95 e0       	ldi	r25, 0x05	; 5
    4fb8:	6f e0       	ldi	r22, 0x0F	; 15
    4fba:	70 e0       	ldi	r23, 0x00	; 0
    4fbc:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
					Next = RSt3;
    4fc0:	88 e1       	ldi	r24, 0x18	; 24
    4fc2:	80 93 06 08 	sts	0x0806, r24
				{
					transmitDataBlockOverBluetooth("Try again \n",12);
					Trial++;
				}
			}
			if(Trial ==3)
    4fc6:	83 e0       	ldi	r24, 0x03	; 3
    4fc8:	c8 16       	cp	r12, r24
    4fca:	09 f0       	breq	.+2      	; 0x4fce <APP_LoginSystem+0x582>
    4fcc:	99 cf       	rjmp	.-206    	; 0x4f00 <APP_LoginSystem+0x4b4>
    4fce:	93 cf       	rjmp	.-218    	; 0x4ef6 <APP_LoginSystem+0x4aa>
    4fd0:	ee 24       	eor	r14, r14
    4fd2:	ff 24       	eor	r15, r15
    4fd4:	05 ce       	rjmp	.-1014   	; 0x4be0 <APP_LoginSystem+0x194>
    4fd6:	00 e0       	ldi	r16, 0x00	; 0
    4fd8:	10 e0       	ldi	r17, 0x00	; 0
    4fda:	8c cd       	rjmp	.-1256   	; 0x4af4 <APP_LoginSystem+0xa8>
    4fdc:	71 01       	movw	r14, r2
    4fde:	c8 ce       	rjmp	.-624    	; 0x4d70 <APP_LoginSystem+0x324>
    4fe0:	09 e1       	ldi	r16, 0x19	; 25
    4fe2:	10 e0       	ldi	r17, 0x00	; 0
    4fe4:	64 ce       	rjmp	.-824    	; 0x4cae <APP_LoginSystem+0x262>
    4fe6:	71 01       	movw	r14, r2
    4fe8:	5b cf       	rjmp	.-330    	; 0x4ea0 <APP_LoginSystem+0x454>
			}
		}
	}
	for(LOCAL_u8Counter2 = 0; LOCAL_u8Counter2 < 1; LOCAL_u8Counter2++)
	{
		(*LOCAL_u8N)++;
    4fea:	80 91 f1 07 	lds	r24, 0x07F1
    4fee:	8f 5f       	subi	r24, 0xFF	; 255
    4ff0:	80 93 f1 07 	sts	0x07F1, r24
		if(LOCAL_u8Name == readDataFromEEPROM(LOCAL_u8Counter2 + EEPROM_ADDR_F_Admin))
    4ff4:	82 e3       	ldi	r24, 0x32	; 50
    4ff6:	90 e0       	ldi	r25, 0x00	; 0
    4ff8:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    4ffc:	90 e0       	ldi	r25, 0x00	; 0
    4ffe:	a0 e0       	ldi	r26, 0x00	; 0
    5000:	b0 e0       	ldi	r27, 0x00	; 0
    5002:	8c 15       	cp	r24, r12
    5004:	9d 05       	cpc	r25, r13
    5006:	ae 05       	cpc	r26, r14
    5008:	bf 05       	cpc	r27, r15
    500a:	39 f6       	brne	.-114    	; 0x4f9a <APP_LoginSystem+0x54e>
    500c:	03 cf       	rjmp	.-506    	; 0x4e14 <APP_LoginSystem+0x3c8>

0000500e <APP_StateTrans>:
	TIMER1_voidSetICR1(40000U);//START 180 THIS IS OVERFLOW VALUE & NEED COMPARE VALUE2
	_delay_ms(200);

}

state APP_StateTrans(state St){
    500e:	2f 92       	push	r2
    5010:	3f 92       	push	r3
    5012:	4f 92       	push	r4
    5014:	5f 92       	push	r5
    5016:	6f 92       	push	r6
    5018:	7f 92       	push	r7
    501a:	8f 92       	push	r8
    501c:	9f 92       	push	r9
    501e:	af 92       	push	r10
    5020:	bf 92       	push	r11
    5022:	cf 92       	push	r12
    5024:	df 92       	push	r13
    5026:	ef 92       	push	r14
    5028:	ff 92       	push	r15
    502a:	0f 93       	push	r16
    502c:	1f 93       	push	r17
    502e:	df 93       	push	r29
    5030:	cf 93       	push	r28
    5032:	00 d0       	rcall	.+0      	; 0x5034 <APP_StateTrans+0x26>
    5034:	00 d0       	rcall	.+0      	; 0x5036 <APP_StateTrans+0x28>
    5036:	0f 92       	push	r0
    5038:	cd b7       	in	r28, 0x3d	; 61
    503a:	de b7       	in	r29, 0x3e	; 62
    503c:	18 2f       	mov	r17, r24
	Local_u8Key = Keypad_u8GetPressed(Keypad_Array);
    503e:	89 eb       	ldi	r24, 0xB9	; 185
    5040:	97 e0       	ldi	r25, 0x07	; 7
    5042:	0e 94 b3 10 	call	0x2166	; 0x2166 <Keypad_u8GetPressed>
    5046:	80 93 fb 07 	sts	0x07FB, r24

	switch(St)
    504a:	e1 2f       	mov	r30, r17
    504c:	f0 e0       	ldi	r31, 0x00	; 0
    504e:	e4 34       	cpi	r30, 0x44	; 68
    5050:	f1 05       	cpc	r31, r1
    5052:	08 f0       	brcs	.+2      	; 0x5056 <APP_StateTrans+0x48>
    5054:	b0 c4       	rjmp	.+2400   	; 0x59b6 <APP_StateTrans+0x9a8>
    5056:	e6 5d       	subi	r30, 0xD6	; 214
    5058:	ff 4f       	sbci	r31, 0xFF	; 255
    505a:	ee 0f       	add	r30, r30
    505c:	ff 1f       	adc	r31, r31
    505e:	05 90       	lpm	r0, Z+
    5060:	f4 91       	lpm	r31, Z+
    5062:	e0 2d       	mov	r30, r0
    5064:	09 94       	ijmp
/*** Ahmed Ashraf___V1 ********************************************************  DONE**/
static state APP_Start_Choose_login(void)
{
	uint_8 read =1;
	uint_8 count=0;
	CLCD_voidGoto(2,5);
    5066:	82 e0       	ldi	r24, 0x02	; 2
    5068:	65 e0       	ldi	r22, 0x05	; 5
    506a:	0e 94 dc 11 	call	0x23b8	; 0x23b8 <CLCD_voidGoto>
	CLCD_voidWriteString("LOGIN...");
    506e:	88 eb       	ldi	r24, 0xB8	; 184
    5070:	95 e0       	ldi	r25, 0x05	; 5
    5072:	0e 94 7a 11 	call	0x22f4	; 0x22f4 <CLCD_voidWriteString>
	transmitDataBlockOverBluetooth("[1] Admin\n",11);
    5076:	81 ec       	ldi	r24, 0xC1	; 193
    5078:	95 e0       	ldi	r25, 0x05	; 5
    507a:	6b e0       	ldi	r22, 0x0B	; 11
    507c:	70 e0       	ldi	r23, 0x00	; 0
    507e:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
	transmitDataBlockOverBluetooth("[2] User",8);
    5082:	8c ec       	ldi	r24, 0xCC	; 204
    5084:	95 e0       	ldi	r25, 0x05	; 5
    5086:	68 e0       	ldi	r22, 0x08	; 8
    5088:	70 e0       	ldi	r23, 0x00	; 0
    508a:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		if(read == '1')
		{
			Next = RSt1;
			count =1;
		}
		else if(Keypad_u8GetPressed(Keypad_Array) == 'K')
    508e:	0f 2e       	mov	r0, r31
    5090:	f9 eb       	ldi	r31, 0xB9	; 185
    5092:	ef 2e       	mov	r14, r31
    5094:	f7 e0       	ldi	r31, 0x07	; 7
    5096:	ff 2e       	mov	r15, r31
    5098:	f0 2d       	mov	r31, r0
			{
				Next = RSt2;
			}
			else
			{
				Next = RSt0;
    509a:	dd 24       	eor	r13, r13
			{
				Next = ESt0;
			}
			else
			{
				Next = RSt0;
    509c:	0f 2e       	mov	r0, r31
    509e:	f5 e1       	ldi	r31, 0x15	; 21
    50a0:	bf 2e       	mov	r11, r31
    50a2:	f0 2d       	mov	r31, r0
    50a4:	cc 24       	eor	r12, r12
    50a6:	c3 94       	inc	r12
	transmitDataBlockOverBluetooth("[1] Admin\n",11);
	transmitDataBlockOverBluetooth("[2] User",8);
	//read = UART_ReceiveCharfrist();
	while((read || Keypad_u8GetPressed(Keypad_Array) == 'K') && ! count)
	{
		read = UART_ReceiveCharfrist();
    50a8:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    50ac:	18 2f       	mov	r17, r24
		if(read == '1')
    50ae:	81 33       	cpi	r24, 0x31	; 49
    50b0:	21 f4       	brne	.+8      	; 0x50ba <APP_StateTrans+0xac>
		{
			Next = RSt1;
    50b2:	86 e1       	ldi	r24, 0x16	; 22
    50b4:	80 93 06 08 	sts	0x0806, r24
    50b8:	7e c4       	rjmp	.+2300   	; 0x59b6 <APP_StateTrans+0x9a8>
			count =1;
		}
		else if(Keypad_u8GetPressed(Keypad_Array) == 'K')
    50ba:	c7 01       	movw	r24, r14
    50bc:	0e 94 b3 10 	call	0x2166	; 0x2166 <Keypad_u8GetPressed>
    50c0:	8b 34       	cpi	r24, 0x4B	; 75
    50c2:	71 f4       	brne	.+28     	; 0x50e0 <APP_StateTrans+0xd2>
		{
			if(readDataFromEEPROM(EEPROM_ADDR_COUNTER_KU) <= 4)
    50c4:	80 e4       	ldi	r24, 0x40	; 64
    50c6:	90 e0       	ldi	r25, 0x00	; 0
    50c8:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    50cc:	85 30       	cpi	r24, 0x05	; 5
    50ce:	20 f4       	brcc	.+8      	; 0x50d8 <APP_StateTrans+0xca>
			{
				Next = ESt0;
    50d0:	d0 92 06 08 	sts	0x0806, r13
    50d4:	0c 2d       	mov	r16, r12
    50d6:	15 c0       	rjmp	.+42     	; 0x5102 <APP_StateTrans+0xf4>
			}
			else
			{
				Next = RSt0;
    50d8:	b0 92 06 08 	sts	0x0806, r11
    50dc:	0c 2d       	mov	r16, r12
    50de:	11 c0       	rjmp	.+34     	; 0x5102 <APP_StateTrans+0xf4>
			}
			count =1;
		}
		else if(read == '2')
    50e0:	12 33       	cpi	r17, 0x32	; 50
    50e2:	71 f4       	brne	.+28     	; 0x5100 <APP_StateTrans+0xf2>
		{
			if(readDataFromEEPROM(EEPROM_ADDR_COUNTER_RU) <= 4)
    50e4:	81 e4       	ldi	r24, 0x41	; 65
    50e6:	90 e0       	ldi	r25, 0x00	; 0
    50e8:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    50ec:	85 30       	cpi	r24, 0x05	; 5
    50ee:	20 f4       	brcc	.+8      	; 0x50f8 <APP_StateTrans+0xea>
			{
				Next = RSt2;
    50f0:	87 e1       	ldi	r24, 0x17	; 23
    50f2:	80 93 06 08 	sts	0x0806, r24
    50f6:	5f c4       	rjmp	.+2238   	; 0x59b6 <APP_StateTrans+0x9a8>
			}
			else
			{
				Next = RSt0;
    50f8:	85 e1       	ldi	r24, 0x15	; 21
    50fa:	80 93 06 08 	sts	0x0806, r24
    50fe:	5b c4       	rjmp	.+2230   	; 0x59b6 <APP_StateTrans+0x9a8>
    5100:	0d 2d       	mov	r16, r13
	CLCD_voidGoto(2,5);
	CLCD_voidWriteString("LOGIN...");
	transmitDataBlockOverBluetooth("[1] Admin\n",11);
	transmitDataBlockOverBluetooth("[2] User",8);
	//read = UART_ReceiveCharfrist();
	while((read || Keypad_u8GetPressed(Keypad_Array) == 'K') && ! count)
    5102:	11 23       	and	r17, r17
    5104:	31 f4       	brne	.+12     	; 0x5112 <APP_StateTrans+0x104>
    5106:	c7 01       	movw	r24, r14
    5108:	0e 94 b3 10 	call	0x2166	; 0x2166 <Keypad_u8GetPressed>
    510c:	8b 34       	cpi	r24, 0x4B	; 75
    510e:	09 f0       	breq	.+2      	; 0x5112 <APP_StateTrans+0x104>
    5110:	52 c4       	rjmp	.+2212   	; 0x59b6 <APP_StateTrans+0x9a8>
    5112:	00 23       	and	r16, r16
    5114:	49 f2       	breq	.-110    	; 0x50a8 <APP_StateTrans+0x9a>
    5116:	4f c4       	rjmp	.+2206   	; 0x59b6 <APP_StateTrans+0x9a8>
	{
	case RSt0 :
		Next = APP_Start_Choose_login();
		break;
	case ESt0 :
		Next = APP_LoginSystem(User_Keypad);
    5118:	80 e0       	ldi	r24, 0x00	; 0
    511a:	0e 94 26 25 	call	0x4a4c	; 0x4a4c <APP_LoginSystem>
    511e:	80 93 06 08 	sts	0x0806, r24
    5122:	49 c4       	rjmp	.+2194   	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt1 :
		Next = APP_LoginSystem(Admin);
    5124:	82 e0       	ldi	r24, 0x02	; 2
    5126:	0e 94 26 25 	call	0x4a4c	; 0x4a4c <APP_LoginSystem>
    512a:	80 93 06 08 	sts	0x0806, r24
    512e:	43 c4       	rjmp	.+2182   	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt2 :
		Next = APP_LoginSystem(User_Remote);
    5130:	81 e0       	ldi	r24, 0x01	; 1
    5132:	0e 94 26 25 	call	0x4a4c	; 0x4a4c <APP_LoginSystem>
    5136:	80 93 06 08 	sts	0x0806, r24
    513a:	3d c4       	rjmp	.+2170   	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt1 :
		Next = APP_HomePageMode(User_Keypad);
    513c:	80 e0       	ldi	r24, 0x00	; 0
    513e:	0e 94 c5 14 	call	0x298a	; 0x298a <APP_HomePageMode>
    5142:	80 93 06 08 	sts	0x0806, r24
    5146:	37 c4       	rjmp	.+2158   	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt3 :
		Next =  APP_HomePageMode(Admin);
    5148:	82 e0       	ldi	r24, 0x02	; 2
    514a:	0e 94 c5 14 	call	0x298a	; 0x298a <APP_HomePageMode>
    514e:	80 93 06 08 	sts	0x0806, r24
    5152:	31 c4       	rjmp	.+2146   	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt4 :
		Next = APP_HomePageMode(User_Remote);
    5154:	81 e0       	ldi	r24, 0x01	; 1
    5156:	0e 94 c5 14 	call	0x298a	; 0x298a <APP_HomePageMode>
    515a:	80 93 06 08 	sts	0x0806, r24
    515e:	2b c4       	rjmp	.+2134   	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt2 :
		Next = APP_StatusMenu(User_Keypad);
    5160:	80 e0       	ldi	r24, 0x00	; 0
    5162:	0e 94 97 16 	call	0x2d2e	; 0x2d2e <APP_StatusMenu>
    5166:	80 93 06 08 	sts	0x0806, r24
    516a:	25 c4       	rjmp	.+2122   	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt3 :
		Next = APP_ControlMenu(User_Keypad);
    516c:	80 e0       	ldi	r24, 0x00	; 0
    516e:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <APP_ControlMenu>
    5172:	80 93 06 08 	sts	0x0806, r24
    5176:	1f c4       	rjmp	.+2110   	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt5 :
		Next = APP_ControlMenu(Admin);
    5178:	82 e0       	ldi	r24, 0x02	; 2
    517a:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <APP_ControlMenu>
    517e:	80 93 06 08 	sts	0x0806, r24
    5182:	19 c4       	rjmp	.+2098   	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt6 :
		Next = APP_StatusMenu(Admin);
    5184:	82 e0       	ldi	r24, 0x02	; 2
    5186:	0e 94 97 16 	call	0x2d2e	; 0x2d2e <APP_StatusMenu>
    518a:	80 93 06 08 	sts	0x0806, r24
    518e:	13 c4       	rjmp	.+2086   	; 0x59b6 <APP_StateTrans+0x9a8>
	return Next;
}
/*** Ahmed Ashraf___V1 ********************************************************  **/
static state APP_Admin_ADD_User(void)
{
	volatile uint_8 ReadUserKeypad = readDataFromEEPROM(EEPROM_ADDR_COUNTER_KU);
    5190:	80 e4       	ldi	r24, 0x40	; 64
    5192:	90 e0       	ldi	r25, 0x00	; 0
    5194:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    5198:	8b 83       	std	Y+3, r24	; 0x03
	volatile uint_8 ReadUserReomte = readDataFromEEPROM(EEPROM_ADDR_COUNTER_RU);
    519a:	81 e4       	ldi	r24, 0x41	; 65
    519c:	90 e0       	ldi	r25, 0x00	; 0
    519e:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    51a2:	8a 83       	std	Y+2, r24	; 0x02
	volatile static uint_8 count =0;
	volatile uint_8  Read =0;
    51a4:	19 82       	std	Y+1, r1	; 0x01
	transmitDataBlockOverBluetooth("[1]Keypad User\n",16);
    51a6:	85 ed       	ldi	r24, 0xD5	; 213
    51a8:	95 e0       	ldi	r25, 0x05	; 5
    51aa:	60 e1       	ldi	r22, 0x10	; 16
    51ac:	70 e0       	ldi	r23, 0x00	; 0
    51ae:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
	transmitDataBlockOverBluetooth("[2]Remote User\n",16);
    51b2:	85 ee       	ldi	r24, 0xE5	; 229
    51b4:	95 e0       	ldi	r25, 0x05	; 5
    51b6:	60 e1       	ldi	r22, 0x10	; 16
    51b8:	70 e0       	ldi	r23, 0x00	; 0
    51ba:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
	transmitDataBlockOverBluetooth("[3]Back\n",9);
    51be:	85 ef       	ldi	r24, 0xF5	; 245
    51c0:	95 e0       	ldi	r25, 0x05	; 5
    51c2:	69 e0       	ldi	r22, 0x09	; 9
    51c4:	70 e0       	ldi	r23, 0x00	; 0
    51c6:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
	transmitDataBlockOverBluetooth("[4]Main\n",9);
    51ca:	8e ef       	ldi	r24, 0xFE	; 254
    51cc:	95 e0       	ldi	r25, 0x05	; 5
    51ce:	69 e0       	ldi	r22, 0x09	; 9
    51d0:	70 e0       	ldi	r23, 0x00	; 0
    51d2:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				transmitDataBlockOverBluetooth("you have 5 Keypad Users\n",25);
				Next = RSt7;
			}
			break;
		case '2':
			if((ReadUserReomte == 0xff)  || ((ReadUserReomte < 4)))
    51d6:	dd 24       	eor	r13, r13
    51d8:	0f 2e       	mov	r0, r31
    51da:	f9 e1       	ldi	r31, 0x19	; 25
    51dc:	af 2e       	mov	r10, r31
    51de:	bb 24       	eor	r11, r11
    51e0:	f0 2d       	mov	r31, r0
					if( 0xff == readDataFromEEPROM( (cou * 5) + EEPROM_ADDR_F_UsersRemote))
					{
						break;
					}
				}
				transmitDataBlockOverBluetooth("User Name\n",11);
    51e2:	0f 2e       	mov	r0, r31
    51e4:	f7 e0       	ldi	r31, 0x07	; 7
    51e6:	8f 2e       	mov	r8, r31
    51e8:	f6 e0       	ldi	r31, 0x06	; 6
    51ea:	9f 2e       	mov	r9, r31
    51ec:	f0 2d       	mov	r31, r0
					APP_SystemState();
					APP_TEMP_MOTOR();
					Read = UART_ReceiveCharfrist();
					if((Read >= '0')&&( Read <= '9'))
					{
						eeprom_write_byte(((uint_8*)(cou *5) + EEPROM_ADDR_F_UsersRemote), Read -'0' );
    51ee:	0f 2e       	mov	r0, r31
    51f0:	f5 e0       	ldi	r31, 0x05	; 5
    51f2:	5f 2e       	mov	r5, r31
    51f4:	f0 2d       	mov	r31, r0
						count++;
					}
				}
				transmitDataBlockOverBluetooth("Pass\n",6);
    51f6:	0f 2e       	mov	r0, r31
    51f8:	f2 e1       	ldi	r31, 0x12	; 18
    51fa:	6f 2e       	mov	r6, r31
    51fc:	f6 e0       	ldi	r31, 0x06	; 6
    51fe:	7f 2e       	mov	r7, r31
    5200:	f0 2d       	mov	r31, r0
				count = 1;
    5202:	44 24       	eor	r4, r4
    5204:	43 94       	inc	r4
						count++;
					}
				}
				ReadUserReomte++;
				eeprom_write_byte((uint_8*)EEPROM_ADDR_COUNTER_RU, ReadUserReomte);
				Next = RSt7;
    5206:	0f 2e       	mov	r0, r31
    5208:	fc e1       	ldi	r31, 0x1C	; 28
    520a:	cf 2e       	mov	r12, r31
    520c:	f0 2d       	mov	r31, r0
				Next = RSt7;
			}
			cou=0;
			break;
		case '3':
			Next = RSt3;
    520e:	0f 2e       	mov	r0, r31
    5210:	f8 e1       	ldi	r31, 0x18	; 24
    5212:	3f 2e       	mov	r3, r31
    5214:	f0 2d       	mov	r31, r0
    5216:	0e c1       	rjmp	.+540    	; 0x5434 <APP_StateTrans+0x426>
	transmitDataBlockOverBluetooth("[2]Remote User\n",16);
	transmitDataBlockOverBluetooth("[3]Back\n",9);
	transmitDataBlockOverBluetooth("[4]Main\n",9);
	uint_8 cou=0;
	while(!((Read >='0')&&(Read <='9'))){
		APP_SystemState();
    5218:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
		APP_TEMP_MOTOR();
    521c:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
		Read = UART_ReceiveCharfrist();
    5220:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    5224:	89 83       	std	Y+1, r24	; 0x01
		switch(Read)
    5226:	89 81       	ldd	r24, Y+1	; 0x01
    5228:	82 33       	cpi	r24, 0x32	; 50
    522a:	09 f4       	brne	.+2      	; 0x522e <APP_StateTrans+0x220>
    522c:	86 c0       	rjmp	.+268    	; 0x533a <APP_StateTrans+0x32c>
    522e:	83 33       	cpi	r24, 0x33	; 51
    5230:	20 f4       	brcc	.+8      	; 0x523a <APP_StateTrans+0x22c>
    5232:	81 33       	cpi	r24, 0x31	; 49
    5234:	09 f0       	breq	.+2      	; 0x5238 <APP_StateTrans+0x22a>
    5236:	fe c0       	rjmp	.+508    	; 0x5434 <APP_StateTrans+0x426>
    5238:	07 c0       	rjmp	.+14     	; 0x5248 <APP_StateTrans+0x23a>
    523a:	83 33       	cpi	r24, 0x33	; 51
    523c:	09 f4       	brne	.+2      	; 0x5240 <APP_StateTrans+0x232>
    523e:	f5 c0       	rjmp	.+490    	; 0x542a <APP_StateTrans+0x41c>
    5240:	84 33       	cpi	r24, 0x34	; 52
    5242:	09 f0       	breq	.+2      	; 0x5246 <APP_StateTrans+0x238>
    5244:	f7 c0       	rjmp	.+494    	; 0x5434 <APP_StateTrans+0x426>
    5246:	f4 c0       	rjmp	.+488    	; 0x5430 <APP_StateTrans+0x422>
		{
		case '1':
			if((ReadUserKeypad == 0xff)  || ((ReadUserKeypad < 4)))
    5248:	8b 81       	ldd	r24, Y+3	; 0x03
    524a:	8f 3f       	cpi	r24, 0xFF	; 255
    524c:	21 f0       	breq	.+8      	; 0x5256 <APP_StateTrans+0x248>
    524e:	8b 81       	ldd	r24, Y+3	; 0x03
    5250:	84 30       	cpi	r24, 0x04	; 4
    5252:	08 f0       	brcs	.+2      	; 0x5256 <APP_StateTrans+0x248>
    5254:	6a c0       	rjmp	.+212    	; 0x532a <APP_StateTrans+0x31c>
    5256:	fd 2c       	mov	r15, r13
    5258:	00 e0       	ldi	r16, 0x00	; 0
    525a:	10 e0       	ldi	r17, 0x00	; 0
			{
				for(cou = 0; cou < 5; cou++)
				{
					if( 0xff == readDataFromEEPROM( (cou * 5) + EEPROM_ADDR_F_UsersKeypad))
    525c:	c8 01       	movw	r24, r16
    525e:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    5262:	8f 3f       	cpi	r24, 0xFF	; 255
    5264:	31 f0       	breq	.+12     	; 0x5272 <APP_StateTrans+0x264>
		switch(Read)
		{
		case '1':
			if((ReadUserKeypad == 0xff)  || ((ReadUserKeypad < 4)))
			{
				for(cou = 0; cou < 5; cou++)
    5266:	f3 94       	inc	r15
    5268:	0b 5f       	subi	r16, 0xFB	; 251
    526a:	1f 4f       	sbci	r17, 0xFF	; 255
    526c:	25 e0       	ldi	r18, 0x05	; 5
    526e:	f2 16       	cp	r15, r18
    5270:	a9 f7       	brne	.-22     	; 0x525c <APP_StateTrans+0x24e>
					if( 0xff == readDataFromEEPROM( (cou * 5) + EEPROM_ADDR_F_UsersKeypad))
					{
						break;
					}
				}
				transmitDataBlockOverBluetooth("User Name\n",11);
    5272:	c4 01       	movw	r24, r8
    5274:	6b e0       	ldi	r22, 0x0B	; 11
    5276:	70 e0       	ldi	r23, 0x00	; 0
    5278:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				count=0;
    527c:	d0 92 04 08 	sts	0x0804, r13
					APP_SystemState();
					APP_TEMP_MOTOR();
					Read = UART_ReceiveCharfrist();
					if((Read >= '0')&&( Read <= '9'))
					{
						eeprom_write_byte(((uint_8*)(cou *5) + EEPROM_ADDR_F_UsersKeypad), Read -'0' );
    5280:	f5 9c       	mul	r15, r5
    5282:	80 01       	movw	r16, r0
    5284:	11 24       	eor	r1, r1
    5286:	e0 2e       	mov	r14, r16
    5288:	f1 2e       	mov	r15, r17
    528a:	18 c0       	rjmp	.+48     	; 0x52bc <APP_StateTrans+0x2ae>
				}
				transmitDataBlockOverBluetooth("User Name\n",11);
				count=0;
				while(count < 1)
				{
					APP_SystemState();
    528c:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
					APP_TEMP_MOTOR();
    5290:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
					Read = UART_ReceiveCharfrist();
    5294:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    5298:	89 83       	std	Y+1, r24	; 0x01
					if((Read >= '0')&&( Read <= '9'))
    529a:	89 81       	ldd	r24, Y+1	; 0x01
    529c:	80 33       	cpi	r24, 0x30	; 48
    529e:	70 f0       	brcs	.+28     	; 0x52bc <APP_StateTrans+0x2ae>
    52a0:	89 81       	ldd	r24, Y+1	; 0x01
    52a2:	8a 33       	cpi	r24, 0x3A	; 58
    52a4:	58 f4       	brcc	.+22     	; 0x52bc <APP_StateTrans+0x2ae>
					{
						eeprom_write_byte(((uint_8*)(cou *5) + EEPROM_ADDR_F_UsersKeypad), Read -'0' );
    52a6:	69 81       	ldd	r22, Y+1	; 0x01
    52a8:	60 53       	subi	r22, 0x30	; 48
    52aa:	8e 2d       	mov	r24, r14
    52ac:	9f 2d       	mov	r25, r15
    52ae:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
						count++;
    52b2:	80 91 04 08 	lds	r24, 0x0804
    52b6:	8f 5f       	subi	r24, 0xFF	; 255
    52b8:	80 93 04 08 	sts	0x0804, r24
						break;
					}
				}
				transmitDataBlockOverBluetooth("User Name\n",11);
				count=0;
				while(count < 1)
    52bc:	80 91 04 08 	lds	r24, 0x0804
    52c0:	88 23       	and	r24, r24
    52c2:	21 f3       	breq	.-56     	; 0x528c <APP_StateTrans+0x27e>
					{
						eeprom_write_byte(((uint_8*)(cou *5) + EEPROM_ADDR_F_UsersKeypad), Read -'0' );
						count++;
					}
				}
				transmitDataBlockOverBluetooth("Pass\n",6);
    52c4:	c3 01       	movw	r24, r6
    52c6:	66 e0       	ldi	r22, 0x06	; 6
    52c8:	70 e0       	ldi	r23, 0x00	; 0
    52ca:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				count = 1;
    52ce:	40 92 04 08 	sts	0x0804, r4
    52d2:	1c c0       	rjmp	.+56     	; 0x530c <APP_StateTrans+0x2fe>
				while((count < 5))
				{
					APP_SystemState();
    52d4:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
					APP_TEMP_MOTOR();
    52d8:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
					Read = UART_ReceiveCharfrist();
    52dc:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    52e0:	89 83       	std	Y+1, r24	; 0x01
					if((Read >= '0')&&( Read <= '9'))
    52e2:	89 81       	ldd	r24, Y+1	; 0x01
    52e4:	80 33       	cpi	r24, 0x30	; 48
    52e6:	90 f0       	brcs	.+36     	; 0x530c <APP_StateTrans+0x2fe>
    52e8:	89 81       	ldd	r24, Y+1	; 0x01
    52ea:	8a 33       	cpi	r24, 0x3A	; 58
    52ec:	78 f4       	brcc	.+30     	; 0x530c <APP_StateTrans+0x2fe>
					{
						eeprom_write_byte((uint_8*)(((cou *5)+ EEPROM_ADDR_F_UsersKeypad) +count), Read - '0');
    52ee:	80 91 04 08 	lds	r24, 0x0804
    52f2:	69 81       	ldd	r22, Y+1	; 0x01
    52f4:	60 53       	subi	r22, 0x30	; 48
    52f6:	98 01       	movw	r18, r16
    52f8:	28 0f       	add	r18, r24
    52fa:	31 1d       	adc	r19, r1
    52fc:	c9 01       	movw	r24, r18
    52fe:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
						count++;
    5302:	80 91 04 08 	lds	r24, 0x0804
    5306:	8f 5f       	subi	r24, 0xFF	; 255
    5308:	80 93 04 08 	sts	0x0804, r24
						count++;
					}
				}
				transmitDataBlockOverBluetooth("Pass\n",6);
				count = 1;
				while((count < 5))
    530c:	80 91 04 08 	lds	r24, 0x0804
    5310:	85 30       	cpi	r24, 0x05	; 5
    5312:	00 f3       	brcs	.-64     	; 0x52d4 <APP_StateTrans+0x2c6>
						eeprom_write_byte((uint_8*)(((cou *5)+ EEPROM_ADDR_F_UsersKeypad) +count), Read - '0');
						count++;
					}
				}

				ReadUserKeypad++;
    5314:	8b 81       	ldd	r24, Y+3	; 0x03
    5316:	8f 5f       	subi	r24, 0xFF	; 255
    5318:	8b 83       	std	Y+3, r24	; 0x03
				eeprom_write_byte((uint_8*)EEPROM_ADDR_COUNTER_KU, ReadUserKeypad);
    531a:	6b 81       	ldd	r22, Y+3	; 0x03
    531c:	80 e4       	ldi	r24, 0x40	; 64
    531e:	90 e0       	ldi	r25, 0x00	; 0
    5320:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
				cou=0;
				Next = RSt7;
    5324:	c0 92 06 08 	sts	0x0806, r12
    5328:	85 c0       	rjmp	.+266    	; 0x5434 <APP_StateTrans+0x426>
			}
			else
			{
				transmitDataBlockOverBluetooth("you have 5 Keypad Users\n",25);
    532a:	88 e1       	ldi	r24, 0x18	; 24
    532c:	96 e0       	ldi	r25, 0x06	; 6
    532e:	b5 01       	movw	r22, r10
    5330:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				Next = RSt7;
    5334:	c0 92 06 08 	sts	0x0806, r12
    5338:	7d c0       	rjmp	.+250    	; 0x5434 <APP_StateTrans+0x426>
			}
			break;
		case '2':
			if((ReadUserReomte == 0xff)  || ((ReadUserReomte < 4)))
    533a:	8a 81       	ldd	r24, Y+2	; 0x02
    533c:	8f 3f       	cpi	r24, 0xFF	; 255
    533e:	21 f0       	breq	.+8      	; 0x5348 <APP_StateTrans+0x33a>
    5340:	8a 81       	ldd	r24, Y+2	; 0x02
    5342:	84 30       	cpi	r24, 0x04	; 4
    5344:	08 f0       	brcs	.+2      	; 0x5348 <APP_StateTrans+0x33a>
    5346:	69 c0       	rjmp	.+210    	; 0x541a <APP_StateTrans+0x40c>
    5348:	fd 2c       	mov	r15, r13
    534a:	85 01       	movw	r16, r10
			{
				for(cou = 0; cou < 5; cou++)
				{
					if( 0xff == readDataFromEEPROM( (cou * 5) + EEPROM_ADDR_F_UsersRemote))
    534c:	c8 01       	movw	r24, r16
    534e:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    5352:	8f 3f       	cpi	r24, 0xFF	; 255
    5354:	31 f0       	breq	.+12     	; 0x5362 <APP_StateTrans+0x354>
			}
			break;
		case '2':
			if((ReadUserReomte == 0xff)  || ((ReadUserReomte < 4)))
			{
				for(cou = 0; cou < 5; cou++)
    5356:	f3 94       	inc	r15
    5358:	0b 5f       	subi	r16, 0xFB	; 251
    535a:	1f 4f       	sbci	r17, 0xFF	; 255
    535c:	35 e0       	ldi	r19, 0x05	; 5
    535e:	f3 16       	cp	r15, r19
    5360:	a9 f7       	brne	.-22     	; 0x534c <APP_StateTrans+0x33e>
					if( 0xff == readDataFromEEPROM( (cou * 5) + EEPROM_ADDR_F_UsersRemote))
					{
						break;
					}
				}
				transmitDataBlockOverBluetooth("User Name\n",11);
    5362:	c4 01       	movw	r24, r8
    5364:	6b e0       	ldi	r22, 0x0B	; 11
    5366:	70 e0       	ldi	r23, 0x00	; 0
    5368:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				count=0;
    536c:	d0 92 04 08 	sts	0x0804, r13
					APP_SystemState();
					APP_TEMP_MOTOR();
					Read = UART_ReceiveCharfrist();
					if((Read >= '0')&&( Read <= '9'))
					{
						eeprom_write_byte(((uint_8*)(cou *5) + EEPROM_ADDR_F_UsersRemote), Read -'0' );
    5370:	f5 9c       	mul	r15, r5
    5372:	70 01       	movw	r14, r0
    5374:	11 24       	eor	r1, r1
    5376:	87 01       	movw	r16, r14
    5378:	07 5e       	subi	r16, 0xE7	; 231
    537a:	1f 4f       	sbci	r17, 0xFF	; 255
    537c:	17 c0       	rjmp	.+46     	; 0x53ac <APP_StateTrans+0x39e>
				}
				transmitDataBlockOverBluetooth("User Name\n",11);
				count=0;
				while(count < 1)
				{
					APP_SystemState();
    537e:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
					APP_TEMP_MOTOR();
    5382:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
					Read = UART_ReceiveCharfrist();
    5386:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    538a:	89 83       	std	Y+1, r24	; 0x01
					if((Read >= '0')&&( Read <= '9'))
    538c:	89 81       	ldd	r24, Y+1	; 0x01
    538e:	80 33       	cpi	r24, 0x30	; 48
    5390:	68 f0       	brcs	.+26     	; 0x53ac <APP_StateTrans+0x39e>
    5392:	89 81       	ldd	r24, Y+1	; 0x01
    5394:	8a 33       	cpi	r24, 0x3A	; 58
    5396:	50 f4       	brcc	.+20     	; 0x53ac <APP_StateTrans+0x39e>
					{
						eeprom_write_byte(((uint_8*)(cou *5) + EEPROM_ADDR_F_UsersRemote), Read -'0' );
    5398:	69 81       	ldd	r22, Y+1	; 0x01
    539a:	60 53       	subi	r22, 0x30	; 48
    539c:	c8 01       	movw	r24, r16
    539e:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
						count++;
    53a2:	80 91 04 08 	lds	r24, 0x0804
    53a6:	8f 5f       	subi	r24, 0xFF	; 255
    53a8:	80 93 04 08 	sts	0x0804, r24
						break;
					}
				}
				transmitDataBlockOverBluetooth("User Name\n",11);
				count=0;
				while(count < 1)
    53ac:	80 91 04 08 	lds	r24, 0x0804
    53b0:	88 23       	and	r24, r24
    53b2:	29 f3       	breq	.-54     	; 0x537e <APP_StateTrans+0x370>
					{
						eeprom_write_byte(((uint_8*)(cou *5) + EEPROM_ADDR_F_UsersRemote), Read -'0' );
						count++;
					}
				}
				transmitDataBlockOverBluetooth("Pass\n",6);
    53b4:	c3 01       	movw	r24, r6
    53b6:	66 e0       	ldi	r22, 0x06	; 6
    53b8:	70 e0       	ldi	r23, 0x00	; 0
    53ba:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				count = 1;
    53be:	40 92 04 08 	sts	0x0804, r4
    53c2:	1c c0       	rjmp	.+56     	; 0x53fc <APP_StateTrans+0x3ee>
				while((count < 5))
				{
					APP_SystemState();
    53c4:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
					APP_TEMP_MOTOR();
    53c8:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
					Read = UART_ReceiveCharfrist();
    53cc:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    53d0:	89 83       	std	Y+1, r24	; 0x01
					if((Read >= '0')&&( Read <= '9'))
    53d2:	89 81       	ldd	r24, Y+1	; 0x01
    53d4:	80 33       	cpi	r24, 0x30	; 48
    53d6:	90 f0       	brcs	.+36     	; 0x53fc <APP_StateTrans+0x3ee>
    53d8:	89 81       	ldd	r24, Y+1	; 0x01
    53da:	8a 33       	cpi	r24, 0x3A	; 58
    53dc:	78 f4       	brcc	.+30     	; 0x53fc <APP_StateTrans+0x3ee>
					{
						eeprom_write_byte((uint_8*)(((cou *5)+ EEPROM_ADDR_F_UsersRemote) +count), Read - '0');
    53de:	80 91 04 08 	lds	r24, 0x0804
    53e2:	69 81       	ldd	r22, Y+1	; 0x01
    53e4:	90 e0       	ldi	r25, 0x00	; 0
    53e6:	49 96       	adiw	r24, 0x19	; 25
    53e8:	60 53       	subi	r22, 0x30	; 48
    53ea:	8e 0d       	add	r24, r14
    53ec:	9f 1d       	adc	r25, r15
    53ee:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
						count++;
    53f2:	80 91 04 08 	lds	r24, 0x0804
    53f6:	8f 5f       	subi	r24, 0xFF	; 255
    53f8:	80 93 04 08 	sts	0x0804, r24
						count++;
					}
				}
				transmitDataBlockOverBluetooth("Pass\n",6);
				count = 1;
				while((count < 5))
    53fc:	80 91 04 08 	lds	r24, 0x0804
    5400:	85 30       	cpi	r24, 0x05	; 5
    5402:	00 f3       	brcs	.-64     	; 0x53c4 <APP_StateTrans+0x3b6>
					{
						eeprom_write_byte((uint_8*)(((cou *5)+ EEPROM_ADDR_F_UsersRemote) +count), Read - '0');
						count++;
					}
				}
				ReadUserReomte++;
    5404:	8a 81       	ldd	r24, Y+2	; 0x02
    5406:	8f 5f       	subi	r24, 0xFF	; 255
    5408:	8a 83       	std	Y+2, r24	; 0x02
				eeprom_write_byte((uint_8*)EEPROM_ADDR_COUNTER_RU, ReadUserReomte);
    540a:	6a 81       	ldd	r22, Y+2	; 0x02
    540c:	81 e4       	ldi	r24, 0x41	; 65
    540e:	90 e0       	ldi	r25, 0x00	; 0
    5410:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
				Next = RSt7;
    5414:	c0 92 06 08 	sts	0x0806, r12
    5418:	0d c0       	rjmp	.+26     	; 0x5434 <APP_StateTrans+0x426>
			}
			else
			{
				transmitDataBlockOverBluetooth("you have 5 Remote Users\n",25);
    541a:	81 e3       	ldi	r24, 0x31	; 49
    541c:	96 e0       	ldi	r25, 0x06	; 6
    541e:	b5 01       	movw	r22, r10
    5420:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				Next = RSt7;
    5424:	c0 92 06 08 	sts	0x0806, r12
    5428:	05 c0       	rjmp	.+10     	; 0x5434 <APP_StateTrans+0x426>
			}
			cou=0;
			break;
		case '3':
			Next = RSt3;
    542a:	30 92 06 08 	sts	0x0806, r3
    542e:	02 c0       	rjmp	.+4      	; 0x5434 <APP_StateTrans+0x426>
			break;
		case '4':
			Next = RSt3;
    5430:	30 92 06 08 	sts	0x0806, r3
	transmitDataBlockOverBluetooth("[1]Keypad User\n",16);
	transmitDataBlockOverBluetooth("[2]Remote User\n",16);
	transmitDataBlockOverBluetooth("[3]Back\n",9);
	transmitDataBlockOverBluetooth("[4]Main\n",9);
	uint_8 cou=0;
	while(!((Read >='0')&&(Read <='9'))){
    5434:	89 81       	ldd	r24, Y+1	; 0x01
    5436:	80 33       	cpi	r24, 0x30	; 48
    5438:	08 f4       	brcc	.+2      	; 0x543c <APP_StateTrans+0x42e>
    543a:	ee ce       	rjmp	.-548    	; 0x5218 <APP_StateTrans+0x20a>
    543c:	89 81       	ldd	r24, Y+1	; 0x01
    543e:	8a 33       	cpi	r24, 0x3A	; 58
    5440:	08 f0       	brcs	.+2      	; 0x5444 <APP_StateTrans+0x436>
    5442:	ea ce       	rjmp	.-556    	; 0x5218 <APP_StateTrans+0x20a>
    5444:	b8 c2       	rjmp	.+1392   	; 0x59b6 <APP_StateTrans+0x9a8>
}

static state APP_Admin_Remove_User(void)
{

	volatile uint_8 ReadUserKeypad = readDataFromEEPROM(EEPROM_ADDR_COUNTER_KU);
    5446:	80 e4       	ldi	r24, 0x40	; 64
    5448:	90 e0       	ldi	r25, 0x00	; 0
    544a:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    544e:	89 83       	std	Y+1, r24	; 0x01
	volatile uint_8 ReadUserReomte = readDataFromEEPROM(EEPROM_ADDR_COUNTER_RU);
    5450:	81 e4       	ldi	r24, 0x41	; 65
    5452:	90 e0       	ldi	r25, 0x00	; 0
    5454:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    5458:	8a 83       	std	Y+2, r24	; 0x02
	volatile static uint_8 count =0;
	volatile uint_8  Read =0;
    545a:	1b 82       	std	Y+3, r1	; 0x03
	uint_8 cou =0;
	transmitDataBlockOverBluetooth("[1]Keypad User\n",16);
    545c:	85 ed       	ldi	r24, 0xD5	; 213
    545e:	95 e0       	ldi	r25, 0x05	; 5
    5460:	60 e1       	ldi	r22, 0x10	; 16
    5462:	70 e0       	ldi	r23, 0x00	; 0
    5464:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
	transmitDataBlockOverBluetooth("[2]Remote User\n",16);
    5468:	85 ee       	ldi	r24, 0xE5	; 229
    546a:	95 e0       	ldi	r25, 0x05	; 5
    546c:	60 e1       	ldi	r22, 0x10	; 16
    546e:	70 e0       	ldi	r23, 0x00	; 0
    5470:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
	transmitDataBlockOverBluetooth("[3]Back\n",9);
    5474:	85 ef       	ldi	r24, 0xF5	; 245
    5476:	95 e0       	ldi	r25, 0x05	; 5
    5478:	69 e0       	ldi	r22, 0x09	; 9
    547a:	70 e0       	ldi	r23, 0x00	; 0
    547c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
	transmitDataBlockOverBluetooth("[4]Main\n",9);
    5480:	8e ef       	ldi	r24, 0xFE	; 254
    5482:	95 e0       	ldi	r25, 0x05	; 5
    5484:	69 e0       	ldi	r22, 0x09	; 9
    5486:	70 e0       	ldi	r23, 0x00	; 0
    5488:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				}
				Next = RSt8;
			}
			else
			{
				transmitDataBlockOverBluetooth("NO Remote Users\n",25);
    548c:	0f 2e       	mov	r0, r31
    548e:	f9 e1       	ldi	r31, 0x19	; 25
    5490:	af 2e       	mov	r10, r31
    5492:	bb 24       	eor	r11, r11
    5494:	f0 2d       	mov	r31, r0
				Next = RSt8;
    5496:	0f 2e       	mov	r0, r31
    5498:	fd e1       	ldi	r31, 0x1D	; 29
    549a:	9f 2e       	mov	r9, r31
    549c:	f0 2d       	mov	r31, r0
			}
			break;
		case '2':
			if(ReadUserReomte <=4)
			{
				transmitDataBlockOverBluetooth("User Name\n",11);
    549e:	0f 2e       	mov	r0, r31
    54a0:	f7 e0       	ldi	r31, 0x07	; 7
    54a2:	6f 2e       	mov	r6, r31
    54a4:	f6 e0       	ldi	r31, 0x06	; 6
    54a6:	7f 2e       	mov	r7, r31
    54a8:	f0 2d       	mov	r31, r0
				{
					APP_SystemState();
					APP_TEMP_MOTOR();
					Read = UART_ReceiveCharfrist();
					Read = UART_ReceiveChar();
					if((Read >= '0')&&( Read <= '9'))
    54aa:	c5 01       	movw	r24, r10
    54ac:	ac 82       	std	Y+4, r10	; 0x04
    54ae:	9d 83       	std	Y+5, r25	; 0x05
						{
							if((Read -'0')  == readDataFromEEPROM( (cou * 5) + EEPROM_ADDR_F_UsersRemote))
							{
								count++;
								ReadUserReomte--;
								eeprom_write_byte((uint_8*)EEPROM_ADDR_COUNTER_RU, ReadUserReomte);
    54b0:	44 24       	eor	r4, r4
    54b2:	55 24       	eor	r5, r5
				transmitDataBlockOverBluetooth("NO Remote Users\n",25);
				Next = RSt8;
			}
			break;
		case '3':
			Next = RSt3;
    54b4:	0f 2e       	mov	r0, r31
    54b6:	f8 e1       	ldi	r31, 0x18	; 24
    54b8:	8f 2e       	mov	r8, r31
    54ba:	f0 2d       	mov	r31, r0
				}
				Next = RSt8;
			}
			else
			{
				transmitDataBlockOverBluetooth("NO Keypad Users\n",25);
    54bc:	0f 2e       	mov	r0, r31
    54be:	fa e4       	ldi	r31, 0x4A	; 74
    54c0:	2f 2e       	mov	r2, r31
    54c2:	f6 e0       	ldi	r31, 0x06	; 6
    54c4:	3f 2e       	mov	r3, r31
    54c6:	f0 2d       	mov	r31, r0
    54c8:	d1 c0       	rjmp	.+418    	; 0x566c <APP_StateTrans+0x65e>
	transmitDataBlockOverBluetooth("[1]Keypad User\n",16);
	transmitDataBlockOverBluetooth("[2]Remote User\n",16);
	transmitDataBlockOverBluetooth("[3]Back\n",9);
	transmitDataBlockOverBluetooth("[4]Main\n",9);
	while(!((Read >='0')&&(Read <='9'))){
		APP_SystemState();
    54ca:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
		APP_TEMP_MOTOR();
    54ce:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
		Read = UART_ReceiveCharfrist();
    54d2:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    54d6:	8b 83       	std	Y+3, r24	; 0x03
		switch(Read)
    54d8:	8b 81       	ldd	r24, Y+3	; 0x03
    54da:	82 33       	cpi	r24, 0x32	; 50
    54dc:	09 f4       	brne	.+2      	; 0x54e0 <APP_StateTrans+0x4d2>
    54de:	64 c0       	rjmp	.+200    	; 0x55a8 <APP_StateTrans+0x59a>
    54e0:	83 33       	cpi	r24, 0x33	; 51
    54e2:	20 f4       	brcc	.+8      	; 0x54ec <APP_StateTrans+0x4de>
    54e4:	81 33       	cpi	r24, 0x31	; 49
    54e6:	09 f0       	breq	.+2      	; 0x54ea <APP_StateTrans+0x4dc>
    54e8:	c1 c0       	rjmp	.+386    	; 0x566c <APP_StateTrans+0x65e>
    54ea:	07 c0       	rjmp	.+14     	; 0x54fa <APP_StateTrans+0x4ec>
    54ec:	83 33       	cpi	r24, 0x33	; 51
    54ee:	09 f4       	brne	.+2      	; 0x54f2 <APP_StateTrans+0x4e4>
    54f0:	b8 c0       	rjmp	.+368    	; 0x5662 <APP_StateTrans+0x654>
    54f2:	84 33       	cpi	r24, 0x34	; 52
    54f4:	09 f0       	breq	.+2      	; 0x54f8 <APP_StateTrans+0x4ea>
    54f6:	ba c0       	rjmp	.+372    	; 0x566c <APP_StateTrans+0x65e>
    54f8:	b7 c0       	rjmp	.+366    	; 0x5668 <APP_StateTrans+0x65a>
		{
		case '1':
			if(ReadUserKeypad <=4)
    54fa:	89 81       	ldd	r24, Y+1	; 0x01
    54fc:	85 30       	cpi	r24, 0x05	; 5
    54fe:	08 f0       	brcs	.+2      	; 0x5502 <APP_StateTrans+0x4f4>
    5500:	4c c0       	rjmp	.+152    	; 0x559a <APP_StateTrans+0x58c>
			{
				transmitDataBlockOverBluetooth("User Name\n",11);
    5502:	c3 01       	movw	r24, r6
    5504:	6b e0       	ldi	r22, 0x0B	; 11
    5506:	70 e0       	ldi	r23, 0x00	; 0
    5508:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				count=0;
    550c:	10 92 05 08 	sts	0x0805, r1
    5510:	3c c0       	rjmp	.+120    	; 0x558a <APP_StateTrans+0x57c>
				while(count < 1)
				{
					APP_SystemState();
    5512:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
					APP_TEMP_MOTOR();
    5516:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
					Read = UART_ReceiveCharfrist();
    551a:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    551e:	8b 83       	std	Y+3, r24	; 0x03
					if((Read >= '0')&&( Read <= '9'))
    5520:	8b 81       	ldd	r24, Y+3	; 0x03
    5522:	80 33       	cpi	r24, 0x30	; 48
    5524:	90 f1       	brcs	.+100    	; 0x558a <APP_StateTrans+0x57c>
    5526:	8b 81       	ldd	r24, Y+3	; 0x03
    5528:	8a 33       	cpi	r24, 0x3A	; 58
    552a:	78 f5       	brcc	.+94     	; 0x558a <APP_StateTrans+0x57c>
    552c:	72 01       	movw	r14, r4
					{
						for(cou =0; cou < 5; cou++)
						{
							if((Read -'0') == readDataFromEEPROM( (cou * 5) + EEPROM_ADDR_F_UsersKeypad))
    552e:	0b 81       	ldd	r16, Y+3	; 0x03
    5530:	67 01       	movw	r12, r14
    5532:	c7 01       	movw	r24, r14
    5534:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    5538:	10 e0       	ldi	r17, 0x00	; 0
    553a:	00 53       	subi	r16, 0x30	; 48
    553c:	10 40       	sbci	r17, 0x00	; 0
    553e:	90 e0       	ldi	r25, 0x00	; 0
    5540:	08 17       	cp	r16, r24
    5542:	19 07       	cpc	r17, r25
    5544:	d1 f4       	brne	.+52     	; 0x557a <APP_StateTrans+0x56c>
							{
								count++;
    5546:	80 91 05 08 	lds	r24, 0x0805
    554a:	8f 5f       	subi	r24, 0xFF	; 255
    554c:	80 93 05 08 	sts	0x0805, r24
								ReadUserKeypad--;
    5550:	89 81       	ldd	r24, Y+1	; 0x01
    5552:	81 50       	subi	r24, 0x01	; 1
    5554:	89 83       	std	Y+1, r24	; 0x01
								eeprom_write_byte((uint_8*)EEPROM_ADDR_COUNTER_KU, ReadUserKeypad);
    5556:	69 81       	ldd	r22, Y+1	; 0x01
    5558:	80 e4       	ldi	r24, 0x40	; 64
    555a:	90 e0       	ldi	r25, 0x00	; 0
    555c:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
    5560:	82 01       	movw	r16, r4
								for(uint_8 cou2 =0; cou2 < 5; cou2++)
								{
									eeprom_write_byte((uint_8*)((cou * 5) + EEPROM_ADDR_F_UsersKeypad + cou2 ), 0xff);
    5562:	c8 01       	movw	r24, r16
    5564:	8c 0d       	add	r24, r12
    5566:	9d 1d       	adc	r25, r13
    5568:	6f ef       	ldi	r22, 0xFF	; 255
    556a:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
    556e:	0f 5f       	subi	r16, 0xFF	; 255
    5570:	1f 4f       	sbci	r17, 0xFF	; 255
							if((Read -'0') == readDataFromEEPROM( (cou * 5) + EEPROM_ADDR_F_UsersKeypad))
							{
								count++;
								ReadUserKeypad--;
								eeprom_write_byte((uint_8*)EEPROM_ADDR_COUNTER_KU, ReadUserKeypad);
								for(uint_8 cou2 =0; cou2 < 5; cou2++)
    5572:	05 30       	cpi	r16, 0x05	; 5
    5574:	11 05       	cpc	r17, r1
    5576:	a9 f7       	brne	.-22     	; 0x5562 <APP_StateTrans+0x554>
    5578:	08 c0       	rjmp	.+16     	; 0x558a <APP_StateTrans+0x57c>
    557a:	85 e0       	ldi	r24, 0x05	; 5
    557c:	90 e0       	ldi	r25, 0x00	; 0
    557e:	e8 0e       	add	r14, r24
    5580:	f9 1e       	adc	r15, r25
					APP_SystemState();
					APP_TEMP_MOTOR();
					Read = UART_ReceiveCharfrist();
					if((Read >= '0')&&( Read <= '9'))
					{
						for(cou =0; cou < 5; cou++)
    5582:	99 e1       	ldi	r25, 0x19	; 25
    5584:	e9 16       	cp	r14, r25
    5586:	f1 04       	cpc	r15, r1
    5588:	91 f6       	brne	.-92     	; 0x552e <APP_StateTrans+0x520>
		case '1':
			if(ReadUserKeypad <=4)
			{
				transmitDataBlockOverBluetooth("User Name\n",11);
				count=0;
				while(count < 1)
    558a:	80 91 05 08 	lds	r24, 0x0805
    558e:	88 23       	and	r24, r24
    5590:	09 f4       	brne	.+2      	; 0x5594 <APP_StateTrans+0x586>
    5592:	bf cf       	rjmp	.-130    	; 0x5512 <APP_StateTrans+0x504>
								break;
							}
						}
					}
				}
				Next = RSt8;
    5594:	90 92 06 08 	sts	0x0806, r9
    5598:	69 c0       	rjmp	.+210    	; 0x566c <APP_StateTrans+0x65e>
			}
			else
			{
				transmitDataBlockOverBluetooth("NO Keypad Users\n",25);
    559a:	c1 01       	movw	r24, r2
    559c:	b5 01       	movw	r22, r10
    559e:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				Next = RSt8;
    55a2:	90 92 06 08 	sts	0x0806, r9
    55a6:	62 c0       	rjmp	.+196    	; 0x566c <APP_StateTrans+0x65e>
			}
			break;
		case '2':
			if(ReadUserReomte <=4)
    55a8:	8a 81       	ldd	r24, Y+2	; 0x02
    55aa:	85 30       	cpi	r24, 0x05	; 5
    55ac:	08 f0       	brcs	.+2      	; 0x55b0 <APP_StateTrans+0x5a2>
    55ae:	51 c0       	rjmp	.+162    	; 0x5652 <APP_StateTrans+0x644>
			{
				transmitDataBlockOverBluetooth("User Name\n",11);
    55b0:	c3 01       	movw	r24, r6
    55b2:	6b e0       	ldi	r22, 0x0B	; 11
    55b4:	70 e0       	ldi	r23, 0x00	; 0
    55b6:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				count=0;
    55ba:	10 92 05 08 	sts	0x0805, r1
    55be:	41 c0       	rjmp	.+130    	; 0x5642 <APP_StateTrans+0x634>
				while(count < 1)
				{
					APP_SystemState();
    55c0:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
					APP_TEMP_MOTOR();
    55c4:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
					Read = UART_ReceiveCharfrist();
    55c8:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    55cc:	8b 83       	std	Y+3, r24	; 0x03
					Read = UART_ReceiveChar();
    55ce:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
    55d2:	8b 83       	std	Y+3, r24	; 0x03
					if((Read >= '0')&&( Read <= '9'))
    55d4:	8b 81       	ldd	r24, Y+3	; 0x03
    55d6:	80 33       	cpi	r24, 0x30	; 48
    55d8:	a0 f1       	brcs	.+104    	; 0x5642 <APP_StateTrans+0x634>
    55da:	8b 81       	ldd	r24, Y+3	; 0x03
    55dc:	8a 33       	cpi	r24, 0x3A	; 58
    55de:	88 f5       	brcc	.+98     	; 0x5642 <APP_StateTrans+0x634>
    55e0:	8c 81       	ldd	r24, Y+4	; 0x04
    55e2:	9d 81       	ldd	r25, Y+5	; 0x05
    55e4:	7c 01       	movw	r14, r24
					{
						for(uint_8 cou=0; cou <= 5; cou++)
						{
							if((Read -'0')  == readDataFromEEPROM( (cou * 5) + EEPROM_ADDR_F_UsersRemote))
    55e6:	0b 81       	ldd	r16, Y+3	; 0x03
    55e8:	67 01       	movw	r12, r14
    55ea:	c7 01       	movw	r24, r14
    55ec:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    55f0:	10 e0       	ldi	r17, 0x00	; 0
    55f2:	00 53       	subi	r16, 0x30	; 48
    55f4:	10 40       	sbci	r17, 0x00	; 0
    55f6:	90 e0       	ldi	r25, 0x00	; 0
    55f8:	08 17       	cp	r16, r24
    55fa:	19 07       	cpc	r17, r25
    55fc:	d1 f4       	brne	.+52     	; 0x5632 <APP_StateTrans+0x624>
							{
								count++;
    55fe:	80 91 05 08 	lds	r24, 0x0805
    5602:	8f 5f       	subi	r24, 0xFF	; 255
    5604:	80 93 05 08 	sts	0x0805, r24
								ReadUserReomte--;
    5608:	8a 81       	ldd	r24, Y+2	; 0x02
    560a:	81 50       	subi	r24, 0x01	; 1
    560c:	8a 83       	std	Y+2, r24	; 0x02
								eeprom_write_byte((uint_8*)EEPROM_ADDR_COUNTER_RU, ReadUserReomte);
    560e:	6a 81       	ldd	r22, Y+2	; 0x02
    5610:	81 e4       	ldi	r24, 0x41	; 65
    5612:	90 e0       	ldi	r25, 0x00	; 0
    5614:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
    5618:	82 01       	movw	r16, r4
								for(uint_8 cou2 =0; cou2 < 5; cou2++)
								{
									eeprom_write_byte((uint_8*)( (cou * 5) + EEPROM_ADDR_F_UsersRemote + cou2), 0xff);
    561a:	c8 01       	movw	r24, r16
    561c:	8c 0d       	add	r24, r12
    561e:	9d 1d       	adc	r25, r13
    5620:	6f ef       	ldi	r22, 0xFF	; 255
    5622:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
    5626:	0f 5f       	subi	r16, 0xFF	; 255
    5628:	1f 4f       	sbci	r17, 0xFF	; 255
							if((Read -'0')  == readDataFromEEPROM( (cou * 5) + EEPROM_ADDR_F_UsersRemote))
							{
								count++;
								ReadUserReomte--;
								eeprom_write_byte((uint_8*)EEPROM_ADDR_COUNTER_RU, ReadUserReomte);
								for(uint_8 cou2 =0; cou2 < 5; cou2++)
    562a:	05 30       	cpi	r16, 0x05	; 5
    562c:	11 05       	cpc	r17, r1
    562e:	a9 f7       	brne	.-22     	; 0x561a <APP_StateTrans+0x60c>
    5630:	08 c0       	rjmp	.+16     	; 0x5642 <APP_StateTrans+0x634>
    5632:	25 e0       	ldi	r18, 0x05	; 5
    5634:	30 e0       	ldi	r19, 0x00	; 0
    5636:	e2 0e       	add	r14, r18
    5638:	f3 1e       	adc	r15, r19
					APP_TEMP_MOTOR();
					Read = UART_ReceiveCharfrist();
					Read = UART_ReceiveChar();
					if((Read >= '0')&&( Read <= '9'))
					{
						for(uint_8 cou=0; cou <= 5; cou++)
    563a:	37 e3       	ldi	r19, 0x37	; 55
    563c:	e3 16       	cp	r14, r19
    563e:	f1 04       	cpc	r15, r1
    5640:	91 f6       	brne	.-92     	; 0x55e6 <APP_StateTrans+0x5d8>
		case '2':
			if(ReadUserReomte <=4)
			{
				transmitDataBlockOverBluetooth("User Name\n",11);
				count=0;
				while(count < 1)
    5642:	80 91 05 08 	lds	r24, 0x0805
    5646:	88 23       	and	r24, r24
    5648:	09 f4       	brne	.+2      	; 0x564c <APP_StateTrans+0x63e>
    564a:	ba cf       	rjmp	.-140    	; 0x55c0 <APP_StateTrans+0x5b2>
								break;
							}
						}
					}
				}
				Next = RSt8;
    564c:	90 92 06 08 	sts	0x0806, r9
    5650:	0d c0       	rjmp	.+26     	; 0x566c <APP_StateTrans+0x65e>
			}
			else
			{
				transmitDataBlockOverBluetooth("NO Remote Users\n",25);
    5652:	8b e5       	ldi	r24, 0x5B	; 91
    5654:	96 e0       	ldi	r25, 0x06	; 6
    5656:	b5 01       	movw	r22, r10
    5658:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
				Next = RSt8;
    565c:	90 92 06 08 	sts	0x0806, r9
    5660:	05 c0       	rjmp	.+10     	; 0x566c <APP_StateTrans+0x65e>
			}
			break;
		case '3':
			Next = RSt3;
    5662:	80 92 06 08 	sts	0x0806, r8
    5666:	02 c0       	rjmp	.+4      	; 0x566c <APP_StateTrans+0x65e>
			break;
		case '4':
			Next = RSt3;
    5668:	80 92 06 08 	sts	0x0806, r8
	uint_8 cou =0;
	transmitDataBlockOverBluetooth("[1]Keypad User\n",16);
	transmitDataBlockOverBluetooth("[2]Remote User\n",16);
	transmitDataBlockOverBluetooth("[3]Back\n",9);
	transmitDataBlockOverBluetooth("[4]Main\n",9);
	while(!((Read >='0')&&(Read <='9'))){
    566c:	8b 81       	ldd	r24, Y+3	; 0x03
    566e:	80 33       	cpi	r24, 0x30	; 48
    5670:	08 f4       	brcc	.+2      	; 0x5674 <APP_StateTrans+0x666>
    5672:	2b cf       	rjmp	.-426    	; 0x54ca <APP_StateTrans+0x4bc>
    5674:	8b 81       	ldd	r24, Y+3	; 0x03
    5676:	8a 33       	cpi	r24, 0x3A	; 58
    5678:	08 f0       	brcs	.+2      	; 0x567c <APP_StateTrans+0x66e>
    567a:	27 cf       	rjmp	.-434    	; 0x54ca <APP_StateTrans+0x4bc>
    567c:	9c c1       	rjmp	.+824    	; 0x59b6 <APP_StateTrans+0x9a8>
/*** Ahmed Ashraf___V1 ********************************************************  DONE**/
static state APP_ChangeAdmin_Pass(void)
{
	uint8_t Local_u8password = 0, Local_u8Key = 0 ;
	//uint16_t number = 0;
	transmitDataBlockOverBluetooth("New Pass \n: ",11);
    567e:	8c e6       	ldi	r24, 0x6C	; 108
    5680:	96 e0       	ldi	r25, 0x06	; 6
    5682:	6b e0       	ldi	r22, 0x0B	; 11
    5684:	70 e0       	ldi	r23, 0x00	; 0
    5686:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
    568a:	03 e3       	ldi	r16, 0x33	; 51
    568c:	10 e0       	ldi	r17, 0x00	; 0
	while (Local_u8password < 4)
	{
		Local_u8Key = UART_ReceiveChar();
    568e:	0e 94 02 13 	call	0x2604	; 0x2604 <UART_ReceiveChar>
		if(Local_u8Key >= '0' && Local_u8Key <= '9')
    5692:	68 2f       	mov	r22, r24
    5694:	60 53       	subi	r22, 0x30	; 48
    5696:	6a 30       	cpi	r22, 0x0A	; 10
    5698:	d0 f7       	brcc	.-12     	; 0x568e <APP_StateTrans+0x680>
		{
			//number = number * 10 + (Local_u8password-'0');
			Local_u8password++;
			eeprom_write_byte((uint_8*)(EEPROM_ADDR_F_Admin + Local_u8password), Local_u8Key - '0');
    569a:	c8 01       	movw	r24, r16
    569c:	0e 94 1c 2e 	call	0x5c38	; 0x5c38 <__eewr_byte_m32>
    56a0:	0f 5f       	subi	r16, 0xFF	; 255
    56a2:	1f 4f       	sbci	r17, 0xFF	; 255
static state APP_ChangeAdmin_Pass(void)
{
	uint8_t Local_u8password = 0, Local_u8Key = 0 ;
	//uint16_t number = 0;
	transmitDataBlockOverBluetooth("New Pass \n: ",11);
	while (Local_u8password < 4)
    56a4:	07 33       	cpi	r16, 0x37	; 55
    56a6:	11 05       	cpc	r17, r1
    56a8:	91 f7       	brne	.-28     	; 0x568e <APP_StateTrans+0x680>
			//CLCD_voidSendCommand(0x90 + 10 + Local_u8password);
			//_delay_ms(100);
			//CLCD_voidWriteData('*');
		}
	}
	Next = RSt0;
    56aa:	85 e1       	ldi	r24, 0x15	; 21
		break;
	case RSt8 :
		Next = APP_Admin_Remove_User();
		break;
	case RSt9 :
		Next = APP_ChangeAdmin_Pass();
    56ac:	80 93 06 08 	sts	0x0806, r24
    56b0:	82 c1       	rjmp	.+772    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt10 :
		Next = APP_ControlMenu(User_Remote);
    56b2:	81 e0       	ldi	r24, 0x01	; 1
    56b4:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <APP_ControlMenu>
    56b8:	80 93 06 08 	sts	0x0806, r24
    56bc:	7c c1       	rjmp	.+760    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt11 :
		Next = APP_StatusMenu(User_Remote);
    56be:	81 e0       	ldi	r24, 0x01	; 1
    56c0:	0e 94 97 16 	call	0x2d2e	; 0x2d2e <APP_StatusMenu>
    56c4:	80 93 06 08 	sts	0x0806, r24
    56c8:	76 c1       	rjmp	.+748    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt4 :
		Next = APP_RoomsStatusMenu(User_Keypad);
    56ca:	80 e0       	ldi	r24, 0x00	; 0
    56cc:	0e 94 af 19 	call	0x335e	; 0x335e <APP_RoomsStatusMenu>
    56d0:	80 93 06 08 	sts	0x0806, r24
    56d4:	70 c1       	rjmp	.+736    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt5 :
		/*Door STATUS*/
		Next = APP_DoorStatus(User_Keypad);
    56d6:	80 e0       	ldi	r24, 0x00	; 0
    56d8:	0e 94 21 1c 	call	0x3842	; 0x3842 <APP_DoorStatus>
    56dc:	80 93 06 08 	sts	0x0806, r24
    56e0:	6a c1       	rjmp	.+724    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt6 :
		/*AC STATUS*/
		Next = APP_AC_Status(User_Keypad);
    56e2:	80 e0       	ldi	r24, 0x00	; 0
    56e4:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <APP_AC_Status>
    56e8:	80 93 06 08 	sts	0x0806, r24
    56ec:	64 c1       	rjmp	.+712    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt7 :
		/*DIMMIR STATUS*/
		Next = APP_DimmerStatus(User_Keypad);
    56ee:	80 e0       	ldi	r24, 0x00	; 0
    56f0:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <APP_DimmerStatus>
    56f4:	80 93 06 08 	sts	0x0806, r24
    56f8:	5e c1       	rjmp	.+700    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt8 :
		Next = APP_RoomsControlMenu(User_Keypad);
    56fa:	80 e0       	ldi	r24, 0x00	; 0
    56fc:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <APP_RoomsControlMenu>
    5700:	80 93 06 08 	sts	0x0806, r24
    5704:	58 c1       	rjmp	.+688    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt9 :
		/*Dimmer Control*/
		Next = APP_DimmerControl(User_Keypad);
    5706:	80 e0       	ldi	r24, 0x00	; 0
    5708:	0e 94 de 23 	call	0x47bc	; 0x47bc <APP_DimmerControl>
    570c:	80 93 06 08 	sts	0x0806, r24
    5710:	52 c1       	rjmp	.+676    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt10 :
		/*AC Control*/
		Next = APP_AC_Control(User_Keypad);
    5712:	80 e0       	ldi	r24, 0x00	; 0
    5714:	0e 94 c5 18 	call	0x318a	; 0x318a <APP_AC_Control>
    5718:	80 93 06 08 	sts	0x0806, r24
    571c:	4c c1       	rjmp	.+664    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt12 :
		/*Rooms Control Admin*/
		Next = APP_RoomsControlMenu(Admin);
    571e:	82 e0       	ldi	r24, 0x02	; 2
    5720:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <APP_RoomsControlMenu>
    5724:	80 93 06 08 	sts	0x0806, r24
    5728:	46 c1       	rjmp	.+652    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt13 :
		/*Dimmer Control Admin*/
		Next = APP_DimmerControl(Admin);
    572a:	82 e0       	ldi	r24, 0x02	; 2
    572c:	0e 94 de 23 	call	0x47bc	; 0x47bc <APP_DimmerControl>
    5730:	80 93 06 08 	sts	0x0806, r24
    5734:	40 c1       	rjmp	.+640    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt14 :
		/*AC Control Admin*/
		Next = APP_AC_Control(Admin);
    5736:	82 e0       	ldi	r24, 0x02	; 2
    5738:	0e 94 c5 18 	call	0x318a	; 0x318a <APP_AC_Control>
    573c:	80 93 06 08 	sts	0x0806, r24
    5740:	3a c1       	rjmp	.+628    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	}
	return Next;
}
static state APP_DoorControl(void){
	volatile uint_8 Read = 0;
    5742:	1b 82       	std	Y+3, r1	; 0x03
	uint_8 Count = 1;
	transmitDataBlockOverBluetooth("[1] DOOR OPEN \n",16);
    5744:	89 e7       	ldi	r24, 0x79	; 121
    5746:	96 e0       	ldi	r25, 0x06	; 6
    5748:	60 e1       	ldi	r22, 0x10	; 16
    574a:	70 e0       	ldi	r23, 0x00	; 0
    574c:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
	transmitDataBlockOverBluetooth("[2] DOOR CLOSE \n",17);
    5750:	89 e8       	ldi	r24, 0x89	; 137
    5752:	96 e0       	ldi	r25, 0x06	; 6
    5754:	61 e1       	ldi	r22, 0x11	; 17
    5756:	70 e0       	ldi	r23, 0x00	; 0
    5758:	0e 94 1b 13 	call	0x2636	; 0x2636 <transmitDataBlockOverBluetooth>
		switch(Read)
		{
		case '1' :
			DIO_voidSetPinDirection(DIO_u8PORTD,DIO_PIN5,Output);
			APP_FAST_PWM3_TIMER1();
			Next = RSt15;
    575c:	14 e2       	ldi	r17, 0x24	; 36
	volatile uint_8 Read = 0;
	uint_8 Count = 1;
	transmitDataBlockOverBluetooth("[1] DOOR OPEN \n",16);
	transmitDataBlockOverBluetooth("[2] DOOR CLOSE \n",17);
	while(Count){
		APP_SystemState();
    575e:	0e 94 2a 14 	call	0x2854	; 0x2854 <APP_SystemState>
		APP_TEMP_MOTOR();
    5762:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
		Read = UART_ReceiveCharfrist();
    5766:	0e 94 09 13 	call	0x2612	; 0x2612 <UART_ReceiveCharfrist>
    576a:	8b 83       	std	Y+3, r24	; 0x03
		switch(Read)
    576c:	8b 81       	ldd	r24, Y+3	; 0x03
    576e:	81 33       	cpi	r24, 0x31	; 49
    5770:	51 f0       	breq	.+20     	; 0x5786 <APP_StateTrans+0x778>
    5772:	82 33       	cpi	r24, 0x32	; 50
    5774:	18 f4       	brcc	.+6      	; 0x577c <APP_StateTrans+0x76e>
    5776:	80 33       	cpi	r24, 0x30	; 48
    5778:	91 f7       	brne	.-28     	; 0x575e <APP_StateTrans+0x750>
    577a:	20 c0       	rjmp	.+64     	; 0x57bc <APP_StateTrans+0x7ae>
    577c:	82 33       	cpi	r24, 0x32	; 50
    577e:	69 f0       	breq	.+26     	; 0x579a <APP_StateTrans+0x78c>
    5780:	83 34       	cpi	r24, 0x43	; 67
    5782:	69 f7       	brne	.-38     	; 0x575e <APP_StateTrans+0x750>
    5784:	1f c0       	rjmp	.+62     	; 0x57c4 <APP_StateTrans+0x7b6>
		{
		case '1' :
			DIO_voidSetPinDirection(DIO_u8PORTD,DIO_PIN5,Output);
    5786:	83 e0       	ldi	r24, 0x03	; 3
    5788:	65 e0       	ldi	r22, 0x05	; 5
    578a:	41 e0       	ldi	r20, 0x01	; 1
    578c:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
			APP_FAST_PWM3_TIMER1();
    5790:	0e 94 64 14 	call	0x28c8	; 0x28c8 <APP_FAST_PWM3_TIMER1>
			Next = RSt15;
    5794:	10 93 06 08 	sts	0x0806, r17
    5798:	e2 cf       	rjmp	.-60     	; 0x575e <APP_StateTrans+0x750>
			break;
		case '2' :
			DIO_voidSetPinDirection(DIO_u8PORTD, DIO_PIN5, Output);
    579a:	83 e0       	ldi	r24, 0x03	; 3
    579c:	65 e0       	ldi	r22, 0x05	; 5
    579e:	41 e0       	ldi	r20, 0x01	; 1
    57a0:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
			/* Set PIN SERVO MOTOR LOW*/
			TIMER1_voidSetICR1(0U);
    57a4:	80 e0       	ldi	r24, 0x00	; 0
    57a6:	90 e0       	ldi	r25, 0x00	; 0
    57a8:	0e 94 22 09 	call	0x1244	; 0x1244 <TIMER1_voidSetICR1>
			TIMER1_voidSetOCR1A(0U);
    57ac:	80 e0       	ldi	r24, 0x00	; 0
    57ae:	90 e0       	ldi	r25, 0x00	; 0
    57b0:	0e 94 1c 09 	call	0x1238	; 0x1238 <TIMER1_voidSetOCR1A>
			Count = 0;
			Next = RSt15;
    57b4:	84 e2       	ldi	r24, 0x24	; 36
    57b6:	80 93 06 08 	sts	0x0806, r24
    57ba:	fd c0       	rjmp	.+506    	; 0x59b6 <APP_StateTrans+0x9a8>
			break;
		case '0' :
			Count = 0;
			Next = RSt5;
    57bc:	8a e1       	ldi	r24, 0x1A	; 26
    57be:	80 93 06 08 	sts	0x0806, r24
    57c2:	f9 c0       	rjmp	.+498    	; 0x59b6 <APP_StateTrans+0x9a8>
			break;
		case 'C' :
			Count = 0;
			Next = RSt3;
    57c4:	88 e1       	ldi	r24, 0x18	; 24
    57c6:	80 93 06 08 	sts	0x0806, r24
    57ca:	f5 c0       	rjmp	.+490    	; 0x59b6 <APP_StateTrans+0x9a8>
		/*Door Control*/
		Next = APP_DoorControl();
		break;
	case RSt16 :
		/*Rooms Status Admin*/
		Next = APP_RoomsStatusMenu(Admin);
    57cc:	82 e0       	ldi	r24, 0x02	; 2
    57ce:	0e 94 af 19 	call	0x335e	; 0x335e <APP_RoomsStatusMenu>
    57d2:	80 93 06 08 	sts	0x0806, r24
    57d6:	ef c0       	rjmp	.+478    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt17 :
		/*Dimmer Status Admin*/
		Next = APP_DimmerStatus(Admin);
    57d8:	82 e0       	ldi	r24, 0x02	; 2
    57da:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <APP_DimmerStatus>
    57de:	80 93 06 08 	sts	0x0806, r24
    57e2:	e9 c0       	rjmp	.+466    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt18 :
		/*AC Status Admin*/
		Next = APP_AC_Status(Admin);
    57e4:	82 e0       	ldi	r24, 0x02	; 2
    57e6:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <APP_AC_Status>
    57ea:	80 93 06 08 	sts	0x0806, r24
    57ee:	e3 c0       	rjmp	.+454    	; 0x59b6 <APP_StateTrans+0x9a8>

		break;
	case RSt19 :
		/*Door Status Admin*/
		Next = APP_DoorStatus(Admin);
    57f0:	82 e0       	ldi	r24, 0x02	; 2
    57f2:	0e 94 21 1c 	call	0x3842	; 0x3842 <APP_DoorStatus>
    57f6:	80 93 06 08 	sts	0x0806, r24
    57fa:	dd c0       	rjmp	.+442    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt20 :
		Next = APP_RoomsControlMenu(User_Remote);
    57fc:	81 e0       	ldi	r24, 0x01	; 1
    57fe:	0e 94 97 17 	call	0x2f2e	; 0x2f2e <APP_RoomsControlMenu>
    5802:	80 93 06 08 	sts	0x0806, r24
    5806:	d7 c0       	rjmp	.+430    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt21 :
		/*Dimmer Control*/
		Next = APP_DimmerControl(User_Remote);
    5808:	81 e0       	ldi	r24, 0x01	; 1
    580a:	0e 94 de 23 	call	0x47bc	; 0x47bc <APP_DimmerControl>
    580e:	80 93 06 08 	sts	0x0806, r24
    5812:	d1 c0       	rjmp	.+418    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt22 :
		/*AC Control*/
		Next = APP_AC_Control(User_Remote);
    5814:	81 e0       	ldi	r24, 0x01	; 1
    5816:	0e 94 c5 18 	call	0x318a	; 0x318a <APP_AC_Control>
    581a:	80 93 06 08 	sts	0x0806, r24
    581e:	cb c0       	rjmp	.+406    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt11 :
		Next = APP_ROOM1_Control(User_Keypad);
    5820:	80 e0       	ldi	r24, 0x00	; 0
    5822:	0e 94 c0 1c 	call	0x3980	; 0x3980 <APP_ROOM1_Control>
    5826:	80 93 06 08 	sts	0x0806, r24
    582a:	c5 c0       	rjmp	.+394    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt12 :
		Next = APP_ROOM2_Control(User_Keypad);
    582c:	80 e0       	ldi	r24, 0x00	; 0
    582e:	0e 94 84 1d 	call	0x3b08	; 0x3b08 <APP_ROOM2_Control>
    5832:	80 93 06 08 	sts	0x0806, r24
    5836:	bf c0       	rjmp	.+382    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt13 :
		Next = APP_ROOM3_Control(User_Keypad);
    5838:	80 e0       	ldi	r24, 0x00	; 0
    583a:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <APP_ROOM3_Control>
    583e:	80 93 06 08 	sts	0x0806, r24
    5842:	b9 c0       	rjmp	.+370    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt14 :
		Next = APP_ROOM4_Control(User_Keypad);
    5844:	80 e0       	ldi	r24, 0x00	; 0
    5846:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <APP_ROOM4_Control>
    584a:	80 93 06 08 	sts	0x0806, r24
    584e:	b3 c0       	rjmp	.+358    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt15 :
		Next = APP_ROOM5_Control(User_Keypad);
    5850:	80 e0       	ldi	r24, 0x00	; 0
    5852:	0e 94 c1 1f 	call	0x3f82	; 0x3f82 <APP_ROOM5_Control>
    5856:	80 93 06 08 	sts	0x0806, r24
    585a:	ad c0       	rjmp	.+346    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt17 :
		Next = APP_ROOM1_Status(User_Keypad);
    585c:	80 e0       	ldi	r24, 0x00	; 0
    585e:	0e 94 80 20 	call	0x4100	; 0x4100 <APP_ROOM1_Status>
    5862:	80 93 06 08 	sts	0x0806, r24
    5866:	a7 c0       	rjmp	.+334    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt18 :
		Next = APP_ROOM2_Status(User_Keypad);
    5868:	80 e0       	ldi	r24, 0x00	; 0
    586a:	0e 94 1a 21 	call	0x4234	; 0x4234 <APP_ROOM2_Status>
    586e:	80 93 06 08 	sts	0x0806, r24
    5872:	a1 c0       	rjmp	.+322    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt19 :
		Next = APP_ROOM3_Status(User_Keypad);
    5874:	80 e0       	ldi	r24, 0x00	; 0
    5876:	0e 94 b4 21 	call	0x4368	; 0x4368 <APP_ROOM3_Status>
    587a:	80 93 06 08 	sts	0x0806, r24
    587e:	9b c0       	rjmp	.+310    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt20 :
		Next = APP_ROOM4_Status(User_Keypad);
    5880:	80 e0       	ldi	r24, 0x00	; 0
    5882:	0e 94 4e 22 	call	0x449c	; 0x449c <APP_ROOM4_Status>
    5886:	80 93 06 08 	sts	0x0806, r24
    588a:	95 c0       	rjmp	.+298    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case ESt21 :
		Next = APP_ROOM5_Status(User_Keypad);
    588c:	80 e0       	ldi	r24, 0x00	; 0
    588e:	0e 94 e8 22 	call	0x45d0	; 0x45d0 <APP_ROOM5_Status>
    5892:	80 93 06 08 	sts	0x0806, r24
    5896:	8f c0       	rjmp	.+286    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt23 :
		Next = APP_RoomsStatusMenu(User_Remote);
    5898:	81 e0       	ldi	r24, 0x01	; 1
    589a:	0e 94 af 19 	call	0x335e	; 0x335e <APP_RoomsStatusMenu>
    589e:	80 93 06 08 	sts	0x0806, r24
    58a2:	89 c0       	rjmp	.+274    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt24 :
		/*DIMMIR STATUS*/
		Next = APP_DimmerStatus(User_Remote);
    58a4:	81 e0       	ldi	r24, 0x01	; 1
    58a6:	0e 94 d8 1a 	call	0x35b0	; 0x35b0 <APP_DimmerStatus>
    58aa:	80 93 06 08 	sts	0x0806, r24
    58ae:	83 c0       	rjmp	.+262    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt25 :
		/*AC STATUS*/
		Next = APP_AC_Status(User_Remote);
    58b0:	81 e0       	ldi	r24, 0x01	; 1
    58b2:	0e 94 71 1b 	call	0x36e2	; 0x36e2 <APP_AC_Status>
    58b6:	80 93 06 08 	sts	0x0806, r24
    58ba:	7d c0       	rjmp	.+250    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt26 :
		/*Door STATUS*/
		Next = APP_DoorStatus(User_Remote);
    58bc:	81 e0       	ldi	r24, 0x01	; 1
    58be:	0e 94 21 1c 	call	0x3842	; 0x3842 <APP_DoorStatus>
    58c2:	80 93 06 08 	sts	0x0806, r24
    58c6:	77 c0       	rjmp	.+238    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt27 :
		Next = APP_ROOM1_Control(Admin);
    58c8:	82 e0       	ldi	r24, 0x02	; 2
    58ca:	0e 94 c0 1c 	call	0x3980	; 0x3980 <APP_ROOM1_Control>
    58ce:	80 93 06 08 	sts	0x0806, r24
    58d2:	71 c0       	rjmp	.+226    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt28 :
		Next = APP_ROOM2_Control(Admin);
    58d4:	82 e0       	ldi	r24, 0x02	; 2
    58d6:	0e 94 84 1d 	call	0x3b08	; 0x3b08 <APP_ROOM2_Control>
    58da:	80 93 06 08 	sts	0x0806, r24
    58de:	6b c0       	rjmp	.+214    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt29 :
		Next = APP_ROOM3_Control(Admin);
    58e0:	82 e0       	ldi	r24, 0x02	; 2
    58e2:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <APP_ROOM3_Control>
    58e6:	80 93 06 08 	sts	0x0806, r24
    58ea:	65 c0       	rjmp	.+202    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt30 :
		Next = APP_ROOM4_Control(Admin);
    58ec:	82 e0       	ldi	r24, 0x02	; 2
    58ee:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <APP_ROOM4_Control>
    58f2:	80 93 06 08 	sts	0x0806, r24
    58f6:	5f c0       	rjmp	.+190    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt31 :
		Next = APP_ROOM5_Control(Admin);
    58f8:	82 e0       	ldi	r24, 0x02	; 2
    58fa:	0e 94 c1 1f 	call	0x3f82	; 0x3f82 <APP_ROOM5_Control>
    58fe:	80 93 06 08 	sts	0x0806, r24
    5902:	59 c0       	rjmp	.+178    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt32 :
		Next = APP_ROOM1_Status(Admin);
    5904:	82 e0       	ldi	r24, 0x02	; 2
    5906:	0e 94 80 20 	call	0x4100	; 0x4100 <APP_ROOM1_Status>
    590a:	80 93 06 08 	sts	0x0806, r24
    590e:	53 c0       	rjmp	.+166    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt33 :
		Next = APP_ROOM2_Status(Admin);
    5910:	82 e0       	ldi	r24, 0x02	; 2
    5912:	0e 94 1a 21 	call	0x4234	; 0x4234 <APP_ROOM2_Status>
    5916:	80 93 06 08 	sts	0x0806, r24
    591a:	4d c0       	rjmp	.+154    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt34 :
		Next = APP_ROOM3_Status(Admin);
    591c:	82 e0       	ldi	r24, 0x02	; 2
    591e:	0e 94 b4 21 	call	0x4368	; 0x4368 <APP_ROOM3_Status>
    5922:	80 93 06 08 	sts	0x0806, r24
    5926:	47 c0       	rjmp	.+142    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt35 :
		Next = APP_ROOM4_Status(Admin);
    5928:	82 e0       	ldi	r24, 0x02	; 2
    592a:	0e 94 4e 22 	call	0x449c	; 0x449c <APP_ROOM4_Status>
    592e:	80 93 06 08 	sts	0x0806, r24
    5932:	41 c0       	rjmp	.+130    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt36 :
		Next = APP_ROOM5_Status(Admin);
    5934:	82 e0       	ldi	r24, 0x02	; 2
    5936:	0e 94 e8 22 	call	0x45d0	; 0x45d0 <APP_ROOM5_Status>
    593a:	80 93 06 08 	sts	0x0806, r24
    593e:	3b c0       	rjmp	.+118    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt37 :
		Next = APP_ROOM1_Control(User_Remote);
    5940:	81 e0       	ldi	r24, 0x01	; 1
    5942:	0e 94 c0 1c 	call	0x3980	; 0x3980 <APP_ROOM1_Control>
    5946:	80 93 06 08 	sts	0x0806, r24
    594a:	35 c0       	rjmp	.+106    	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt38 :
		Next = APP_ROOM2_Control(User_Remote);
    594c:	81 e0       	ldi	r24, 0x01	; 1
    594e:	0e 94 84 1d 	call	0x3b08	; 0x3b08 <APP_ROOM2_Control>
    5952:	80 93 06 08 	sts	0x0806, r24
    5956:	2f c0       	rjmp	.+94     	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt39 :
		Next = APP_ROOM3_Control(User_Remote);
    5958:	81 e0       	ldi	r24, 0x01	; 1
    595a:	0e 94 43 1e 	call	0x3c86	; 0x3c86 <APP_ROOM3_Control>
    595e:	80 93 06 08 	sts	0x0806, r24
    5962:	29 c0       	rjmp	.+82     	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt40 :
		Next = APP_ROOM4_Control(User_Remote);
    5964:	81 e0       	ldi	r24, 0x01	; 1
    5966:	0e 94 02 1f 	call	0x3e04	; 0x3e04 <APP_ROOM4_Control>
    596a:	80 93 06 08 	sts	0x0806, r24
    596e:	23 c0       	rjmp	.+70     	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt41 :
		Next = APP_ROOM5_Control(User_Remote);
    5970:	81 e0       	ldi	r24, 0x01	; 1
    5972:	0e 94 c1 1f 	call	0x3f82	; 0x3f82 <APP_ROOM5_Control>
    5976:	80 93 06 08 	sts	0x0806, r24
    597a:	1d c0       	rjmp	.+58     	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt42 :
		Next = APP_ROOM1_Status(User_Remote);
    597c:	81 e0       	ldi	r24, 0x01	; 1
    597e:	0e 94 80 20 	call	0x4100	; 0x4100 <APP_ROOM1_Status>
    5982:	80 93 06 08 	sts	0x0806, r24
    5986:	17 c0       	rjmp	.+46     	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt43 :
		Next = APP_ROOM2_Status(User_Remote);
    5988:	81 e0       	ldi	r24, 0x01	; 1
    598a:	0e 94 1a 21 	call	0x4234	; 0x4234 <APP_ROOM2_Status>
    598e:	80 93 06 08 	sts	0x0806, r24
    5992:	11 c0       	rjmp	.+34     	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt44 :
		Next = APP_ROOM3_Status(User_Remote);
    5994:	81 e0       	ldi	r24, 0x01	; 1
    5996:	0e 94 b4 21 	call	0x4368	; 0x4368 <APP_ROOM3_Status>
    599a:	80 93 06 08 	sts	0x0806, r24
    599e:	0b c0       	rjmp	.+22     	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt45 :
		Next = APP_ROOM4_Status(User_Remote);
    59a0:	81 e0       	ldi	r24, 0x01	; 1
    59a2:	0e 94 4e 22 	call	0x449c	; 0x449c <APP_ROOM4_Status>
    59a6:	80 93 06 08 	sts	0x0806, r24
    59aa:	05 c0       	rjmp	.+10     	; 0x59b6 <APP_StateTrans+0x9a8>
		break;
	case RSt46 :
		Next = APP_ROOM5_Status(User_Remote);
    59ac:	81 e0       	ldi	r24, 0x01	; 1
    59ae:	0e 94 e8 22 	call	0x45d0	; 0x45d0 <APP_ROOM5_Status>
    59b2:	80 93 06 08 	sts	0x0806, r24
		break;

	}
	return Next;
}
    59b6:	80 91 06 08 	lds	r24, 0x0806
    59ba:	0f 90       	pop	r0
    59bc:	0f 90       	pop	r0
    59be:	0f 90       	pop	r0
    59c0:	0f 90       	pop	r0
    59c2:	0f 90       	pop	r0
    59c4:	cf 91       	pop	r28
    59c6:	df 91       	pop	r29
    59c8:	1f 91       	pop	r17
    59ca:	0f 91       	pop	r16
    59cc:	ff 90       	pop	r15
    59ce:	ef 90       	pop	r14
    59d0:	df 90       	pop	r13
    59d2:	cf 90       	pop	r12
    59d4:	bf 90       	pop	r11
    59d6:	af 90       	pop	r10
    59d8:	9f 90       	pop	r9
    59da:	8f 90       	pop	r8
    59dc:	7f 90       	pop	r7
    59de:	6f 90       	pop	r6
    59e0:	5f 90       	pop	r5
    59e2:	4f 90       	pop	r4
    59e4:	3f 90       	pop	r3
    59e6:	2f 90       	pop	r2
    59e8:	08 95       	ret

000059ea <APP_voidIntialize>:
state Current, Next;

/*-------------- APIs Definitions ---------------*/
/********************************************************************************** DONE**/
void APP_voidIntialize(void)
{
    59ea:	0f 93       	push	r16
    59ec:	1f 93       	push	r17
    59ee:	cf 93       	push	r28
    59f0:	df 93       	push	r29
	uint_8 Counter = 0;
	BLUETOOTH_voidInit();
    59f2:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <BLUETOOTH_voidInit>
	CLCD_voidInit();
    59f6:	0e 94 8b 12 	call	0x2516	; 0x2516 <CLCD_voidInit>
	Keypad_voidInit();
    59fa:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <Keypad_voidInit>
	APP_SERVO_INTILIZE();
    59fe:	0e 94 a2 14 	call	0x2944	; 0x2944 <APP_SERVO_INTILIZE>
	ADC_voidInit();
    5a02:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <ADC_voidInit>
	BUZZER_voidInit();
    5a06:	0e 94 d0 12 	call	0x25a0	; 0x25a0 <BUZZER_voidInit>

	TIMER1_voidInit(TIMER1_FAST_PWM_10BIT_MODE,TIMER1_SCALER_64);
    5a0a:	87 e0       	ldi	r24, 0x07	; 7
    5a0c:	63 e0       	ldi	r22, 0x03	; 3
    5a0e:	0e 94 6d 07 	call	0xeda	; 0xeda <TIMER1_voidInit>
	TIMER1_voidOutputCompareInit(TIMER1_OC1_NON_INVERTING_MODE ,TIMER1_OCR1B);
    5a12:	82 e0       	ldi	r24, 0x02	; 2
    5a14:	61 e0       	ldi	r22, 0x01	; 1
    5a16:	0e 94 af 08 	call	0x115e	; 0x115e <TIMER1_voidOutputCompareInit>
	DIO_voidSetPinDirection(DIO_u8PORTD,DIO_PIN4,Output);
    5a1a:	83 e0       	ldi	r24, 0x03	; 3
    5a1c:	64 e0       	ldi	r22, 0x04	; 4
    5a1e:	41 e0       	ldi	r20, 0x01	; 1
    5a20:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>
	DIO_voidSetPinDirection(DIO_u8PORTA, DIO_PIN0, Input);
    5a24:	80 e0       	ldi	r24, 0x00	; 0
    5a26:	60 e0       	ldi	r22, 0x00	; 0
    5a28:	40 e0       	ldi	r20, 0x00	; 0
    5a2a:	0e 94 e4 0d 	call	0x1bc8	; 0x1bc8 <DIO_voidSetPinDirection>

	Motor_void_Intilize();
    5a2e:	0e 94 44 10 	call	0x2088	; 0x2088 <Motor_void_Intilize>
    5a32:	c4 eb       	ldi	r28, 0xB4	; 180
    5a34:	d7 e0       	ldi	r29, 0x07	; 7
	//DIO_voidSetPinDirection(DIO_u8PORTA, DIO_PIN2, Input);

	for(Counter = 0; Counter < 5; Counter++){
    5a36:	09 eb       	ldi	r16, 0xB9	; 185
    5a38:	17 e0       	ldi	r17, 0x07	; 7
		Ecual_Led_Intialize(&LED1[Counter]);
    5a3a:	ce 01       	movw	r24, r28
    5a3c:	0e 94 9d 10 	call	0x213a	; 0x213a <Ecual_Led_Intialize>
    5a40:	21 96       	adiw	r28, 0x01	; 1
	DIO_voidSetPinDirection(DIO_u8PORTA, DIO_PIN0, Input);

	Motor_void_Intilize();
	//DIO_voidSetPinDirection(DIO_u8PORTA, DIO_PIN2, Input);

	for(Counter = 0; Counter < 5; Counter++){
    5a42:	c0 17       	cp	r28, r16
    5a44:	d1 07       	cpc	r29, r17
    5a46:	c9 f7       	brne	.-14     	; 0x5a3a <APP_voidIntialize+0x50>
		Ecual_Led_Intialize(&LED1[Counter]);
	}
	CLCD_voidStoreCustomChar(0, NULLChar);
    5a48:	80 e0       	ldi	r24, 0x00	; 0
    5a4a:	6c ef       	ldi	r22, 0xFC	; 252
    5a4c:	77 e0       	ldi	r23, 0x07	; 7
    5a4e:	0e 94 c0 11 	call	0x2380	; 0x2380 <CLCD_voidStoreCustomChar>
	CLCD_voidStoreCustomChar(1, Body);
    5a52:	81 e0       	ldi	r24, 0x01	; 1
    5a54:	62 ea       	ldi	r22, 0xA2	; 162
    5a56:	77 e0       	ldi	r23, 0x07	; 7
    5a58:	0e 94 c0 11 	call	0x2380	; 0x2380 <CLCD_voidStoreCustomChar>
	CLCD_voidStoreCustomChar(2, DegMark);
    5a5c:	82 e0       	ldi	r24, 0x02	; 2
    5a5e:	6a ea       	ldi	r22, 0xAA	; 170
    5a60:	77 e0       	ldi	r23, 0x07	; 7
    5a62:	0e 94 c0 11 	call	0x2380	; 0x2380 <CLCD_voidStoreCustomChar>
}
    5a66:	df 91       	pop	r29
    5a68:	cf 91       	pop	r28
    5a6a:	1f 91       	pop	r17
    5a6c:	0f 91       	pop	r16
    5a6e:	08 95       	ret

00005a70 <main>:

extern state Current, Next;
extern uint_8 MotorFlag;
int main(){

	APP_voidIntialize();
    5a70:	0e 94 f5 2c 	call	0x59ea	; 0x59ea <APP_voidIntialize>
	APP_voidWelcom();
    5a74:	0e 94 de 13 	call	0x27bc	; 0x27bc <APP_voidWelcom>

	if(0 == readDataFromEEPROM(0x200)){
    5a78:	80 e0       	ldi	r24, 0x00	; 0
    5a7a:	92 e0       	ldi	r25, 0x02	; 2
    5a7c:	0e 94 cb 0c 	call	0x1996	; 0x1996 <readDataFromEEPROM>
    5a80:	88 23       	and	r24, r24
    5a82:	11 f4       	brne	.+4      	; 0x5a88 <main+0x18>
		APP_BlockingMode();
    5a84:	0e 94 f5 24 	call	0x49ea	; 0x49ea <APP_BlockingMode>
	}

	Next = RSt0;
    5a88:	85 e1       	ldi	r24, 0x15	; 21
    5a8a:	80 93 06 08 	sts	0x0806, r24
	APP_voidFirstRun();
    5a8e:	0e 94 97 24 	call	0x492e	; 0x492e <APP_voidFirstRun>

	while(1){
		if(1 == MotorFlag){
    5a92:	80 91 f2 07 	lds	r24, 0x07F2
    5a96:	81 30       	cpi	r24, 0x01	; 1
    5a98:	19 f4       	brne	.+6      	; 0x5aa0 <main+0x30>
			APP_TEMP_MOTOR();
    5a9a:	0e 94 a9 14 	call	0x2952	; 0x2952 <APP_TEMP_MOTOR>
    5a9e:	02 c0       	rjmp	.+4      	; 0x5aa4 <main+0x34>
		}
		else{
			Motor_void_stop();
    5aa0:	0e 94 33 10 	call	0x2066	; 0x2066 <Motor_void_stop>
		}
		Current = Next;
    5aa4:	80 91 06 08 	lds	r24, 0x0806
    5aa8:	80 93 07 08 	sts	0x0807, r24
		Next = APP_StateTrans(Current);
    5aac:	0e 94 07 28 	call	0x500e	; 0x500e <APP_StateTrans>
    5ab0:	80 93 06 08 	sts	0x0806, r24
    5ab4:	ee cf       	rjmp	.-36     	; 0x5a92 <main+0x22>

00005ab6 <__mulsi3>:
    5ab6:	62 9f       	mul	r22, r18
    5ab8:	d0 01       	movw	r26, r0
    5aba:	73 9f       	mul	r23, r19
    5abc:	f0 01       	movw	r30, r0
    5abe:	82 9f       	mul	r24, r18
    5ac0:	e0 0d       	add	r30, r0
    5ac2:	f1 1d       	adc	r31, r1
    5ac4:	64 9f       	mul	r22, r20
    5ac6:	e0 0d       	add	r30, r0
    5ac8:	f1 1d       	adc	r31, r1
    5aca:	92 9f       	mul	r25, r18
    5acc:	f0 0d       	add	r31, r0
    5ace:	83 9f       	mul	r24, r19
    5ad0:	f0 0d       	add	r31, r0
    5ad2:	74 9f       	mul	r23, r20
    5ad4:	f0 0d       	add	r31, r0
    5ad6:	65 9f       	mul	r22, r21
    5ad8:	f0 0d       	add	r31, r0
    5ada:	99 27       	eor	r25, r25
    5adc:	72 9f       	mul	r23, r18
    5ade:	b0 0d       	add	r27, r0
    5ae0:	e1 1d       	adc	r30, r1
    5ae2:	f9 1f       	adc	r31, r25
    5ae4:	63 9f       	mul	r22, r19
    5ae6:	b0 0d       	add	r27, r0
    5ae8:	e1 1d       	adc	r30, r1
    5aea:	f9 1f       	adc	r31, r25
    5aec:	bd 01       	movw	r22, r26
    5aee:	cf 01       	movw	r24, r30
    5af0:	11 24       	eor	r1, r1
    5af2:	08 95       	ret

00005af4 <__udivmodhi4>:
    5af4:	aa 1b       	sub	r26, r26
    5af6:	bb 1b       	sub	r27, r27
    5af8:	51 e1       	ldi	r21, 0x11	; 17
    5afa:	07 c0       	rjmp	.+14     	; 0x5b0a <__udivmodhi4_ep>

00005afc <__udivmodhi4_loop>:
    5afc:	aa 1f       	adc	r26, r26
    5afe:	bb 1f       	adc	r27, r27
    5b00:	a6 17       	cp	r26, r22
    5b02:	b7 07       	cpc	r27, r23
    5b04:	10 f0       	brcs	.+4      	; 0x5b0a <__udivmodhi4_ep>
    5b06:	a6 1b       	sub	r26, r22
    5b08:	b7 0b       	sbc	r27, r23

00005b0a <__udivmodhi4_ep>:
    5b0a:	88 1f       	adc	r24, r24
    5b0c:	99 1f       	adc	r25, r25
    5b0e:	5a 95       	dec	r21
    5b10:	a9 f7       	brne	.-22     	; 0x5afc <__udivmodhi4_loop>
    5b12:	80 95       	com	r24
    5b14:	90 95       	com	r25
    5b16:	bc 01       	movw	r22, r24
    5b18:	cd 01       	movw	r24, r26
    5b1a:	08 95       	ret

00005b1c <__divmodhi4>:
    5b1c:	97 fb       	bst	r25, 7
    5b1e:	09 2e       	mov	r0, r25
    5b20:	07 26       	eor	r0, r23
    5b22:	0a d0       	rcall	.+20     	; 0x5b38 <__divmodhi4_neg1>
    5b24:	77 fd       	sbrc	r23, 7
    5b26:	04 d0       	rcall	.+8      	; 0x5b30 <__divmodhi4_neg2>
    5b28:	e5 df       	rcall	.-54     	; 0x5af4 <__udivmodhi4>
    5b2a:	06 d0       	rcall	.+12     	; 0x5b38 <__divmodhi4_neg1>
    5b2c:	00 20       	and	r0, r0
    5b2e:	1a f4       	brpl	.+6      	; 0x5b36 <__divmodhi4_exit>

00005b30 <__divmodhi4_neg2>:
    5b30:	70 95       	com	r23
    5b32:	61 95       	neg	r22
    5b34:	7f 4f       	sbci	r23, 0xFF	; 255

00005b36 <__divmodhi4_exit>:
    5b36:	08 95       	ret

00005b38 <__divmodhi4_neg1>:
    5b38:	f6 f7       	brtc	.-4      	; 0x5b36 <__divmodhi4_exit>
    5b3a:	90 95       	com	r25
    5b3c:	81 95       	neg	r24
    5b3e:	9f 4f       	sbci	r25, 0xFF	; 255
    5b40:	08 95       	ret

00005b42 <__udivmodsi4>:
    5b42:	a1 e2       	ldi	r26, 0x21	; 33
    5b44:	1a 2e       	mov	r1, r26
    5b46:	aa 1b       	sub	r26, r26
    5b48:	bb 1b       	sub	r27, r27
    5b4a:	fd 01       	movw	r30, r26
    5b4c:	0d c0       	rjmp	.+26     	; 0x5b68 <__udivmodsi4_ep>

00005b4e <__udivmodsi4_loop>:
    5b4e:	aa 1f       	adc	r26, r26
    5b50:	bb 1f       	adc	r27, r27
    5b52:	ee 1f       	adc	r30, r30
    5b54:	ff 1f       	adc	r31, r31
    5b56:	a2 17       	cp	r26, r18
    5b58:	b3 07       	cpc	r27, r19
    5b5a:	e4 07       	cpc	r30, r20
    5b5c:	f5 07       	cpc	r31, r21
    5b5e:	20 f0       	brcs	.+8      	; 0x5b68 <__udivmodsi4_ep>
    5b60:	a2 1b       	sub	r26, r18
    5b62:	b3 0b       	sbc	r27, r19
    5b64:	e4 0b       	sbc	r30, r20
    5b66:	f5 0b       	sbc	r31, r21

00005b68 <__udivmodsi4_ep>:
    5b68:	66 1f       	adc	r22, r22
    5b6a:	77 1f       	adc	r23, r23
    5b6c:	88 1f       	adc	r24, r24
    5b6e:	99 1f       	adc	r25, r25
    5b70:	1a 94       	dec	r1
    5b72:	69 f7       	brne	.-38     	; 0x5b4e <__udivmodsi4_loop>
    5b74:	60 95       	com	r22
    5b76:	70 95       	com	r23
    5b78:	80 95       	com	r24
    5b7a:	90 95       	com	r25
    5b7c:	9b 01       	movw	r18, r22
    5b7e:	ac 01       	movw	r20, r24
    5b80:	bd 01       	movw	r22, r26
    5b82:	cf 01       	movw	r24, r30
    5b84:	08 95       	ret

00005b86 <__prologue_saves__>:
    5b86:	2f 92       	push	r2
    5b88:	3f 92       	push	r3
    5b8a:	4f 92       	push	r4
    5b8c:	5f 92       	push	r5
    5b8e:	6f 92       	push	r6
    5b90:	7f 92       	push	r7
    5b92:	8f 92       	push	r8
    5b94:	9f 92       	push	r9
    5b96:	af 92       	push	r10
    5b98:	bf 92       	push	r11
    5b9a:	cf 92       	push	r12
    5b9c:	df 92       	push	r13
    5b9e:	ef 92       	push	r14
    5ba0:	ff 92       	push	r15
    5ba2:	0f 93       	push	r16
    5ba4:	1f 93       	push	r17
    5ba6:	cf 93       	push	r28
    5ba8:	df 93       	push	r29
    5baa:	cd b7       	in	r28, 0x3d	; 61
    5bac:	de b7       	in	r29, 0x3e	; 62
    5bae:	ca 1b       	sub	r28, r26
    5bb0:	db 0b       	sbc	r29, r27
    5bb2:	0f b6       	in	r0, 0x3f	; 63
    5bb4:	f8 94       	cli
    5bb6:	de bf       	out	0x3e, r29	; 62
    5bb8:	0f be       	out	0x3f, r0	; 63
    5bba:	cd bf       	out	0x3d, r28	; 61
    5bbc:	09 94       	ijmp

00005bbe <__epilogue_restores__>:
    5bbe:	2a 88       	ldd	r2, Y+18	; 0x12
    5bc0:	39 88       	ldd	r3, Y+17	; 0x11
    5bc2:	48 88       	ldd	r4, Y+16	; 0x10
    5bc4:	5f 84       	ldd	r5, Y+15	; 0x0f
    5bc6:	6e 84       	ldd	r6, Y+14	; 0x0e
    5bc8:	7d 84       	ldd	r7, Y+13	; 0x0d
    5bca:	8c 84       	ldd	r8, Y+12	; 0x0c
    5bcc:	9b 84       	ldd	r9, Y+11	; 0x0b
    5bce:	aa 84       	ldd	r10, Y+10	; 0x0a
    5bd0:	b9 84       	ldd	r11, Y+9	; 0x09
    5bd2:	c8 84       	ldd	r12, Y+8	; 0x08
    5bd4:	df 80       	ldd	r13, Y+7	; 0x07
    5bd6:	ee 80       	ldd	r14, Y+6	; 0x06
    5bd8:	fd 80       	ldd	r15, Y+5	; 0x05
    5bda:	0c 81       	ldd	r16, Y+4	; 0x04
    5bdc:	1b 81       	ldd	r17, Y+3	; 0x03
    5bde:	aa 81       	ldd	r26, Y+2	; 0x02
    5be0:	b9 81       	ldd	r27, Y+1	; 0x01
    5be2:	ce 0f       	add	r28, r30
    5be4:	d1 1d       	adc	r29, r1
    5be6:	0f b6       	in	r0, 0x3f	; 63
    5be8:	f8 94       	cli
    5bea:	de bf       	out	0x3e, r29	; 62
    5bec:	0f be       	out	0x3f, r0	; 63
    5bee:	cd bf       	out	0x3d, r28	; 61
    5bf0:	ed 01       	movw	r28, r26
    5bf2:	08 95       	ret

00005bf4 <__eerd_block_m32>:
    5bf4:	dc 01       	movw	r26, r24
    5bf6:	cb 01       	movw	r24, r22

00005bf8 <__eerd_blraw_m32>:
    5bf8:	fc 01       	movw	r30, r24
    5bfa:	e1 99       	sbic	0x1c, 1	; 28
    5bfc:	fe cf       	rjmp	.-4      	; 0x5bfa <__eerd_blraw_m32+0x2>
    5bfe:	06 c0       	rjmp	.+12     	; 0x5c0c <__eerd_blraw_m32+0x14>
    5c00:	ff bb       	out	0x1f, r31	; 31
    5c02:	ee bb       	out	0x1e, r30	; 30
    5c04:	e0 9a       	sbi	0x1c, 0	; 28
    5c06:	31 96       	adiw	r30, 0x01	; 1
    5c08:	0d b2       	in	r0, 0x1d	; 29
    5c0a:	0d 92       	st	X+, r0
    5c0c:	41 50       	subi	r20, 0x01	; 1
    5c0e:	50 40       	sbci	r21, 0x00	; 0
    5c10:	b8 f7       	brcc	.-18     	; 0x5c00 <__eerd_blraw_m32+0x8>
    5c12:	08 95       	ret

00005c14 <__eerd_byte_m32>:
    5c14:	e1 99       	sbic	0x1c, 1	; 28
    5c16:	fe cf       	rjmp	.-4      	; 0x5c14 <__eerd_byte_m32>
    5c18:	9f bb       	out	0x1f, r25	; 31
    5c1a:	8e bb       	out	0x1e, r24	; 30
    5c1c:	e0 9a       	sbi	0x1c, 0	; 28
    5c1e:	99 27       	eor	r25, r25
    5c20:	8d b3       	in	r24, 0x1d	; 29
    5c22:	08 95       	ret

00005c24 <__eewr_block_m32>:
    5c24:	dc 01       	movw	r26, r24
    5c26:	cb 01       	movw	r24, r22
    5c28:	03 c0       	rjmp	.+6      	; 0x5c30 <__eewr_block_m32+0xc>
    5c2a:	2d 91       	ld	r18, X+
    5c2c:	0e 94 1d 2e 	call	0x5c3a	; 0x5c3a <__eewr_r18_m32>
    5c30:	41 50       	subi	r20, 0x01	; 1
    5c32:	50 40       	sbci	r21, 0x00	; 0
    5c34:	d0 f7       	brcc	.-12     	; 0x5c2a <__eewr_block_m32+0x6>
    5c36:	08 95       	ret

00005c38 <__eewr_byte_m32>:
    5c38:	26 2f       	mov	r18, r22

00005c3a <__eewr_r18_m32>:
    5c3a:	e1 99       	sbic	0x1c, 1	; 28
    5c3c:	fe cf       	rjmp	.-4      	; 0x5c3a <__eewr_r18_m32>
    5c3e:	9f bb       	out	0x1f, r25	; 31
    5c40:	8e bb       	out	0x1e, r24	; 30
    5c42:	2d bb       	out	0x1d, r18	; 29
    5c44:	0f b6       	in	r0, 0x3f	; 63
    5c46:	f8 94       	cli
    5c48:	e2 9a       	sbi	0x1c, 2	; 28
    5c4a:	e1 9a       	sbi	0x1c, 1	; 28
    5c4c:	0f be       	out	0x3f, r0	; 63
    5c4e:	01 96       	adiw	r24, 0x01	; 1
    5c50:	08 95       	ret

00005c52 <_exit>:
    5c52:	f8 94       	cli

00005c54 <__stop_program>:
    5c54:	ff cf       	rjmp	.-2      	; 0x5c54 <__stop_program>
